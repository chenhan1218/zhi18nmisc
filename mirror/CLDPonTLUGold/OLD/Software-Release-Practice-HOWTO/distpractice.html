<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML
><HEAD
><TITLE
>制作項目發布包的好經驗</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.59"><LINK
REL="HOME"
HREF="t1.html"><LINK
REL="PREVIOUS"
TITLE="好的開發習慣"
HREF="develpractice.html"><LINK
REL="NEXT"
TITLE="好的文檔編寫慣例"
HREF="documentation.html"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="develpractice.html"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="documentation.html"
>Next &#62;&#62;&#62;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="DISTPRACTICE"
>制作項目發布包的好經驗</A
></H1
><P
>這一章節主要介紹您發布的項目應該具有什么樣的形式，以方便其他人下載、
檢索和解壓。</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="TARBALLS"
>確保tar包解壓時會創建一個獨立的新目錄</A
></H2
><P
>新手常犯的低級錯誤是制作了一個解壓后把文件和目錄直接解壓在當前工作目
錄的tar包，這樣做潛在的危險是會把原來已有的同名文件覆蓋掉。記住，
<I
CLASS="EMPHASIS"
>千萬不要這么干！</I
></P
><P
>而正確的方法是：您的項目的所有檔案都是存放在項目所在目錄下的標准目錄結
構中，這樣tar包就可以解壓在一個特定的目錄下<I
CLASS="EMPHASIS"
>而不是</I
>當前目錄。</P
><P
>這里有一個Makefile文件的技巧示例展示了如何完成打包工作，這里假定您的
項目所在目錄名稱為“foobar”，而SRC變量中是一個包含所有需要發布的文件
列表：</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>foobar-$(VERS).tar.gz:
	@ls $(SRC) | sed s:^:foobar-$(VERS)/: &#62;MANIFEST
	@(cd ..; ln -s foobar foobar-$(VERS))
	(cd ..; tar -czvf foobar/foobar-$(VERS).tar.gz `cat foobar/MANIFEST`)
	@(cd ..; rm foobar-$(VERS))</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="README"
>編寫README文件</A
></H2
><P
>應該有一個名為<TT
CLASS="FILENAME"
>README</TT
>或者<TT
CLASS="FILENAME"
>READ.ME</TT
>的
文件來說明整個源碼的結構信息。古老的傳統告訴我們，勇猛的探索者在解開您的壓
縮文件包后的第一件事情就是找出README文件來閱讀。</P
><P
>README文件中最好應該包括如下信息：</P
><P
></P
><OL
TYPE="1"
><LI
><P
>整個項目的簡介</P
></LI
><LI
><P
>項目的WWW站點所在的URL（如果有的話）</P
></LI
><LI
><P
>指出開發者編譯整個項目所在的系統環境，并指出項目可能潛在的移植性問題</P
></LI
><LI
><P
>重要文件和子目錄的結構信息</P
></LI
><LI
><P
>編譯/安裝步驟說明，或者指明這些信息所在的文件名
（通常是<TT
CLASS="FILENAME"
>INSTALL</TT
>文件）</P
></LI
><LI
><P
>項目主持人和參與者的名單列表，或者指出這些信息所在的文件（通常是<TT
CLASS="FILENAME"
>CREDITS</TT
>文件）</P
></LI
><LI
><P
>最近關于本項目的一些進展情況和新聞，或者指出包含此信息的文件
（通常是<TT
CLASS="FILENAME"
>NEWS</TT
>文件）</P
></LI
></OL
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FILENAMES"
>遵照標准文件命名規則</A
></H2
><P
>“勇猛的探索者”要想閱讀README文件，他們就必須首先瀏覽解壓后項目檔案所
在的根目錄下的文件名。這些文件名本身就在向讀者傳達著許多信息。如果您遵照
標准的命名規則就可以給那些探索者有價值得線索以便他們更好的理解您的意圖。</P
><P
>這里列出了一些標准文件名稱和他們的涵義。當然并不是所有項目發布時都必須
包含所有這些文件。</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>README或READ.ME</DT
><DD
><P
>整個項目的結構信息說明，第一個需要閱讀的文件。</P
></DD
><DT
>INSTALL</DT
><DD
><P
>配置、編譯和安裝該項目的說明信息</P
></DD
><DT
>CREDITS</DT
><DD
><P
>本項目所有貢獻者的列表</P
></DD
><DT
>NEWS</DT
><DD
><P
>本項目最近的一些新聞和進展狀況</P
></DD
><DT
>HISTORY</DT
><DD
><P
>本項目的歷史發展演變記錄</P
></DD
><DT
>COPYING</DT
><DD
><P
>指出本項目采用的許可証條款（通常采用GNU GPL）</P
></DD
><DT
>LICENSE</DT
><DD
><P
>本項目的許可証條款文件</P
></DD
><DT
>MANIFEST</DT
><DD
><P
>本項目的所有文件列表</P
></DD
><DT
>FAQ</DT
><DD
><P
>關于本項目的純文本格式的常見問題解答</P
></DD
><DT
>TAGS</DT
><DD
><P
>為Emacs或vi准備的tag標記文件</P
></DD
></DL
></DIV
><P
>我們可以看出來，全部大寫的文件名一般表示該文件是給人閱讀的文檔，而不
是項目的一個組成部分。</P
><P
>編撰一個FAQ文件可以幫您很多忙。如果某個問題經常被其他人問起，就把這個
問題列入FAQ文件﹔然后指導用戶在向您發文或提交出錯報告前首先閱讀FAQ文
件。一份好的FAQ文件可以給項目維護者減輕好几個數量級的負擔。</P
><P
>另外在每次發布時都保留一個HISTORY文件和NEWS文件，并列明時間信息的做法是非常有
好處的。在所有其他文件中，這兩個文件可以讓您在遇到一些專利侵權法律問題
時有所准備（雖然這種情況至今還沒有發生過，不過最好還是有備無患）。</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="UPGRADEABILITY"
>為項目升級做好准備</A
></H2
><P
>只要您打算為您的項目發布新版本，項目就必定處在不斷的變化之中。有些
變化是不能向前兼容的。因此您必須認真思考安裝程序設計上的問題，就是
說讓同一項目的不同版本的代碼安裝后可以共存在一個系統中。這個問題對
庫項目的發布尤為重要，因為您不能指望所有基于這個庫的應用程序都會緊
跟您的API接口規范的后塵。</P
><P
>Emacs、Python和Qt項目有一套對付這個問題的好辦法，就是讓目錄名中包含
版本號。這里有Qt庫安裝后的目錄結構的例子（${ver}是代表版本號的變量）：</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>/usr/lib/qt
/usr/lib/qt-${ver}
/usr/lib/qt-${ver}/bin          # moc程序所在目錄
/usr/lib/qt-${ver}/lib          # .so共享庫所在目錄
/usr/lib/qt-${ver}/include      # 頭文件所在目錄</PRE
></TD
></TR
></TABLE
><P
>這樣組織目錄結構可以讓多個不同版本的檔案共存。客戶程序可以根據需
要選用具有特定版本號的庫，因此為了不讓這些接口影響客戶程序，還是需
要付出一些小小代價（制定版本號）的。</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RPMS"
>提供RPM包</A
></H2
><P
>安裝可執行文件包（二進制包）的事實標准就是使用RedHat包管理器將可
執行文件打包成 rpm 包。許多流行的GNU/Linux發行版都是這么做的，同時也
有許多發行版雖然主要不是rpm包格式但是也支持rpm包（除了Debian和
Slackware以外，而且Debian還支持rpm的安裝）。
<P
>&#13;<P
>因此一個好的項目除了有tar包的源代碼以外，最好也提供直接可安裝的rpm
包的下載。</P
>

<P
>如果您能把您的源代碼tar包和Makefile文件中用于生成rpm包的相關信息寫
入rpm的spec文件中就再好不過了。spec文件是有著".spec"后綴的文件，這
就是帶 -t 選項的 rpm 命令如何在 tar 包中尋找它的方法。</P
>

<P
>還有一個要點是，您可以用一個腳本程序自動的從Makefile或version.h
文件中找出版本號，并用這個版本號來生成您的spec文件。</P
>

<P
>注：如果您還打算提供源碼的rpm包，最好用BuildRoot工具來將程序編譯
到/tmp或者/var/tmp目錄中。如果不這么做，在安裝過程中執行
make install命令時就會直接將那些源程序直接安裝到最終的目錄位置下。
這樣就會導致即使在發生文件覆蓋沖突，或者您本意并不想裝那個包的
時候，安裝動作依然被執行。因此安裝完成后，文件是被裝到了系統中，
但是系統的RPM數據庫卻并沒有記錄這些信息。這種愚蠢的SRPM安裝動作
是非常危險的，理應避免。</P
>&#13;</P
></P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="develpractice.html"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="t1.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="documentation.html"
>Next &#62;&#62;&#62;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>好的開發習慣</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>好的文檔編寫慣例</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>