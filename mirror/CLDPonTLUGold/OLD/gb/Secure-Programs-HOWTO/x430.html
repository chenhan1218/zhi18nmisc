<HTML
><HEAD
><TITLE
>CGI输入</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.54"><LINK
REL="HOME"
TITLE="Linux和Unix安全编程HOWTO"
HREF="book1.html"><LINK
REL="UP"
TITLE="证实所有的输入"
HREF="c384.html"><LINK
REL="PREVIOUS"
TITLE="文件内容"
HREF="x426.html"><LINK
REL="NEXT"
TITLE="其它输入"
HREF="x436.html"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Linux和Unix安全编程HOWTO</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x426.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 4. 证实所有的输入</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x436.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN430"
>CGI输入</A
></H1
><P
>CGI输入其实是指定的一组环境变量和标准输入。这些值必须被证实。</P
><P
>一个额外的复杂情况是很多CGI输入采用所谓的“URL编码”格式提供，即某些值是以%HH的格式编写的，其中HH是相应字节的十六进制代码。你或着你的CGI库必须正确处理这些输入，先URL解码输入，再检查作为结果的字节值是否可以接受。必须正确处理所有的值，包括可能有问题的值，如%00（NIL）和%0A（换行）。不要对输入多次解码，否则诸如“%2500”的输入会被错误处理（%25会翻译成“%”，结果“%00”又会被错误地翻译成NIL字符）。</P
><P
>CGI脚本一般会受到包含特殊字符输入的攻击；参见上面的说明。</P
><P
>某些HTML表格包括客户端的检查，以去除某些非法值。这种检查对用户可能有些帮助，但对安全性毫无用处，因为攻击者可以直接向WEB服务器发送这样的“非法”字符。如下文说到的那样（在“只信任值得信任的通道”一节），服务器必须对所有输入进行自己的检查。</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x426.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x436.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>文件内容</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c384.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>其它输入</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>