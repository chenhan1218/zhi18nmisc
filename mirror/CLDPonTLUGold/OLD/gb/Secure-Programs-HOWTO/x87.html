<HTML
><HEAD
><TITLE
>安全准则</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.54"><LINK
REL="HOME"
TITLE="Linux和Unix安全编程HOWTO"
HREF="book1.html"><LINK
REL="UP"
TITLE="背景知识"
HREF="c54.html"><LINK
REL="PREVIOUS"
TITLE="背景知识"
HREF="c54.html"><LINK
REL="NEXT"
TITLE="安全程序的类型"
HREF="x127.html"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Linux和Unix安全编程HOWTO</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="c54.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 2. 背景知识</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x127.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN87"
>安全准则</A
></H1
><P
>你需要熟悉许多普遍的安全准则；请查阅诸如[Pfleeger 1997]一类的有关计算机安全的通用读本。计算机安全目标通常由三个总体目标来描述：

<P
></P
><UL
><LI
><P
><I
CLASS="EMPHASIS"
>秘密性</I
>（也被称为秘密），意味着计算系统的内容只能被授权对象访问。</P
></LI
><LI
><P
><I
CLASS="EMPHASIS"
>完整性</I
>，意味着内容只能被授权对象以被授权的方式所修改。</P
></LI
><LI
><P
><I
CLASS="EMPHASIS"
>可用性</I
>，意味着内容可以被授权对象使用。该目标经常提到的反义词就是拒绝服务。</P
></LI
></UL
>


有些人还定义了一些附加安全目标，而其他人则把那些附加目标归为这三个目标的特例。例如，有些人独立地把无拒绝定义为一个目标；这样就能够“证明”某个发送者发送或接收者接收到消息，即使该发送者或接收者随后希望拒绝它。隐私有时也被从秘密性中独立出来；有些人把它定义为保护一个<I
CLASS="EMPHASIS"
>用户</I
>而非数据的秘密性。大多数目标都要求识别和确认，有时这也被单独列为一个目标，而且审计（也被称为负责）经常也是一个可取的安全目标。有时“访问控制”和“可靠性”也被单独列出来。无论把安全目标如何组织在一起，在任何情况下找出程序总的安全目标都是重要的，只有这样才能知道何时可以达到这些目标。</P
><P
>Saltzer [1974]和Saltzer and Schroeder [1975]
列出了以下依然有效的设计安全保护系统的原则：

<P
></P
><UL
><LI
><P
><I
CLASS="EMPHASIS"
>最小特权</I
>。
每个用户和程序在操作时应当使用尽可能少的特权。该原则限制了事故、错误或攻击带来的危害。它还减少了特权程序之间潜在的相互作用，从而使对特权无意的、没必要的或不适当的使用不太可能发生。这种想法还可以引申到程序内部：只有程序中需要那些特权的最小部分才拥有特权。</P
></LI
><LI
><P
><I
CLASS="EMPHASIS"
>机制经济</I
>。
保护系统的设计应当尽可能地简单和小。用他们的话来说，“逐行审阅软件和对硬件进行物理检查一类的技术是实现保护机制所必需的。这样的技术要想成功，小而简单的设计是必不可少的。”</P
></LI
><LI
><P
><I
CLASS="EMPHASIS"
>公开设计</I
>。
保护机制不应该依赖于攻击者的无知。其机制反而应当是公开的，依赖于象密码或密钥这样比较少的（而且容易改变的）项目的保密。公开设计使广泛的公开详细检查成为可能，而且还可以让用户确信所要使用的系统是可以满足需要的。坦白地说，要保持一个广泛应用系统的秘密是不现实的；反向编译和硬件破解能够很快暴露一个产品的任何“秘密”。Bruce Schneier证明了聪明的设计者应当“对任何有关安全的东西都要求公开源码”，以及确保它受到普遍的审核，而且任何找到的问题都已得到修正[Schneier 1999]。</P
></LI
><LI
><P
><I
CLASS="EMPHASIS"
>完全中介</I
>。
每一个访问企图都应该被检查；把认证机制放在不会被推翻的位置上。例如，在客户--服务器模型中，通常服务器应该进行所有的访问检查，因为用户可以构建或修改他们自己的客户程序。</P
></LI
><LI
><P
><I
CLASS="EMPHASIS"
>安全失败的缺省值（例如，基于许可的方案）</I
>。
缺省反应应当是拒绝服务，而且保护系统能随后辨别哪种情况下访问是允许的。</P
></LI
><LI
><P
><I
CLASS="EMPHASIS"
>&#62;特权分离</I
>。
理想情况下，访问对象应当依赖于多个条件，这样破坏一个保护系统并不能进行完全的访问。</P
></LI
><LI
><P
><I
CLASS="EMPHASIS"
>最少的公共机制</I
>。
使共享机制的数量和使用（例如，对/tmp或/var/tmp目录的使用）最小化。共享对象提供了信息流和无意的相互作用的潜在危险通道。</P
></LI
><LI
><P
><I
CLASS="EMPHASIS"
>心理上的接受程度/使用简便</I
>。
人机界面必须设计得易于使用，这样用户就可以按惯例自动地正确使用保护机制。如果安全机制非常符合用户对自己保护目标的想象，错误就很少发生。</P
></LI
></UL
>&#13;</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="c54.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x127.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>背景知识</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c54.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>安全程序的类型</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>