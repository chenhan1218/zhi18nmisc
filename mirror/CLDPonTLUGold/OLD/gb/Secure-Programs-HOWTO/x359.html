<HTML
><HEAD
><TITLE
>动态连接库</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.54"><LINK
REL="HOME"
TITLE="Linux和Unix安全编程HOWTO"
HREF="book1.html"><LINK
REL="UP"
TITLE="Linux和Unix安全特性概要"
HREF="c211.html"><LINK
REL="PREVIOUS"
TITLE="配额与限制"
HREF="x354.html"><LINK
REL="NEXT"
TITLE="审核"
HREF="x378.html"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Linux和Unix安全编程HOWTO</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x354.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 3. Linux和Unix安全特性概要</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x378.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN359"
>动态连接库</A
></H1
><P
>实际上所有程序执行都依赖于库。在包括Linux的大多数现代类Unix系统中，程序缺省使用<I
CLASS="EMPHASIS"
>动态连接库</I
>（DLL）进行编译。这样就可以更新某个库，所有使用该库的程序如果可能的话，都将使用新的（希望有所改进的）版本。</P
><P
>动态连接库通常被放在若干特殊目录下。通常这些目录包括<TT
CLASS="FILENAME"
>/lib</TT
>、<TT
CLASS="FILENAME"
>/usr/lib</TT
>、有关PAM模块的<TT
CLASS="FILENAME"
>/lib/security</TT
>、有关X-windows的<TT
CLASS="FILENAME"
>/usr/X11R6/lib</TT
>和<TT
CLASS="FILENAME"
>/usr/local/lib</TT
>。</P
><P
>对于库的命名和进行库的符号连接有些特殊约定，这样就可以更新库，同时继续支持需要使用不具有反向兼容的老版本库的程序。在执行特定程序时可以覆盖某个指定库，甚至只覆盖某个库里的指定函数。这是类Unix系统相对于类Windows系统的一个实际优点；我相信类Unix系统有一个更好的系统来处理库的更新，这也是Unix和Linux系统被认为比基于Windows的系统更稳定的原因。</P
><P
>在包括所有Linux系统的基于GNU glibc的系统中，程序启动时自动寻找的目录列表存储在文件/etc/ld.so.conf中。很多源于Red Hat的发行版一般在文件<TT
CLASS="FILENAME"
>/etc/ld.so.conf</TT
>中不包含<TT
CLASS="FILENAME"
>/usr/local/lib</TT
>。我认为这是个Bug，要在源于Red Hat的系统里运行很多程序都需要进行一个通用的“修复”，把<TT
CLASS="FILENAME"
>/usr/local/lib</TT
>加入<TT
CLASS="FILENAME"
>/etc/ld.so.conf</TT
>。如果只是想覆盖某个库里的若干函数，而想保留该库的其它部分，可以在<TT
CLASS="FILENAME"
>/etc/ld.so.preload</TT
>中输入要覆盖的库名（.o文件）；这些“预载入”的库会优先于标准库使用。通常这种预载入文件是用于紧急补丁的；发行版在发行时一般不会包含这样的文件。在程序启动时寻找所有这些目录太花时间，所以实际上使用了一个cache管理方法。程序ldconfig(8)缺省读入文件/etc/ld.so.conf，在动态连接目录里建立相应的符号连接（这样就遵循了标准约定），然后把cache写入/etc/ld.so.cache，这样就可以被其它程序使用了。所以一旦增加一个DLL，或删除一个DLL，或者DLL目录集发生改变，ldconfig就要运行一次；在安装库时，运行ldconfig通常是软件包管理程序需要执行的一个步骤。在启动时，程序使用动态加载程序来读入文件/etc/ld.so.cache，然后载入其所需的库。</P
><P
>各种环境变量可以控制这一过程，而且事实上也有允许覆盖此过程的环境变量（所以可以在某次特别的执行过程中临时替换某个不同的库）。在Linux下，环境变量LD_LIBRARY_PATH是一组用逗号隔开的目录，在查找标准目录集之前先查找这些库；这在调试新库或为特殊目的使用非标准库时很有用。变量LD_PRELOAD列出了覆盖标准集的函数所在的目标文件，就像/etc/ld.so.preload一样。</P
><P
>如果不采取特别的措施，允许用户控制动态连接库会对setuid/setgid程序造成灾难性的后果。因此在实现GNU glibc时，如果是setuid或setgid程序，将忽略这些变量（和其它类似的变量），或者严格限制这些变量所起的作用。GNU的glibc库通过检查程序的证明来确定其是否为setuid或setgid程序；如果uid和euid不同，或者gid和egid不同，则库就假设该程序为setuid/setgid程序（或者为其子程序），然后严格限制它控制连接的能力。如果载入GNU的glibc库，就可以看到这种情况；请特别阅读一下文件elf/rtld.c和sysdeps/generic/dl-sysdep.c。这就意味着如果使uid和gid等于euid和egid，再调用程序，这些变量就具有完全的效力。其它类Unix系统处理这些情况有所不同，但原因相同：一个setuid/setgid程序不应受到环境变量集的过分影响。</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x354.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x378.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>配额与限制</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c211.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>审核</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>