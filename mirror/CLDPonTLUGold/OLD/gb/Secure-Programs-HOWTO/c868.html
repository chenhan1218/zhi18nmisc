<HTML
><HEAD
><TITLE
>专题</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.54"><LINK
REL="HOME"
TITLE="Linux和Unix安全编程HOWTO"
HREF="book1.html"><LINK
REL="PREVIOUS"
TITLE="Java"
HREF="x814.html"><LINK
REL="NEXT"
TITLE="随机数"
HREF="x880.html"></HEAD
><BODY
CLASS="CHAPTER"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Linux和Unix安全编程HOWTO</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x814.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x880.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
><A
NAME="AEN868"
>Chapter 10. 专题</A
></H1
><TABLE
BORDER="0"
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
CLASS="EPIGRAPH"
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="LEFT"
VALIGN="TOP"
><I
><P
><I
>Understanding is a fountain of life to those who have it,
but folly brings punishment to fools.</I
></P
></I
></TD
></TR
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="RIGHT"
VALIGN="TOP"
><I
><SPAN
CLASS="ATTRIBUTION"
>Proverbs 16:22 (NIV)</SPAN
></I
></TD
></TR
></TABLE
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="c868.html#AEN873"
>密码</A
></DT
><DT
><A
HREF="x880.html"
>随机数</A
></DT
><DT
><A
HREF="x885.html"
>加密算法与协议</A
></DT
><DT
><A
HREF="x892.html"
>PAM</A
></DT
><DT
><A
HREF="x896.html"
>其它事项</A
></DT
></DL
></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN873"
>密码</A
></H1
><P
>尽可能地不要编写处理密码的代码。特别是对于本地应用程序，尽量依靠普通的用户登录认证。如果应用程序为CGI脚本，则尽量依靠web服务器来提供保护。如果应用程序是在网络上的，避免用明文发送密码（如果可能的话），因为它很容易被网络窥探者俘获并在此后加以利用。使用某些算法的固定密码或使用某种掩护算法来“加密”密码从本质上来说跟用明文发送密码是一样的。</P
><P
>对于网络，至少要考虑使用摘要密码。摘要密码是从散列密码发展来的；一般服务器程序向客户程序发送一些数据（如日期、时间、服务器程序名称），客户程序把该数据与用户密码结合，再用散列处理该值（所谓的“摘要密码”）并把散列处理后的结果回答给服务器程序；服务器程序核实此散列值。这会起作用，因为实际上没有以任何形式发送密码；密码只是用来导出散列值。摘要密码不能被认为是通常意义上的“加密”，甚至在法律限制为了保密进行加密的国家一般也可以接受。摘要密码容易受到主动攻击的威胁，但可以抵御被动的网络窥探者。摘要密码的一个弱点在于服务器必须拥有所有未经散列处理的密码，这使得服务器成为攻击的一个非常诱人的目标。</P
><P
>如果应用程序必须处理密码，应该在使用后立刻重写它们以减少暴露的危险。在Java中，不要用String类型来存储密码，因为String是不可改变的（在收集内存垃圾和重用之前无法重写它们，可能会存在很长时间）。作为替代，在Java中使用char[]来保存密码，这样就可以立刻被重写。
I</P
><P
>如果应用程序允许用户设置密码，则检查密码并只允许“好的”密码（如不在字典中、有特定的最小长度等等）。可以参考一下如下信息
<A
HREF="http://consult.cern.ch/writeup/security/security_3.html"
TARGET="_top"
>http://consult.cern.ch/writeup/security/security_3.html</A
>
以了解如何选择一个好的密码。</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x814.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x880.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Java</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>随机数</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>