<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=gb2312">
 <META NAME="GENERATOR" CONTENT="ZH-SGML-Tools 1.0.9">
 <TITLE> 教堂与市集 (The Cathedral and the Bazaar) : 尽早发表, 经常发表新版本 (Release Early, Release Often)</TITLE>
 <LINK HREF="Cathedral-Bazaar-5.html" REL=next>
 <LINK HREF="Cathedral-Bazaar-3.html" REL=previous>
 <LINK HREF="Cathedral-Bazaar.html#toc4" REL=contents>
<SCRIPT src="../menu.js"> function BeginPage() {} function EndPage() {} </SCRIPT> </HEAD> <BODY bgcolor=#EEEEFF MARGINHEIGHT=0 MARGINWIDTH=0> <SCRIPT>BeginPage(1, 4, 1);</SCRIPT>
<A HREF="Cathedral-Bazaar-5.html"><IMG SRC="../img/next.gif" ALT="Next"></A>
<A HREF="Cathedral-Bazaar-3.html"><IMG SRC="../img/prev.gif" ALT="Previous"></A>
<A HREF="Cathedral-Bazaar.html#toc4"><IMG SRC="../img/toc.gif" ALT="Contents"></A>
<HR>
<H2><A NAME="s4">4. 尽早发表, 经常发表新版本 (Release Early, Release Often)</A></H2>

<P>尽早, 经常发表新版本是 Linux 发展模式中非常重要的一环. 过去, 大部份的
程式发展者 (包括我) 认为这个策略对较大型的专案是不好的, 因为早期的版本
几乎可以定义为多错的版本, 我们并不想把使用者的耐心消磨殆尽.
<P>这个过去的信念加强了软体的发展要用建造教堂的方式的想法. 假如我们极欲
强调的目标是让使用者在软体中发现最少的错误, 那你何不每半年 (或更长) 才
发表一个新版本, 并且在发展新版本的期间, 卖力地除错而累得像条狗似的. 
Emacs 的核心部分 (用 C 语言写的) 就是用这种方式发展的, 但它的 Lisp 程式
库就不是. 因为 Emacs 的 Lisp 资源库不在自由软体基金会的管辖内, 你可以在
其中找到新发展的 Lisp 程式使用, 而不受限於 Emacs 的发表周期.
<P>在 Emacs 的 Lisp 程式库中, 最重要的一个来源是俄亥俄州的 elisp 资源库,
它先前的精神就已经具有今日大规模 Linux 资源库的特色, 但当时我们之中却
很少有人思考过我们到底做了什麽, 甚至想过我们已对自由软体基金会的 ``建造
教堂'' 的发展模式提出质疑. 1992 年左右, 我很认真地要把俄亥俄州 elisp
资源库中许多程式加入 Emacs 正式的 Lisp 程式库中, 但却遭遇到官方的阻碍
而失败了.
<P>但一年之後,  Linux 已受到四方的瞩目, 也带来不同而且更健康的观点,
Linus 的开放性发展策略和 ``建造教堂'' 非常不同. 当时 Linux 的两大资源库
sunsite 和 tsx-11 正在萌芽, 有许多版本在交流著, Linux 核心系统发表新版本
的频繁程度前所未有.
<P>Linus 以最有效的方法, 视使用者为协同发展者:
<P><B>[格言 7] 尽早, 经常发表新版本, 并且倾听使用者的意见.</B>
<P><EM>Release early.  Release often.  And listen to your customers.</EM>
<P>Linus 的创新并不完全在此 (这在 UNIX 世界是行之有年的传统了), 而在於提高
这个做法效力的层次, 使其能匹配他在发展的系统的复杂度. 早期在 1991 年左右
, 许多人都知道他一天内发表一次以上 Linux 核心程式□新版本. 因为他善用网
际网路和协同发展者们合作更胜於其他人.
<P>他能我也能吗? 还是只有像他这样的天才才办得到?
<P>我并不认为如此, 虽然 Linus 是一位很厉害的高手 (在我们之间, 有多少人能够
完整地写出一个具有商品品质的作业系统核心呢? ), 但 Linux 并不是一个空前
耀进的观念, Linus 也并非 (或者说至少目前还不是) 如 Richard Stallman 或
James Cosling (NeWS 和 java 的创始者) 这样的天才创新者, 而我个人认为他
是一位天才工程师, 他有避免程式错误及避免程式发展掉入死胡同的第六感, 和
找到两点间最省力路径的技巧. 事实上, 整个 Linux 的设计中, 我们可以看到
Linus 表现出的品质和他保守而简单的设计取向.
<P>承上所说, 如果快速地发表新版本和彻底地善用网际网路媒介不是突然冒出, 而是
以 Linus 天才工程师洞见所得的最省力路径, 那麽他把网际网路的什麽功用发挥
到最大?
<P>其实问题的本身已反应出答案, Linus 让 Linux 的高手和使用者们经常感觉刺激
和有收获 -- 感觉刺激是因协助发展 Linux 得到自我满足, 感觉有收获是因经常
(甚至每天) 进步的 Linux 帮助他们把工作做得更好.
<P>Linus 想直接将投入除错和发展的 ``人-时'' (person-hours) 数加到最大, 
即使要付出的代价是程式码的不稳定, 或是因一些程式错误被证实无法追踪而
吓走原有的使用者. Linus 会如此做是因为他相信:
<P><B>[格言 8] 以足够多的 ``beta 版'' 测试者和协同发展者做基础, 几乎程式 中的每一个问题都可以很快地找出来, 并且对某些人而言, 针对发现的问题的解决方法是显而易见的.</B>
<P><EM>8. Given a large enough beta-tester and co-developer base, almost
every problem will be characterized quickly and the fix obvious to
someone.</EM>
<P>或者用比较不那麽正式的说法: ``足够多的人来看程式, 
所有的错误都变得浅显'', 我将此命名为 ``Linus 定律''.
<P>我原本先前的论述是: ``某些问题对某些人而言是容易解决的'', 但 Linus 
有不同的意见: ``了解并解决问题的人不一定是第一个发现问题的人'', 
他说: ``有些人发现问题, 有些人解决问题, 我愿正式强调 -- 发现问题是
较大的挑战. '' 而在 Linux 的世界, 发现问题和解决问题的速度都很快.
<P>我想这就是教堂模式和市集模式最主要的不同, 以教堂建造者的观点来看程式
发展, 程式错误和相关问题难以处理, 并隐伏在深处, 需要数个月的工夫仔细察看
来找到它们, 而这对程式发展者的自信少有加许. 发展的期间越长, 一旦经冗长等
待的新版本发表後不如预期完美, 使用者的失望也越大.
<P>另一方面就市集发展模式的观点来看, 它假设程式错误都是显而易见的, 或者说
至少在上千位渴望新版的协同发展者面前, 程式错误很快地都变得浅显, 因此经常
发表新版本是为了获得更多的指正, 以及避免偶尔笨拙的修补.
<P>以上已说明足够 ``Linus 定律''. 如果 ``Linus 定律'' 是假的, 那麽任何像 
Linux 核心程式这样复杂的系统, 并且拥有像 Linux 核心程式这麽多的高手
在发展,  早就因沟通不良及未被发现的程式错误而崩塌. 反过来说如果 
``Linus 定律'' 是真的, 那正可解释为什麽相对地 Linux 比较没有程式错误.
<P>也许 Linus 定律并不是一个惊奇, 社会学家多年前发现到在一群素质相同的观察
家中, 他们共同做出的预测要比其中任一位单独所做的要来得可信. 这被称为 
``Delphi 效应''. 可见 Linus 只是把 ``Delphi 效应'' 用在发展作业系统时
对程式的除错上, 所以 ``Delphi 效应'' 能够克服发展系统的复杂度, 
即使复杂如作业系统核心.
<P><EM>[译注] Delphi 是希腊古都, 以善作预言的 Apollo 神殿而闻名.</EM>
<P>我在此要感谢 Jeff Dutky 
<A HREF="mailto:dutky@wam.umd.edu">dutky@wam.umd.edu</A>, 他指出 ``Linus 定律'' 亦可称
之为 ``程式除错可并行处理''. Jeff 观察到多位程式除错者在工作时需要和一些
程式发展者沟通协调, 但是程式除错者彼此间却不需如此. 所以增加程式除错者
并不会像增加程式发展者那样, 多出平方倍的复杂度和管理成本.
<P>理论上造成程式除错效率减低的原因是多位除错者重复同一件工作, 就实际的情形
而言, 在 Linux 的世界中几乎不会发生这样的状况. ``尽早, 经常发表新版本''
这个策略使得程式错误的修补回馈得很快, 藉此将除错者重复同一件工作
的机会减至最低.
<P>Brooks 曾发表过一个即席的看法, 和 Jeff 的看法相关: ``维护一个广为人用
的程式的总成本通常是发展这个程式成本的百分之四十或更多, 令人讶异的是
这维护成本深受使用者人数的影响, 越多的使用者发现越多的程式错误.''
(这正是我所要强调的)
<P>因为增加越多的使用者, 就会增加考验程式的方法, 所以使用者越多, 发现的程式
错误也越多, 当使用者也是协同发展者时这种效应会再被放大, 每一位使用者以不
同的直觉 , 不同的分析工具, 和不同的角度来标明程式错误, 因为这些不同, 
``Delphi 效应''似乎真的有作用了, 在个别情况下的除错工作, 也因这些不同而
减少重复出力的可能.
<P>所以, 以程式发展者的眼光看来, 增加更多的 beta 版测试者也许不会减少目前藏
在深处的程式错误的复杂度, 但可以增加某位除错者以他的工具程式找到这个程式
错误的机会, 而这个程式错误对这位除错者来说是浅显的.
<P>Linus 也在这种方式上下了赌注.  因为程式都会有错误, Linux 核心程式
以一种特别的方式来定出版本号码, 让使用者可以选择要用上一个比较稳定的版本
, 还是选择错误风险比较高的新版来使用新功能. 这个策略尚未正式为大部分的 
Linux 高手所采行, 但是它也显示出一个事实, 就是使用者可做选择使得这两种版
本都更有吸引力.
<P>
<P>
<HR>
<A HREF="Cathedral-Bazaar-5.html"><IMG SRC="../img/next.gif" ALT="Next"></A>
<A HREF="Cathedral-Bazaar-3.html"><IMG SRC="../img/prev.gif" ALT="Previous"></A>
<A HREF="Cathedral-Bazaar.html#toc4"><IMG SRC="../img/toc.gif" ALT="Contents"></A>
<SCRIPT>EndPage();</SCRIPT>  </BODY>
</HTML>
