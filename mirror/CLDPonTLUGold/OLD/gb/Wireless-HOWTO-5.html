<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=gb2312">
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.16">
 <TITLE>Wireless HOWTO: 无线网路设定</TITLE>
 <LINK HREF="Wireless-HOWTO-6.html" REL=next>
 <LINK HREF="Wireless-HOWTO-4.html" REL=previous>
 <LINK HREF="Wireless-HOWTO.html#toc5" REL=contents>
<SCRIPT src="menu.js"> function BeginPage() {} function EndPage() {} </SCRIPT> </HEAD> <BODY bgcolor=#EEEEFF MARGINHEIGHT=0 MARGINWIDTH=0> <SCRIPT>BeginPage(0, 2, 5);</SCRIPT>
<A HREF="Wireless-HOWTO-6.html"><IMG SRC="img/next.png" ALT="Next"></A>
<A HREF="Wireless-HOWTO-4.html"><IMG SRC="img/prev.png" ALT="Previous"></A>
<A HREF="Wireless-HOWTO.html#toc5"><IMG SRC="img/toc.png" ALT="Contents"></A>
<HR>
<H2><A NAME="s5">5.</A> <A HREF="Wireless-HOWTO.html#toc5">无线网路设定</A></H2>

<H2><A NAME="ss5.1">5.1</A> <A HREF="Wireless-HOWTO.html#toc5.1">基本步骤</A>
</H2>

<P>当你具备了所有的条件之后,你需要按照以下步骤进行设定:
<UL>
<LI>核心的底层设定,如I/O端口,中断, DMA ...)完成后,你应当在开机的时候看到这些,
表示无线网卡被Linux正确识别. </LI>
<LI>为无线网卡设定连接层,比如用"rl2cfg"设定Proxim Symphony 
无线网卡, 你应当为每个无线网卡设定以让它们能进行正常通讯.</LI>
<LI>使用 ifconfig 和 route 更改IP设定.</LI>
<LI>找到最佳运行的决窍,解决资源冲突. 这样你的无线网路以经基本运行起来:
proxy-arp, icmp echo redirect, bridging, channel change 这些方面还要做一些细节的设定,
优化网路,防止异常. </LI>
</UL>
</P>
<P>N.B.: step 1, 2 and 3 correspond to level 1,
2 和 3 基于 ISO/OSI, 
while step 4 is an addendum to solve situation generated by netmask 255.255.255.255.
事实上32bit网路遮罩违反了 ISO/OSI 标准,因为网路强制使用相同的地址对不存在的机器和地址进行广播. </P>
<P>有些人可能反对这种观点,但是如果你用 ISO/OSI 标准设定无线网路,会失去很多个子网路的设定.
每个子网通常丢弃2个IP号(Network and broadcast),并失去IP分配的灵活性(geographically kind). 
你可以在附录中找到有关的描述.
You could notice that step 2 is not present 
in Wired cards 因为那里没有什么详细的设定要做. </P>

<H2><A NAME="ss5.2">5.2</A> <A HREF="Wireless-HOWTO.html#toc5.2">底层核心设定</A>
</H2>

<P>管理机器总会有个问题 : 让核心(or in general)识别你的硬体.</P>
<P>无线网卡更复杂, 因为它们通常是Pcmcia plug, 所以首先得让你的核心识别你的Pcmcia adapter card
, 因此,你可以试著为无线网卡安装特别的硬体驱动程式.</P>

<P> 所以在Pcmcia 设定中你必需:
<UL>
<LI>安装核心源代码 从
<A HREF="http://www.kernel.org ">http://www.kernel.org </A> 到/usr/src/linux (see tar and gzip utilities) </LI>
<LI>安装Pcmcia源代码 
<A HREF="ftp://projects.sourceforge.net/pub/pcmcia-cs">ftp://projects.sourceforge.net/pub/pcmcia-cs</A> 
到/usr/src/pcmcia (see tar and gzip utilities) </LI>
<LI>设定并重新编译核心:read file README in your linux directory (/usr/src/linux) </LI>
<LI>设定并重新编译 Pcmcia 源代码: 在 /usr/src/pcmcia 里使用 configure 和 make.
确定你的驱动程式在那里 另外你还要按指示安装它(usually a tar zxvf driver.tgz under pcmcia dir is sufficient).
然后 "make all" 进行编译最后 "make install".  </LI>
<LI>完成之后你可以在/etc/pcmcia里找到有用的设定程式(文档). </LI>
</UL>
 </P>

<P>在非Pcmcia 模式中:</P>
<P>
<UL>
<LI>如果无线网卡的驱动程式是以Linux源代码的形式出现(99%不是),
你必需将它安装到一个目录当中,编译它.
还要知道挂哪个模组: 使用pcmcia设定你只要运行pcmcia侍服程式(/etc/rc.d/init.d/pcmcia start for RedHat),
其它的使用"modprobe module_name options".在选项中给出无线硬体的I/O端口,IRQ和 data-link 设定 (see Par 5.3)</LI>
<LI>如果出现资源冲突,可以使用以下工具:
<UL>
<LI>"tail /var/log/messages" 列印日志.</LI>
<LI>使用"dmesg"得到更多的资讯. </LI>
<LI>/proc dir: ioports, devices, irq files and driver 
specific sub-directories</LI>
</UL>
</LI>
</UL>
</P>

<H2><A NAME="ss5.3">5.3</A> <A HREF="Wireless-HOWTO.html#toc5.3">数据连接层的设定</A>
</H2>

<P>那是什么?</P>
<P>无线网路只需要相互连接,而你只要设定网路参数.</P>
<P>对于无线网路你先要进行连接的设定:
<UL>
<LI>它属于哪一种无线网路(独立或形组模式)</LI>
<LI>使用哪一个频道</LI>
<LI>它属于哪一个子网路(BSSID),它的ESS ID是多少.</LI>
<LI>它的连接有无加密,加密的程度.</LI>
</UL>
</P>
<P>正如上面那样,许多设定需要调整.
因为无线网路的结构:可能在附近的某一个人,只要对准天线,使用和你一样的协议和一样的TCP/IP设定就可以看到你传输的数据包.</P>
<P>加之, 每个子网路之间可能相互产生冲突,</P>
<P>所以这里:
<UL>
<LI>例如在挂模组的时候这样: "modprobe ray_cs essid='LINUX'" 或者 </LI>
<LI>在运行的时候使用设定工具: "rl2cfg eth1 master". </LI>
</UL>
</P>
<H2><A NAME="ss5.4">5.4</A> <A HREF="Wireless-HOWTO.html#toc5.4">IP 设定</A>
</H2>

<P>这是你将要面对的第三个问题.出现当你的网路遂渐扩大的时候.</P>
<P>Remember Wireless IP Networking doesn't stress you if you don't stress it!
如果你不犯它,它就不会犯你.</P>

<H3>一个简单的构建:</H3>

<P>
<BLOCKQUOTE><CODE>
<PRE>
所有的主机之间是相互可见的.
 
                               A - - - - - C
                                 \       /
                               |   \   /   |
                                     /\
                               |   /    \  |
                                 /       \
                               B - - - - - D
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>这个设定非常简单,不需要特别的设定(IP层),只要给每个主机分配IP地址,设定网路遮罩相同就可以了.</P>

<H3>一个较为复杂的网路:</H3>

<P>
<BLOCKQUOTE><CODE>
<PRE>
A不能直接访问B
 
                                A &lt;- - - -
                              NO\        |
                            TALK\        C
                                \        |
                                B &lt;- - - -
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>A和B只有通过C才能相互访问.</P>
<P>如果网路是形组模式,并且C是基点(Access Point),那么就没有问题.
在独立模式(Adhoc mode) 里你也可以设定一个host做为master (I know the term is not so formal!), 
其它主机都加入以master为中心的无线网路当中. </P>
<P>所有的连接达到了IP层: A 和 B 的界面与 C 相同,它们都与C进行通讯,
这样,如果你试著用A ping B, 你将收到许多来自C的ICMP重定向数据包, 
因为C告诉A,它所要求的对象早已经连入网路.
解决方法: type a "echo 0 > /proc/sys/net/ipv4/conf/ethx/send_redirects" 
( ethx 是 C 同 A 连接的界面) to null all that. </P>

<P>另一个问题:该给A和C怎么分配遮罩? 如果你分配一个遮罩包含A和C,它们将不工作,因为A不使用闸道(C)
但又以未知的MAC地址来发送 ARP 请求. </P>

<P>你可能想过ARP代理,但是没有用.因为代理ARP只在目标与请求的来源使用不同界面的时候对来源进行回应:
this is not the case!! </P>
<P>所以你要设定一个不大相同的庶罩 (Win9x let it be 255.255.255.254, WinNT at least 255.255.255.248)
并保证A和C拥有不相同的网路地址.
<BLOCKQUOTE><CODE>
<PRE>
Examples: 


IP(A) = x.y.z.2/31, IP(B) = x.y.z.3/31. 
This doesn't work cause A asks for B in its network (ARP request) and C doesn't answer cause,
 for it, A and B belong to the same interface (so, no proxy arp). 
IP(A) = x.y.z.1/31, IP(B)= x.y.z.2/31. This works cause A ask to C (send requests to B with C MAC address) for B. 
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>In general with a netmask 255.255.255.254 system works with 2 IP changing only for the final bit. </P>

<P>这都是 TCP/IP 的作用,也是唯一获得最高灵活性的方法. </P>
<P>注意:如果你使用基点(Access Point)(网路使用形组模式)就不会有重定向的问题,
因为问题都在 data-link level 解决了 (几乎所有的基点(Access Point)都扮演网桥的角色...). 
但是基点(Access Point)很昂贵(在 1000 美元或更多)
既便是使用多个无线网卡加上一台 P133 32MB Ram 来代替基点(Access Point)还是很划得来的. </P>

<H3>Internet 接入</H3>

<P>
<BLOCKQUOTE><CODE>
<PRE>
                               A - - - - - C - - Internet
                                 \       /
                               |   \   /   |
                                     /\
                               |   /    \  |
                                 /       \
                               B - - - - - D
                
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>它有多种情况:
<UL>
<LI>C 是唯一的Public IP 地址. 只要在无线网路设定private IP 地址(192.168.x.y for example), 在C上执行 forwarding 和 IP伪装 .
A, B 和 D 将 C 作为缺省的闸道. </LI>
<LI>You have a public netmask visible from Internet and C is your default GW to Internet for the network.
You only need to enable forwarding on C, setting up default GW on A, B and D to point to C.
你拥有Internet的一部分网段.  C 作为无线网路到Internet的默认闸道.
只要在C上执行 forwarding , A, B 和 D 对准 C. </LI>
<LI>You have a public netmask visible from Internet and C is not the default GW to Internet. You have 2 possible solutions: Modify your default GW to let it point to C for your network. Symmetrically you have to let C point to default GW to go to Internet. You could, instead, enable proxy arp feature to C (echo 1 > /proc/sys/net/ipv4/conf/ethx/proxy_arp where ethx is the interface towards the default GW) and set your default GW on C to point to the default GW. Proxy arp is a TCP/IP forcing but works well. </LI>
</UL>
</P>

<H3>有线网路与无线网路的混合</H3>

<P>
<BLOCKQUOTE><CODE>
<PRE>
                                Internet         
                                       \      
                                        \        E
                                         \     /
                                          \  /       Wireless
                               A - - - - - C - - F
                                 \       /   \
                               |   \   /   |   \
                        Wired        /\          G
                               |   /    \  |
                                 /       \
                               B - - - - - D
 
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>现在 C 加入了2个网路: 左边是有线网路 Wire 右边是无线网路 Wiredless .</P>
<P>加上Internet接入,你总共要在C上装三个网卡.</P>
<P>应该如何分配IP地址,你有两个选择:
<BLOCKQUOTE><CODE>
<PRE>
               1.划分成两个子网路:如 192.168.1.0/24 和 192.168.2.0/24. 
                 这种方法很快但如果你使用Internet IP地址就失去了灵活性.
                 因为你要丢掉很多的IP.
 
               2. Enable Proxy Arp feature to C for all 2 interfaces. 
无线网路 和 有线网路的 网路参数(net address and netmask) 相同, 
但是使用 proxy-arp,我可以选择哪一个IP分配给有线和哪一个分配给无线. 
</PRE>
</CODE></BLOCKQUOTE>
</P>
<H3>现在我们来检查一下第2个方案:</H3>

<P>例子:现在你有一个 Internet public 子网路 x.y.z.0/24.
<BLOCKQUOTE><CODE>
<PRE>
它们的界面是:

1. ifconfig eth0 x.y.z.C netmask 255.255.255.255 (Wired) 
2. ifconfig eth1 x.y.z.C netmask 255.255.255.255 (Wireless) 
3. ifconfig eth2 x.y.z.C netmask 255.255.255.255 (to Internet) 
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
在eth2上使用静态路由

route add IPGW dev eth2 
route add default gw IPGW 
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>这个路由使所有访问Internet的请求发往闸道:像你注意到的那样, 
第一,告诉Linux路由器在哪里,然后让请求发往路由器. </P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
在eth0上使用静态路由
Static routes on eth0:
route add x.y.z.A dev eth0 
route add x.y.z.B dev eth0 
route add x.y.z.D dev eth0 
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
在eth0上使用静态路由
Static routes on eth1:
route add x.y.z.E dev eth1 
route add x.y.z.F dev eth1 
route add x.y.z.G dev eth1 
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>主机E,F 和G 连入无线网路.</P>


<P>注意: 灵活性相当好,但是你要手工设定每一个主机.</P>

<HR>
<A HREF="Wireless-HOWTO-6.html"><IMG SRC="img/next.png" ALT="Next"></A>
<A HREF="Wireless-HOWTO-4.html"><IMG SRC="img/prev.png" ALT="Previous"></A>
<A HREF="Wireless-HOWTO.html#toc5"><IMG SRC="img/toc.png" ALT="Contents"></A>
<SCRIPT>EndPage();</SCRIPT>  </BODY>
</HTML>
