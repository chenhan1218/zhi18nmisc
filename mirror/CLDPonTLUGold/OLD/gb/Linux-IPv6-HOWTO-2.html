<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=gb2312">
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.16">
 <TITLE>Linux IPv6 HOWTO: 什么是IPv6?</TITLE>
 <LINK HREF="Linux-IPv6-HOWTO-3.html" REL=next>
 <LINK HREF="Linux-IPv6-HOWTO-1.html" REL=previous>
 <LINK HREF="Linux-IPv6-HOWTO.html#toc2" REL=contents>
<SCRIPT src="menu.js"> function BeginPage() {} function EndPage() {} </SCRIPT> </HEAD> <BODY bgcolor=#EEEEFF MARGINHEIGHT=0 MARGINWIDTH=0> <SCRIPT>BeginPage(0, 2, 5);</SCRIPT>
<A HREF="Linux-IPv6-HOWTO-3.html"><IMG SRC="img/next.png" ALT="Next"></A>
<A HREF="Linux-IPv6-HOWTO-1.html"><IMG SRC="img/prev.png" ALT="Previous"></A>
<A HREF="Linux-IPv6-HOWTO.html#toc2"><IMG SRC="img/toc.png" ALT="Contents"></A>
<HR>
<H2><A NAME="s2">2.</A> <A HREF="Linux-IPv6-HOWTO.html#toc2">什么是IPv6?</A></H2>

<P>IPv6是新的第三层传输协议(参考http://www.linuxports.com/howto/intro_to_networking/c4412.htm#PAGE103HTML),它将用来取代IPv4(也叫做IP).</P>
<P>IPv4是很早以前设计的,现在对IPv4提供更多的地址和性能方面有著更高的要求. 
在IPv6中主要的变革是重新设计了报头. 包括将地址位的大小从32 bits 增加到 128 bits.
因为第三层传输主要负责end-to-end(端对端)基于地址的数据包路由.
它必需包含新的IPv6地址(来源和目标),这点就像IPv4一样.</P>
<P>下面这个连结提供了更多有关IPv6的资讯, 和RFC 的例表等等:</P>
<P>http://www.switch.ch/lan/ipv6/references.html</P>


<H2><A NAME="ss2.1">2.1</A> <A HREF="Linux-IPv6-HOWTO.html#toc2.1">IPv6在Linux作业系统上的历史</A>
</H2>

<P>将要做的: 更好的时间排列, 更多的内容...</P>



<H2><A NAME="ss2.2">2.2</A> <A HREF="Linux-IPv6-HOWTO.html#toc2.2">开始</A>
</H2>

<P>第一次将与IPv6有关的代码加入 Linux kernel 2.1.8 的工作是由Pedro Roque<BR>
在1996年11月完成的. 它基于BSD API:
<BLOCKQUOTE><CODE>
<HR>
<PRE>
diff -u --recursive --new-file v2.1.7/linux/include/linux/in6.h
 linux/include/linux/in6.h 
--- v2.1.7/linux/include/linux/in6.h Thu Jan 1 02:00:00 1970 
+++ linux/include/linux/in6.h Sun Nov 3 11:04:42 1996 
@@ -0,0 +1,99 @@ 
+/* 
+ * Types and definitions for AF_INET6 
+ * Linux INET6 implementation 
+ * + * Authors: 
+ * Pedro Roque &lt;******> 
+ * 
+ * Source: 
+ * IPv6 Program Interfaces for BSD Systems 
+ * &lt;draft-ietf-ipngwg-bsd-api-05.txt>
 
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>
<P>以上的代码来自patch-2.1.8  (e-mail 地址在复制&amp;贴上时漏掉了)</P>

<H2><A NAME="ss2.3">2.3</A> <A HREF="Linux-IPv6-HOWTO.html#toc2.3">其间</A>
</H2>

<P>因为缺少人手, 在核心加入IPv6的计划不能按照讨论的或新的RFCs执行.</P>
<P>在2000年的10月, 一个叫做USAGI(http://www.linux-ipv6.org/)的计划在日本正式启动. 
目标是执行所有不见了的, 搁浅的(IPv6 support in Linux)计划. 
计划紧随 KAME project (http://www.kame.net/) 的脚步. 依据 vanilla Linux 
核心源代码进行遂步的改动.</P>


<H2><A NAME="ss2.4">2.4</A> <A HREF="Linux-IPv6-HOWTO.html#toc2.4">现在</A>
</H2>

<P>不幸的是 USAGI 的 patch(补丁)很大, Linux networking 
维护人员无法将它包含进现在Linux 2.4.x 系列的源代码当中去.
因此2.4.x 失去了一些(多数)括展性, 并且不支持所有当前的设计和RFCs.
这导致了它和其它作业系统会产生一些协同问题.</P>


<H2><A NAME="ss2.5">2.5</A> <A HREF="Linux-IPv6-HOWTO.html#toc2.5">将来</A>
</H2>

<P>USAGI 现在正在将当前的括展加入到 Linux 2.5.x 核心当中. </P>
<P>希望2.6.x 系列核心能有一个真正和最新的IPv6功能.</P>

<H2><A NAME="ss2.6">2.6</A> <A HREF="Linux-IPv6-HOWTO.html#toc2.6">IPv6 的地址会是什么样 ?</A>
</H2>

<P>刚才提过, IPv6 的地址有128 bits 长. 这样的 bits 可以产生39个十进字数字:
<BLOCKQUOTE><CODE>
<HR>
<PRE>
2^128-1: 340282366920938463463374607431768211455
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>

<P>这样的地址很难记得住. IPv6的地址是逐位定位的(就像IPv4, 但这个观点不是公认的).
所以十六进制能更好地代表这些数字, 
4 bits(也叫做"nibble")表现为数字(0-9)或字符 a-f(10-15). 
这种格式将IPv6的地址长度缩减到个32字符.</P>
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
2^128-1: 0xffffffffffffffffffffffffffffffff
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>

<P>这种表现形式仍然很不方便. 
(可能混淆或遗漏单个十六进制数字),
所以IPv6的设计者将地址形式定为每16bit就用":"区分开来.
开头的"0x"(在程式设计当中用来表示十六进制数值)被移除了:
<BLOCKQUOTE><CODE>
<HR>
<PRE>
2^128-1: ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>


<P>一个有效的地址(稍后请看地址类型)如下:
<BLOCKQUOTE><CODE>
<HR>
<PRE>
3ffe:ffff:0100:f101:0210:a4ff:fee3:9566
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>

<P>为了简化, 每个16bit开头的0可以被省略:</P>
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
3ffe:ffff:0100:f101:0210:a4ff:fee3:9566  -> 
 3ffe:ffff:100:f101:210:a4ff:fee3:9566
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>

<P>连续的并且数值为0的16bit地址段可以用"::"表示. 
但是一个IPv6地址当中只能出现一次, 不然这种方法保持不了多久.</P>
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
3ffe:ffff:100:f101:0:0:0:1  ->  3ffe:ffff:100:f101::1
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>

<P>简化得最短的IPv6 localhost地址:
<BLOCKQUOTE><CODE>
<HR>
<PRE>
0000:0000:0000:0000:0000:0000:0000:0001  ->  ::1
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>

<P>这种方法也叫做 compact (base85 coded) representation defined RFC 1924 / 
A IPv6紧凑地址表示法(定于1996), 但没有提起过, 例如:
<BLOCKQUOTE><CODE>
<HR>
<PRE>
# ipv6calc --addr_to_base85 3ffe:ffff:0100:f101:0210:a4ff:fee3:9566 
Itu&amp;-ZQ82s>J%s99FJXT
 
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>

<P>资讯: ipv6calc 是一个IPv6地址格式的计算和转换的计划,
您可以在这里找到: http://www.bieringer.de/linux/IPv6/ipv6calc/</P>


<H2><A NAME="ss2.7">2.7</A> <A HREF="Linux-IPv6-HOWTO.html#toc2.7">FAQ(基础)</A>
</H2>

<H3>为什么叫IPv6,而不能成为IPv4之后的IPv5 ?</H3>

<P>在任何IP头, 前4bits 是为协议版本号所保留的. 
所以理论上一个协议的版本号在0和15之间是有效的:</P>
<P>
<UL>
<LI>4 己经为IPv4所使用.</LI>
<LI>5 为 Stream 协议所保留(STP, RFC 1819 http://rfc.net/rfc1819.html 
没有公开过)</LI>
</UL>
</P>
<P> IPv4之后可用的版本号是6, 因此 IPv6 就这样旦生了!</P>

<H3>IPv6 地址: 为什么会有这么长的bits</H3>

<P>在设计IPv4的时候,人们认为32bit的长度足够全世界使用. 看一看这些年, 32bit 
就现在和未来几年来说是足够的. 然而, 32bits 
不能在将来满足全球各种网路设备对IP地址的需求. 想一想将来要连结网路的移动电话, 汽车(包括电子总控系统),
烤面包机,冰箱, 照明开关...</P>

<P>所以设计者采用了128bits, 是今天IPv4 大小(2^96)与长度的4倍.</P>

<P>实际使用的大小可能比它看起来的还要小. 因为现在的定义地址设计,
64bits 用于interface identifiers(界面标识).
另外64bits用于路由. 寄于现在严格的层数集合(/48, /35, ...), 
IPv6 所能提供的地址空间还是可能不够, 希望这种情况不要在往后的几年里发生.</P>


<H3>IPv6 地址: 为什么在新的设计里bits这么小?</H3>

<P>虽然, (可能)有些人(在Internet里)考虑IPv8和IPv6,
设计无论从接受和执行都是那么的遥远. 
在此其间128bit对于报头和数据传输来说是最佳的选择.</P>

<P>考虑到在IPv4里和IPv6里的最大/最小传输单位(MTU,它们分别是576byte 和 1280 byte),
IPv4 的报头是20 byte(最小值,可以通过调节IPv4的选项增大到60byte),
IPv6 的报头是48 byte(固定不变的), 报头分别占它们MTU的3.4%和3.8%,
这意昧著报头占了很大一部分开销. 更大bits的地址需要更大的报头,因而占据更大的开销.</P>
<P>同样,顾及到MTU正常连结的最大值(像现在的以太网):
1500byte(除了特别的列子:9k byte 应用在 Jumbo frames 当中).
最终,如果要传输在第三层数据包中占10%或20%报头,
这样的IP地址在设计上也就没有意义了.</P>


<HR>
<A HREF="Linux-IPv6-HOWTO-3.html"><IMG SRC="img/next.png" ALT="Next"></A>
<A HREF="Linux-IPv6-HOWTO-1.html"><IMG SRC="img/prev.png" ALT="Previous"></A>
<A HREF="Linux-IPv6-HOWTO.html#toc2"><IMG SRC="img/toc.png" ALT="Contents"></A>
<SCRIPT>EndPage();</SCRIPT>  </BODY>
</HTML>
