<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=gb2312">
 <META NAME="GENERATOR" CONTENT="ZH-SGML-Tools 1.0.9">
 <TITLE>Linux以太网-HOWTO: 技术信息</TITLE>
 <LINK HREF="Ethernet-HOWTO-8.html" REL=next>
 <LINK HREF="Ethernet-HOWTO-6.html" REL=previous>
 <LINK HREF="Ethernet-HOWTO.html#toc7" REL=contents>
<SCRIPT src="menu.js"> function BeginPage() {} function EndPage() {} </SCRIPT> </HEAD> <BODY bgcolor=#EEEEFF MARGINHEIGHT=0 MARGINWIDTH=0> <SCRIPT>BeginPage(0, 2, 5);</SCRIPT>
<A HREF="Ethernet-HOWTO-8.html"><IMG SRC="img/next.gif" ALT="Next"></A>
<A HREF="Ethernet-HOWTO-6.html"><IMG SRC="img/prev.gif" ALT="Previous"></A>
<A HREF="Ethernet-HOWTO.html#toc7"><IMG SRC="img/toc.gif" ALT="Contents"></A>
<HR>
<H2><A NAME="tech-intro"></A> <A NAME="s7">7. 技术信息</A></H2>

<P>
<P>对于那些想了解更多有关网卡如何工作、或如何使用现有驱动程序，以及试图为目前不支持的网卡编写自己的驱动程序的人来说，这些信息应该会有用。如果你没有这种想法，那么最好跳过这一节。
<P>
<H2><A NAME="data-xfer"></A> <A NAME="ss7.1">7.1 可编程I/O、共享内存与DMA</A>
</H2>

<P>
<P>如果已经可以发送接收背靠背数据包，就无法把更多的数据放到网络上。每一个现代以太网卡都可以接收背靠背数据包。Linux的DP8390驱动程序（wd80x3、SMC-Ultra、3c503、ne2000，等等）非常接近于发送背靠背数据包（依赖于当前的中断延迟），3c509和AT1500的硬件在自动发送背靠背数据包上没有一点问题。
<P>
<P>
<H3>可编程I/O（如NE2000、3c509）</H3>

<P>
<P>优点：没有使用任何受限制的系统资源，只用了若干I/O寄存器，而且没有16M的限制。
<P>缺点：一般传输速率较慢，CPU需要等待，几乎不可能访问交叉的数据包。
<P>
<H3>共享内存（如WD80x3、SMC-Ultra、3c503）</H3>

<P>
<P>优点：简单，比可编程I/O速度快，允许随机访问数据包。在可能的情况下，Linux驱动程序在从网卡复制出接收的IP数据包时计算其校验和，从而比相应的PIO网卡进一步减少了对CPU的占用。
<P>缺点：占用内存空间（对DOS用户来说是个大问题，在Linux下没有问题），依然要占用CPU。
<P>
<H3>从属（普通）的直接内存存取（Linux下没有这种情况！）</H3>

<P>
<P>优点：在实际数据传递过程中不占用CPU。
<P>缺点：检查边界条件、分配相邻的缓存和DMA寄存器编程使该方法成为最慢的技术。它还占用了一个珍贵的DMA通道，并要求对齐的低端内存缓存。
<P>
<H3><A NAME="master"></A> 总线控制的直接内存存取（如LANCE、DEC 21040）</H3>

<P>
<P>优点：在数据传输过程中不占用CPU，可以把缓存串起来，CPU时间很少或没有花费在ISA总线上。大多数总线控制的Linux驱动程序现在使用一种“copybreak”方案，较大的数据包直接从网卡放进内核的网络缓存，小的数据包被CPU复制到cache里进行下一步的处理。
<P>缺点：（只适用于ISA总线的网卡）网卡要求低端内存缓存和一个DMA通道。任何总线控制器在与其它强占总线的总线控制器，如某些古老的SCSI适配器，一起工作时都会出问题。有几个设计低劣的主板芯片组在与总线控制器一起使用时也有麻烦。不使用<EM>任何</EM>类型的DMA设备的一个原因是使用了为代替386设计的486处理器插件：这些处理器在每个DMA周期都必须刷新cache。（这其中包括Cx486DLC、Ti486DLC、Cx486SLC、Ti486SLC，等等。）
<P>
<P>
<H2><A NAME="ss7.2">7.2 涉及总线带宽的性能</A>
</H2>

<P>
<P>ISA总线能达到5.3MB/sec (42Mb/sec)，听起来对10Mbps以太网是足够了。对于100Mbps网卡，显然需要更快的总线以利用网络带宽。
<P>
<H3><A NAME="8-vs-16"></A> 8比特ISA网卡与16比特ISA网卡</H3>

<P>
<P>你可能不会再买一个新的8比特ISA以太网卡了，但在随后几年间你会在计算机物物交换市场一类的地方发现很多很便宜的这种卡。这使得它们在“家用以太网”系统中很常见。对于16比特的ISA网卡来说也是一样的，因为现在PCI卡已经很普遍了。
<P>对于较低或平均的应用，一些可以提供足够性能的8比特网卡是wd8003、3c503和ne1000。3c501的性能较差，而且要避免使用那些12年前XT时代的低性能纪念品。（可以把它们送给Alan，他在收集这种网卡......）
<P>8比特的数据通道不会对性能造成太大损害，你依然可以从一个较快主机上的8比特wd8003网卡（使用快的ISA总线）上获得大约500到800kB/s的ftp下载速度。如果你的所有网络流量几乎都是来自远端站点，那么数据通道上的瓶颈将发生在其它地方，只有在进行本地子网操作时你才会注意到不同网卡间的速度差别。
<P>
<H2><A NAME="ss7.3">7.3 32比特(VLB/EISA/PCI)以太网卡</A>
</H2>

<P>
<P>注意，10Mbs网络通常并不一定要求32比特的接口。参见
<A HREF="#data-xfer">可编程I/O、共享内存与DMA</A>以了解为什么8MHz的ISA总线上的10Mbps以太网卡并非真正的瓶颈。尽管使用快的总线的以太网卡并不一定带来更快的数据传输，但会减少CPU负载，这对多用户系统来说是件好事。当然，对于现在普通的100Mbps网络，32比特接口是充分使用全部带宽的必要条件。
<P>
<H2><A NAME="skel"></A> <A NAME="ss7.4">7.4 编写驱动程序</A>
</H2>

<P>
<P>在Linux下使用以太网卡所必需的只不过是相应的驱动程序。因此，关键是制造商要向公众公开编程的技术资料，而无需你（或其他什么人）签署什么协议。关于获取资料的可能性（也许你不编写代码，那么就是其他人编写你确实需要的驱动程序的可能性），一个较好的指南是Crynwr (昵称Clarkson)的包驱动程序的可用性。Russ Nelson在干这些事，对开发Linux驱动程序很有帮助。<EM>网上冲浪者</EM>可以试著用下面的URL看一下Russ的软件。
<P>
<A HREF="http://www.crynwr.com">Russ Nelson's Packet Drivers</A><P>有了资料，就可以为网卡编写驱动程序并在Linux下使用（至少从理论上来说是这样）。记住，有些为XT一类机器设计的老式硬件在Linux这样的多任务环境下工作得不是很好。如果网络流量较大，使用这些网卡会带来大麻烦。
<P>大多数网卡都带有如NDIS和ODI一类的MS-DOS接口的驱动程序，但对Linux没有用。许多人建议直接链接它们或自动翻译一下，但这几乎是不可能的。MS-DOS驱动程序需要工作在16比特模式，并依赖于“软件中断”，这二者与Linux内核不兼容。这种不兼容实际上是Linux的一个特性，有些Linux驱动程序比其相应的MS-DOS驱动程序要好得多。比如“8390”系列驱动程序使用乒乓传送缓存，该方法刚刚被引进MS-DOS。
<P>（乒乓传送缓存意味著为传送数据包使用至少两个最大大小的包缓存。在网卡发送其中的一个时，载入另一个。在第一个包被发出去后，立刻发送第二个包，依次类推。这样，大多数网卡就可以连续向线路上发送背靠背数据包。）
<P>好啦。你可以决定为Foobar Ethernet网卡编写驱动程序了，因为你有编程资料，而且还没人写这个驱动程序。（......这是两个主要的需求 ;-) 你可以从Linux内核源码树中提供的网络驱动程序框架开始。在所有近期的内核里都能找到这个文件/usr/src/linux/drivers/net/skeleton.c。在2.4.x（或更新的）内核里已经把它重新命名为<CODE>isa-skeleton.c</CODE>。也可以看看如下URL的Kernel Hackers Guide：
<A HREF="http://www.redhat.com:8080/HyperNews/get/khg.html">KHG</A><P>
<P>
<H2><A NAME="ss7.5">7.5 内核的驱动程序接口</A>
</H2>

<P>
<P>下面对编写一个新驱动程序所必需的函数进行了若干说明。和上面提到的驱动程序框架一起阅读可以更清楚一些。
<P>
<P>
<H3>Probe</H3>

<P>
<P>在启动时调用以检查网卡存在与否。如果可以通过读取内存等非强制手段进行检查最好。也可以从I/O端口读取。在探测开始向I/O端口写<EM>不好</EM>，因为这样可能会损害另一个设备。通常在这里还进行一些设备初始化（分配I/O空间、IRQ、填充dev-&gt;???域等等）。必须了解网卡可以配置到哪些I/O端口/内存、如何启用共享内存（如果用了的话）以及如何选择/启用中断产生，等等。
<P>
<H3>Interrupt handler</H3>

<P>
<P>在网卡发出一个中断时内核调用的程序。它需要确定网卡发出中断的原因并进行相应的操作。一般的中断条件是接收到数据、发送完成、报告出错状况。需要了解相关的中断状态位以进行相应的操作。
<P>
<H3>Transmit function</H3>

<P>
<P>与dev-&gt;hard_start_xmit()链接，在内核想通过设备传送数据时调用它。该函数把数据放入网卡并触发传送。需要了解如何把数据打包并传给网卡（共享内存拷贝、PIO传送、DMA？），以及放入网卡正确的位置。然后需要了解如何通知网卡把数据发送到线路上，（可能）在发送完成后发出一个中断。在硬件无法接收更多数据包时需要设置dev-&gt;tbusy标志。在网卡有空间可用时，一般这发生在传送完成中断过程中，清除dev-&gt;tbusy标志并用<CODE>mark_bh(INET_BH)</CODE>通知上一层。
<P>
<H3>Receive function</H3>

<P>
<P>在网卡报告有数据时由内核中断处理程序调用。它把数据从网卡上移出，放入一个sk_buff并通过执行netif_rx(sk_buff)告诉内核数据所在位置。需要了解如何在接收数据时启用中断生成，如何检查相关的接收状态位，以及如何从网卡获取数据（通过共享内存拷贝、PIO、DMA，等等）。
<P>
<H3>Open function</H3>

<P>
<P>与dev-&gt;open链接，在有人使用<CODE>ifconfig eth0 up</CODE>时网络层调用它――把设备连到线路上并启用来接收/发送数据。任何在探测过程中（启用IRQ生成函数等）没有完成的特别的初始化操作都在这里进行。
<P>
<H3>Close function （可选）</H3>

<P>
<P>在有人使用<CODE>ifconfig eth0 down</CODE>时使网卡进入一个清醒的状态。如果硬件许可的话它会释放中断和DMA通道，并完全关闭以节约能源（象收发器一样）。
<P>
<H3>Miscellaneous functions</H3>

<P>
<P>如同一个重新设置函数，如果事情变得很糟，驱动程序可以试图重新设置网卡作为最后防线。一般在发送超时或类似情况下如此进行。也是一个读取网卡统计寄存器的函数，如果是这样配备的话。
<P>
<H2><A NAME="3com-tech"></A> <A NAME="ss7.6">7.6 3Com的技术信息</A>
</H2>

<P>
<P>如果对3Com网卡驱动程序的工作感兴趣，可以从3Com公司获取技术资料。Cameron在下面友好地告诉了我们该如何去做：
<P>在我们的“技术参考文献”（TRs）里给出了3Com的以太网适配器驱动程序程序员需要了解的资料。这些手册描述了板上的程序员接口，但没有提及诊断、安装程序等终端用户所看到的东西。
<P>网络适配器分部的市场部有技术参考资料分发。为了使这个计划更有效，我们把它集中到一个称作“CardFacts”的自动电话系统里。你可以打电话来，然后它把资料传真给你。要索取技术参考资料，打电话到408-727-7021。索取开发人员的订单，资料号是9070。在打电话前准备好你的传真号码。填完订单后把它传真到408-764-5004。手册会由联邦速递的次日服务送到。
<P>有人认为我们的手册不该免费，他们也在寻找此系统过于昂贵或占用的时间和努力太多的证据。到目前为止，3Com的顾客确实不错，向我们提出的要求也很合理。我们需要你们的继续合作并把这样的服务维持下去。
<P>
<H2><A NAME="amd-notes"></A> <A NAME="ss7.7">7.7 基于AMD PCnet/LANCE的网卡的注意事项</A>
</H2>

<P>
<P>AMD的LANCE（以太网的局域网控制器）是最早提供的，已经被“PCnet-ISA”芯片所取代，否则又名79C960。注意，“LANCE”名称有毛病，有些人会用老名称称呼新芯片。AMD的网络产品分部的Dave Roberts友好地提供了下面有关该芯片的信息：
<P>“从功能上来看，它等同与NE1500。它的寄存器组与使用附加1500/2100结构的老式LANCE一样。PCnet-ISA可以使用较早的1500/2100驱动程序。NE1500和NE2100的结构基本上是相同的。开始Novell把它称为2100，但后来想区分同轴电缆与10BASE-T网卡。属于10BASE-T的就只采用1500范围的编号。这是仅有的区别。
<P>许多公司提供基于PCnet-ISA的产品，包括HP、Racal-Datacom、Allied Telesis、Boca Research、Kingston Technology等等。除了有些制造商增加了“无跳线”特性允许软件配置网卡外，这些网卡基本上都是一样的。大多数制造商没有增加这一特性。AMD提供了一个使用PCnet-ISA的网卡的标准设计软件包，许多制造商不加改变地直接使用我们的设计。这也就是说，如果想编写大多数基于PCnet-ISA的网卡的驱动程序，只需要从AMD获取数据资料。打电话给我们的资料分发中心(800)222-9323，索取PCnet-ISA的数据资料Am79C960。这是免费的。
<P>要迅速了解一块网卡是否“标准”网卡只需要看一下。如果是标准的，网卡上只有一块大的芯片、一块晶振、一块小的IEEE地址PROM、可能还有一个启动ROM的插座和一个连接器（依照提供的媒介选项可能是1、2或3）。注意，如果是同轴电缆网卡，卡上就应该有一些收发器缓存，它们靠近连接器，远离PCnet-ISA。”
<P>一个可能的网卡黑客需要注意，不同的LANCE产品采用不同的“重起”方法。有些恢复到上次离开网络环路的地方，另一些则从环路的开头开始，就象刚被初始化一样。
<P>
<H2><A NAME="promisc"></A> <A NAME="ss7.8">7.8 广播与混杂模式</A>
</H2>

<P>
<P>Donald所做的另一个工作是实现广播与混杂模式的钩子函数。所有<EM>发布的</EM>（即<B>不是</B>ALPHA版本的）ISA驱动程序现在都支持混杂模式。
<P>Donald写道：“我准备从讨论混杂模式开始，它从概念上来说很容易实现。对大多数硬件，你只需要设置一个寄存器位，然后就可以接收到线路上的每一个数据包。对，差不多就这么简单；对有些硬件，你必须先关闭板卡（可能会丢失若干数据包），重新配置它，然后重新启用以太网卡。对吧，就这么简单，下面要讨论的就不是这么明显了：广播模式。它可以用两种方式实现：
<P>
<OL>
<LI>    使用混杂模式和一个如Berkeley包过滤器（BPF）的数据包过滤器。BPF是一个模式匹配指令语言，可以编写一个程序挑出感兴趣的地址。它的优点在于它很普遍和可编程。其缺点是没有一个一般性的方法可以让内核避免打开混杂模式和通过每一个注册的包过滤器运行每一个线路上的数据包。参见
<A HREF="#bpf">Berkeley包过滤器</A>以了解更多信息。
        </LI>
<LI>    使用绝大多数以太网芯片内建的广播包过滤器。
</LI>
</OL>
<P>我想应该列出几个以太网卡/芯片提供的广播包过滤器：
<P>
<PRE>
        
        芯片/网卡           混杂模式    广播包过滤器
        -------------   ------------    ---------------
        Seeq8001/3c501  Yes                     Binary filter (1)
        3Com/3c509                Yes                   Binary filter (1)
        8390                      Yes                   Autodin II six bit hash (2) (3)
        LANCE                     Yes                   Autodin II six bit hash (2) (3)
        i82586                    Yes                   Hidden Autodin II six bit hash (2) (4)
        
</PRE>
<P>
<OL>
<LI>    这些网卡声称有一个过滤器，但只是简单地对“accept all multicast packets”或“accept no multicast packets”回答yes/no。
</LI>
<LI>    AUTODIN II是标准的以太网CRC校验多项式。在这种方式下，广播地址被哈希运算后在哈希表里进行查找。如果启用了相应的比特位，则数据包被接收。以太网数据包的设计使得硬件在如此处理时的开销很小――（通常）只要在前6个八进制数（目标地址）之后锁定CRC电路（用来进行错误检查）的6个比特位，把它们作为哈希表的索引（6比特――一个64比特的表）。
        </LI>
<LI>    这些芯片使用6比特哈希，必须由主机计算并载入哈希表。这也就是说内核必须包含CRC代码。
        </LI>
<LI>    82586内部使用6比特哈希，但是由自己从接受的广播地址列表计算出哈希表。
</LI>
</OL>
<P>注意，这些芯片的过滤效果都不好，还需要一个中间层次的模块完成最后的过滤。同时还要注意，在每种情况下都必须保持一个完整的接受广播地址列表，在出现变化时以重新计算哈希表。
<P>
<H2><A NAME="bpf"></A> <A NAME="ss7.9">7.9 Berkeley包过滤器（BPF）</A>
</H2>

<P>
<P>开发者普遍认为BPF的功能不该由内核提供，而是放在一个（希望很少用到的）兼容库里。
<P>对不了解的人来说：BPF（Berkeley包过滤器）是一种向内核网络层说明对哪些数据包感兴趣的机制。它是用一种建立在底层网络代码中的特殊指令语言解释器实现的。应用程序把一个用这种语言编写的程序传递给内核，然后内核对每一个接收到的数据包执行该程序。如果内核有多个BPF应用程序，对每个数据包都要运行这个程序。
<P>问题在于很难从数据包过滤器程序推断出应用程序实际上对哪一种数据包感兴趣，所以一般的解决方法就是始终运行过滤器。假设一个应用程序注册的BPF程序是获取发往某个广播地址的低速数据流。绝大多数以太网卡有一个64个入口的哈希表的硬件实现的广播地址过滤器，用来忽略大多数不想要的广播数据包，所以有可能以极低的开销完成这一操作。但是由于有了BPF，内核必须把接口设置为混杂模式，接收所有数据包，并对它们运行过滤器。不管怎样，这样确实可以工作，但考虑到对所要求的数据包进行的处理，就已经变得过于麻烦了。
<P>
<HR>
<A HREF="Ethernet-HOWTO-8.html"><IMG SRC="img/next.gif" ALT="Next"></A>
<A HREF="Ethernet-HOWTO-6.html"><IMG SRC="img/prev.gif" ALT="Previous"></A>
<A HREF="Ethernet-HOWTO.html#toc7"><IMG SRC="img/toc.gif" ALT="Contents"></A>
<SCRIPT>EndPage();</SCRIPT>  </BODY>
</HTML>
