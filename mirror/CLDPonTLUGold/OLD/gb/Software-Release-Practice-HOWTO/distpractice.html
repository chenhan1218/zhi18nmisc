<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML
><HEAD
><TITLE
>制作项目发布包的好经验</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.59"><LINK
REL="HOME"
HREF="t1.html"><LINK
REL="PREVIOUS"
TITLE="好的开发习惯"
HREF="develpractice.html"><LINK
REL="NEXT"
TITLE="好的文档编写惯例"
HREF="documentation.html"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="develpractice.html"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="documentation.html"
>Next &#62;&#62;&#62;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="DISTPRACTICE"
>制作项目发布包的好经验</A
></H1
><P
>这一章节主要介绍您发布的项目应该具有什么样的形式，以方便其他人下载、
检索和解压。</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="TARBALLS"
>确保tar包解压时会创建一个独立的新目录</A
></H2
><P
>新手常犯的低级错误是制作了一个解压后把文件和目录直接解压在当前工作目
录的tar包，这样做潜在的危险是会把原来已有的同名文件覆盖掉。记住，
<I
CLASS="EMPHASIS"
>千万不要这么干！</I
></P
><P
>而正确的方法是：您的项目的所有档案都是存放在项目所在目录下的标准目录结
构中，这样tar包就可以解压在一个特定的目录下<I
CLASS="EMPHASIS"
>而不是</I
>当前目录。</P
><P
>这里有一个Makefile文件的技巧示例展示了如何完成打包工作，这里假定您的
项目所在目录名称为“foobar”，而SRC变量中是一个包含所有需要发布的文件
列表：</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>foobar-$(VERS).tar.gz:
	@ls $(SRC) | sed s:^:foobar-$(VERS)/: &#62;MANIFEST
	@(cd ..; ln -s foobar foobar-$(VERS))
	(cd ..; tar -czvf foobar/foobar-$(VERS).tar.gz `cat foobar/MANIFEST`)
	@(cd ..; rm foobar-$(VERS))</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="README"
>编写README文件</A
></H2
><P
>应该有一个名为<TT
CLASS="FILENAME"
>README</TT
>或者<TT
CLASS="FILENAME"
>READ.ME</TT
>的
文件来说明整个源码的结构信息。古老的传统告诉我们，勇猛的探索者在解开您的压
缩文件包后的第一件事情就是找出README文件来阅读。</P
><P
>README文件中最好应该包括如下信息：</P
><P
></P
><OL
TYPE="1"
><LI
><P
>整个项目的简介</P
></LI
><LI
><P
>项目的WWW站点所在的URL（如果有的话）</P
></LI
><LI
><P
>指出开发者编译整个项目所在的系统环境，并指出项目可能潜在的移植性问题</P
></LI
><LI
><P
>重要文件和子目录的结构信息</P
></LI
><LI
><P
>编译/安装步骤说明，或者指明这些信息所在的文件名
（通常是<TT
CLASS="FILENAME"
>INSTALL</TT
>文件）</P
></LI
><LI
><P
>项目主持人和参与者的名单列表，或者指出这些信息所在的文件（通常是<TT
CLASS="FILENAME"
>CREDITS</TT
>文件）</P
></LI
><LI
><P
>最近关于本项目的一些进展情况和新闻，或者指出包含此信息的文件
（通常是<TT
CLASS="FILENAME"
>NEWS</TT
>文件）</P
></LI
></OL
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FILENAMES"
>遵照标准文件命名规则</A
></H2
><P
>“勇猛的探索者”要想阅读README文件，他们就必须首先浏览解压后项目档案所
在的根目录下的文件名。这些文件名本身就在向读者传达著许多信息。如果您遵照
标准的命名规则就可以给那些探索者有价值得线索以便他们更好的理解您的意图。</P
><P
>这里列出了一些标准文件名称和他们的涵义。当然并不是所有项目发布时都必须
包含所有这些文件。</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>README或READ.ME</DT
><DD
><P
>整个项目的结构信息说明，第一个需要阅读的文件。</P
></DD
><DT
>INSTALL</DT
><DD
><P
>配置、编译和安装该项目的说明信息</P
></DD
><DT
>CREDITS</DT
><DD
><P
>本项目所有贡献者的列表</P
></DD
><DT
>NEWS</DT
><DD
><P
>本项目最近的一些新闻和进展状况</P
></DD
><DT
>HISTORY</DT
><DD
><P
>本项目的历史发展演变记录</P
></DD
><DT
>COPYING</DT
><DD
><P
>指出本项目采用的许可证条款（通常采用GNU GPL）</P
></DD
><DT
>LICENSE</DT
><DD
><P
>本项目的许可证条款文件</P
></DD
><DT
>MANIFEST</DT
><DD
><P
>本项目的所有文件列表</P
></DD
><DT
>FAQ</DT
><DD
><P
>关于本项目的纯文本格式的常见问题解答</P
></DD
><DT
>TAGS</DT
><DD
><P
>为Emacs或vi准备的tag标记文件</P
></DD
></DL
></DIV
><P
>我们可以看出来，全部大写的文件名一般表示该文件是给人阅读的文档，而不
是项目的一个组成部分。</P
><P
>编撰一个FAQ文件可以帮您很多忙。如果某个问题经常被其他人问起，就把这个
问题列入FAQ文件；然后指导用户在向您发文或提交出错报告前首先阅读FAQ文
件。一份好的FAQ文件可以给项目维护者减轻好几个数量级的负担。</P
><P
>另外在每次发布时都保留一个HISTORY文件和NEWS文件，并列明时间信息的做法是非常有
好处的。在所有其他文件中，这两个文件可以让您在遇到一些专利侵权法律问题
时有所准备（虽然这种情况至今还没有发生过，不过最好还是有备无患）。</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="UPGRADEABILITY"
>为项目升级做好准备</A
></H2
><P
>只要您打算为您的项目发布新版本，项目就必定处在不断的变化之中。有些
变化是不能向前兼容的。因此您必须认真思考安装程序设计上的问题，就是
说让同一项目的不同版本的代码安装后可以共存在一个系统中。这个问题对
库项目的发布尤为重要，因为您不能指望所有基于这个库的应用程序都会紧
跟您的API接口规范的后尘。</P
><P
>Emacs、Python和Qt项目有一套对付这个问题的好办法，就是让目录名中包含
版本号。这里有Qt库安装后的目录结构的例子（${ver}是代表版本号的变量）：</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>/usr/lib/qt
/usr/lib/qt-${ver}
/usr/lib/qt-${ver}/bin          # moc程序所在目录
/usr/lib/qt-${ver}/lib          # .so共享库所在目录
/usr/lib/qt-${ver}/include      # 头文件所在目录</PRE
></TD
></TR
></TABLE
><P
>这样组织目录结构可以让多个不同版本的档案共存。客户程序可以根据需
要选用具有特定版本号的库，因此为了不让这些接口影响客户程序，还是需
要付出一些小小代价（制定版本号）的。</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RPMS"
>提供RPM包</A
></H2
><P
>安装可执行文件包（二进制包）的事实标准就是使用RedHat包管理器将可
执行文件打包成 rpm 包。许多流行的GNU/Linux发行版都是这么做的，同时也
有许多发行版虽然主要不是rpm包格式但是也支持rpm包（除了Debian和
Slackware以外，而且Debian还支持rpm的安装）。
<P
>&#13;<P
>因此一个好的项目除了有tar包的源代码以外，最好也提供直接可安装的rpm
包的下载。</P
>

<P
>如果您能把您的源代码tar包和Makefile文件中用于生成rpm包的相关信息写
入rpm的spec文件中就再好不过了。spec文件是有著".spec"后缀的文件，这
就是带 -t 选项的 rpm 命令如何在 tar 包中寻找它的方法。</P
>

<P
>还有一个要点是，您可以用一个脚本程序自动的从Makefile或version.h
文件中找出版本号，并用这个版本号来生成您的spec文件。</P
>

<P
>注：如果您还打算提供源码的rpm包，最好用BuildRoot工具来将程序编译
到/tmp或者/var/tmp目录中。如果不这么做，在安装过程中执行
make install命令时就会直接将那些源程序直接安装到最终的目录位置下。
这样就会导致即使在发生文件覆盖冲突，或者您本意并不想装那个包的
时候，安装动作依然被执行。因此安装完成后，文件是被装到了系统中，
但是系统的RPM数据库却并没有记录这些信息。这种愚蠢的SRPM安装动作
是非常危险的，理应避免。</P
>&#13;</P
></P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="develpractice.html"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="t1.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="documentation.html"
>Next &#62;&#62;&#62;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>好的开发习惯</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>好的文档编写惯例</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>