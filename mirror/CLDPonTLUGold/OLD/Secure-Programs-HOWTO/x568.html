<HTML
><HEAD
><TITLE
>C/C++的編譯解決方案</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.54"><LINK
REL="HOME"
TITLE="Linux和Unix安全編程HOWTO"
HREF="book1.html"><LINK
REL="UP"
TITLE="避免緩存溢出"
HREF="c502.html"><LINK
REL="PREVIOUS"
TITLE="C/C++中庫的解決方案"
HREF="x515.html"><LINK
REL="NEXT"
TITLE="其它語言"
HREF="x576.html"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Linux和Unix安全編程HOWTO</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x515.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 5. 避免緩存溢出</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x576.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN568"
>C/C++的編譯解決方案</A
></H1
><P
>有個完全不同的方案是使用執行邊界檢查的編譯方法（參見[Sitaker 1999]中所列的方法）。在我看來，這樣的工具在進行多層次防范時很有用，但把該技朮作為唯一的防范手段就不是很明智。至少有兩個理由這樣講。首先，大多數這樣的工具都只對緩存溢出提供部分保護（“完全的”防范一般會慢12-30倍）﹔C和C++根本就不是為防止緩存溢出而設計的。其次，對于開放源代碼程序，人們無法確定將使用什么工具來編譯程序﹔對于某個給定系統使用缺省的“常用”編譯器可能會突然打開安全漏洞。</P
><P
>一個更有用的工具是“StackGuard”，標准GNU的C編譯器gcc的一個修改版。StackGuard通過在返回地址前插入一個“守衛”值（稱作“canary”）起作用﹔如果緩存溢出改寫了返回地址，canary的值（很可能）改變了，系統在使用地址前會察覺出來。這很有價值，但要注意這并沒有防止緩存溢出改變其它的值（而這還是可以被用來對系統進行攻擊）。有個叫“PointGuard”的工具把StackGuard擴展為可以在其它數據項前增加canary，PointGuard會自動保護特定的值（如函數指針和遠程跳轉緩存）。但是，使用PointGuard來保護其它變量類型要求程序員明確地介入（程序員必須指定哪一個數據值需要用canary保護）。這可能有價值，但容易意外地忘記保護一個被認為不需要保護的數據值 -- 但它實際上是需要進行保護的。更多有關StackGuard、PointGuard和其它替代方案可參見Cowan [1999]。</P
><P
>與之相關，可以修改Linux內核，使堆棧段不可執行﹔這樣的Linux補丁已經有了（參見包含此部分的Solar Designer的補丁
<A
HREF="http://www.openwall.com/linux/"
TARGET="_top"
>http://www.openwall.com/linux/</A
>）。
但是，這種做法不是建立在Linux內核里的。一部分理由是因為這種保護并不像看起來那樣完善﹔攻擊者可以簡單地迫使系統調用其它已經在程序中的某些“有趣”的位置（如庫、堆或靜態數據段）。同樣，有時Linux確實需要堆棧中的可執行代碼，比如用來實現信號和用來實現GCC的“trampolines”。Solar Designer的補丁確實可以處理這些問題，但這使補丁變得復雜。就個人而言，我希望它被結合進主要的Linux發行版中，因為它確實使攻擊變得更困難，而且可抵御一部分現有的攻擊。盡管如此，我同意Linus Torvalds和其他人的觀點，即它并沒有增加如顯示的那樣多的保護，而且可以被相對容易地繞過。可以看一下Linus Torvalds對不包括該支持的解釋
<A
HREF="http://lwn.net/980806/a/linus-noexec.html"
TARGET="_top"
>http://lwn.net/980806/a/linus-noexec.html</A
>。</P
><P
>簡而言之，最好是先開發自己能抵御緩存溢出的正確程序。然后，再使用諸如StackGuard等技朮和工具來作為額外的安全網絡。如果在代碼本身下了工夫以消除緩存溢出，那么StackGuard就會更為有效，因為需要調用StackGuard進行保護的“盔甲上的縫隙”會少很多。</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x515.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x576.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>C/C++中庫的解決方案</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c502.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>其它語言</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>