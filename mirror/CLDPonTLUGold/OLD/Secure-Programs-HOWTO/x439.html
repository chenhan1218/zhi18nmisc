<HTML
><HEAD
><TITLE
>字符編碼</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.54"><LINK
REL="HOME"
TITLE="Linux和Unix安全編程HOWTO"
HREF="book1.html"><LINK
REL="UP"
TITLE="証實所有的輸入"
HREF="c384.html"><LINK
REL="PREVIOUS"
TITLE="其它輸入"
HREF="x436.html"><LINK
REL="NEXT"
TITLE="限制合法的輸入時間和負載水平"
HREF="x499.html"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Linux和Unix安全編程HOWTO</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x436.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 4. 証實所有的輸入</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x499.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN439"
>字符編碼</A
></H1
><P
>多年來美國人一直使用ASCII對字符編碼，可以方便地交換英語文本。但不幸的是，ASCII完全不足以處理大多數其它語言的字符集。多年來不同的國家采用不同的技朮交換不同語言的文本。最近，ISO推出了ISO 10646，用于表示世界上所有字符的單一31比特編碼方案，被稱為通用字符集（UCS）。可用16比特（UCS的前65536個字符）表示的字符被稱為“基本多語言平台”（BMP），而且BMP意圖覆蓋所有口頭語言。Unicode論壇推出了Unicode標准，注重于16比特字符集，并為了有助于互操作性增加了一些附加的約定。</P
><P
>盡管如此，大多數軟件不是為處理16比特或32比特字符設計的，所以開發出一種叫做“UTF-8”的特殊格式來編碼這些潛在的國際字符，現有的程序和庫更容易處理這種格式。在IETF RFC 2279和其它一些地方有UTF-8的定義，所以它是一種可以自由閱讀和使用的定義完好的標准。UTF-8是可變長度編碼﹔從0到0x7f （127）的字符作為單個字節被編碼為自身，更大值的字符則被編碼為2到6個字節信息（依賴于具體值）。編碼被特別設計以具有以下良好特性（取自RFC和Linux中utf-8的man幫助頁）：

<P
></P
><UL
><LI
><P
>標准的US ASCII字符（0--0x7f）編碼為自身，這樣只包含7比特ASCII字符的文件和字符串在ASCII和UTF-8編碼下是相同的。這對于許多已有美國程序和數據文件的反向兼容性而言是太好了。</P
></LI
><LI
><P
>所有大于0x7f的UCS字符被編碼為僅由0x80到0xfd范圍內的字節組成的多字節序列。這就意味著ASCII字節不會變成另一個字符的一部分。許多其它的編碼方法允許嵌入NIL的字符，會導致程序失效。</P
></LI
><LI
><P
>在UTF-8和2字節或4字節固定長度的字符表示（分別被稱為UCS-2和UCS-4）之間進行轉換很容易。</P
></LI
><LI
><P
>UCS-4字符串保持了按字典分類的順序，可以直接對UTF-8數據應用Boyer-Moore快速查找算法。</P
></LI
><LI
><P
>所有可能的2^31個UCS代碼都可以用UTF-8進行編碼。</P
></LI
><LI
><P
>表示單個非ASCII的UCS字符的多字節序列的第一個字節總是在0xc0到0xfd范圍內，表示該多字節序列有多長。多字節序列的所有其它字節都在0x80到0xbf范圍內。這就可以很容易地實行重新同步﹔如果丟失了某個字節，可以很容易地跳到“下一個”字符，而且總是可以很容易地跳到“前一個”或“后一個”字符。</P
></LI
></UL
></P
><P
>簡而言之，UTF-8轉換格式正在成為交換國際文本信息的主要方法，因為它可以支持世界上的所有語言，而且還與美國的ASCII文件反向兼容，并具有其它一些良好特性。出于諸多理由，我推荐使用這種編碼，特別是在把數據保存到“文本”文件時。</P
><P
>提及UTF-8的原因在于某些字節序列不是合法的UTF-8，而且可能成為可利用的安全漏洞。RFC提到了以下內容：

<BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>UTF-8的實現者需要考慮如何處理非法的UTF-8序列的安全方面的問題。可以想象，在某些情況下黑客可以通過發送一個UTF-8語法不允許的八進制序列，來利用一個不謹慎的UTF-8解釋器。</P
><P
>對于執行對UTF-8編碼形式的輸入進行關乎安全的合法性檢查的解釋器，可以采用一個方式特別微妙的攻擊，使得特定的非法八進制序列被解釋為字符。例如，某個解釋器可能禁止編碼為單個八進制序列00的NUL字符，但允許非法的兩個八進制序列C0 80，把它解釋為一個NUL字符。另一個例子就是可能會有個解釋器禁止八進制序列2F 2E 2E 2F（“/../”），但允許非法的八進制序列2F C0 AE 2E 2F。</P
></BLOCKQUOTE
>&#13;</P
><P
>有關此問題的較為充分的討論可以在
<A
HREF="http://www.cl.cam.ac.uk/~mgk25/unicode.html"
TARGET="_top"
>http://www.cl.cam.ac.uk/~mgk25/unicode.html</A
>
上的Markus Kuhn的
<I
CLASS="EMPHASIS"
>UTF-8 and Unicode FAQ for Unix/Linux</I
>
里看到。</P
><P
>UTF-8字符集是可以列出所有非法值（并証明已經全部列出）的一種情況。如果要確定是否得到一個合法的UTF-8序列，需要檢查兩件事：(1)初始序列是否合法，(2)如果合法，是否第一個字節后面跟隨了所要求的合法后續字符數目？進行第一項檢查很簡單，可以証明下面是所有非法UTF-8初始序列的完全列表：

<DIV
CLASS="TABLE"
><P
><B
>Table 4-1. 非法UTF-8初始序列</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
WIDTH="50%"
ALIGN="LEFT"
VALIGN="TOP"
>UTF-8序列</TH
><TH
WIDTH="50%"
ALIGN="LEFT"
VALIGN="TOP"
>非法的原因</TH
></TR
></THEAD
><TBODY
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="TOP"
>10xxxxxx</TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="TOP"
>作為字符的起始字節非法(80..BF)</TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="TOP"
>1100000x           </TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="TOP"
>非法，過長(C0 80..BF)</TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="TOP"
>11100000 100xxxxx  </TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="TOP"
>非法，過長(E0 80..9F)</TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="TOP"
>11110000 1000xxxx  </TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="TOP"
>非法，過長(F0 80..8F)</TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="TOP"
>11111000 10000xxx  </TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="TOP"
>非法，過長(F8 80..87)</TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="TOP"
>11111100 100000xx  </TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="TOP"
>非法，過長(FC 80..83)</TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="TOP"
>1111111x           </TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="TOP"
>非法﹔為規格說明所禁止</TD
></TR
></TBODY
></TABLE
></DIV
>&#13;</P
><P
>需要說明的是在某些情況下，可能會要松散地打斷（或內部使用）十六進制序列C0 80。這是個可以代表ASCII NUL（NIL）的過長序列。由于C/C++在把NIL字符包含在普通字符串里會出問題，有些人在想要把NIL作為數據流的一部分時就使用該序列﹔Java甚至把這種方法奉為經典。在處理數據時可以自由地在內部使用C0 80，但從技朮角度來說，在保存數據時應該把它轉換回00。根據實際需要，可以自行決定是否“馬虎”一下，把C0 80作為UTF-8數據流的輸入。</P
><P
>第二個步驟是檢查正確的后續字符數目是否包含在字符串中。如果第一個字節的頭兩個比特被置位了，那么數一下頭一個比特位后被置位比特的個數，然后再檢查是否有那么多以比特“10”開頭的后續字節。因此，二進制數11100001就要求兩個以上的后續字節。</P
><P
>與此有關的一個問題是在ISO 10646/Unicode中某些語句可以用多種方式表示。例如，有些帶著重號的字符可以用單個字符（帶著重號）表示，也可以用一組字符（如基本字符加上單獨排版的著重號）來表示。這兩種形式可能看起來完全一樣。也可以在其中插入一個零寬度的空格，使看起來相似的二者有所區別。有些情況下要小心這樣的隱藏文本會干擾程序。</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x436.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x499.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>其它輸入</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c384.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>限制合法的輸入時間和負載水平</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>