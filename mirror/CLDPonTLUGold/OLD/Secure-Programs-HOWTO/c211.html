<HTML
><HEAD
><TITLE
>Linux和Unix安全特性概要</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.54"><LINK
REL="HOME"
TITLE="Linux和Unix安全編程HOWTO"
HREF="book1.html"><LINK
REL="PREVIOUS"
TITLE="文檔習語"
HREF="x206.html"><LINK
REL="NEXT"
TITLE="文件"
HREF="x270.html"></HEAD
><BODY
CLASS="CHAPTER"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Linux和Unix安全編程HOWTO</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x206.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x270.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
><A
NAME="AEN211"
>Chapter 3. Linux和Unix安全特性概要</A
></H1
><TABLE
BORDER="0"
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
CLASS="EPIGRAPH"
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="LEFT"
VALIGN="TOP"
><I
><P
><I
>Discretion will protect you, and understanding will guard you.</I
></P
></I
></TD
></TR
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="RIGHT"
VALIGN="TOP"
><I
><SPAN
CLASS="ATTRIBUTION"
>Proverbs 2:11 (NIV)</SPAN
></I
></TD
></TR
></TABLE
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="c211.html#AEN221"
>進程</A
></DT
><DT
><A
HREF="x270.html"
>文件</A
></DT
><DT
><A
HREF="x316.html"
>System V的IPC</A
></DT
><DT
><A
HREF="x337.html"
>套接字和網絡連接</A
></DT
><DT
><A
HREF="x346.html"
>信號</A
></DT
><DT
><A
HREF="x354.html"
>配額與限制</A
></DT
><DT
><A
HREF="x359.html"
>動態連接庫</A
></DT
><DT
><A
HREF="x378.html"
>審核</A
></DT
><DT
><A
HREF="x381.html"
>PAM</A
></DT
></DL
></DIV
><P
>在討論如何應用Linux或Unix安全特性指南前，先從一個程序員的角度了解一下這些特性是很有用的。本節對這些在几乎所有類Unix系統上廣泛應用的特性進行簡要的描述。盡管如此，還是需要注意類Unix系統不同版本間相當大的差異，以及不是所有系統都具有這里所描述的能力。本節也著重提到了Linux特有的一些擴展或特性﹔從安全編程的角度來看，不同Linux發行版非常相似，因為它們本質上都使用相同的內核與C庫（以及鼓勵任何創新迅速傳播的基于GPL的許可）。本文不討論很多類Unix系統都不實現的強制存取控制（MAC）的實現之類的問題。如果你已經知道了這些特性，可以跳過本節繼續閱讀。</P
><P
>很多編程指南簡單地略過了Linux或Unix有關安全的部分，而且忽略了重要的信息。特別是它們經常討論通常情況下“如何應用”某物，而不考慮影響這些應用的安全屬性。與此相反，在單個函數的手冊頁中有大量的詳細信息，但是有時手冊頁對于如何使用每個單獨函數的詳細討論模糊了關鍵的安全性問題。本節試圖彌補此缺憾﹔只為程序員提供Linux下可能會用到的安全機制的全局概貌，但特別注重有關安全問題的分支。本節比經典的編程指南更為深入，特別是集中在有關安全的問題上，并指出從哪里可以獲得進一步的資料。</P
><P
>首先，是基本情況。
Linux和Unix從根本上來說可以分為兩部分：內核與“用戶空間”。絕大多數程序運行在用戶空間（在內核之上）。Linux支持“內核模塊”的概念，簡單地說就是在內核里動態載入代碼的能力，但還是有這樣的基本划分。有些其它的系統（如HURD）是基于“微內核”的系統﹔它們有一個功能很有限的小內核和一組“用戶”程序來實現傳統上由內核實現的底層函數。</P
><P
>有些類Unix系統進行了大量修改以支持增強的安全性，特別是支持美國國防部對強制存取控制（B1級別以上）。本文的目前版本不涉及這些系統或這些問題﹔我希望在未來的版本中可以加入這些內容。</P
><P
>當用戶登錄時，他們的用戶名被映射為整數，來標明自己的“UID”（用戶ID）和作為其中成員的“GID”（組ID）。UID 0是傳統上被稱為“root”的具有特權的用戶（角色），在絕大多數類Unix系統（包括Unix）中root可以強制變更大多數的安全性檢查，被用來管理系統。就安全性而言，進程是唯一的“主題”（也就是說，只有進程是活動的目標）。進程可以訪問各種數據對象，特別是文件系統對象（FSO）、系統V進程間通信（IPC）對象和網絡端口。進程還可以設置信號。其它有關安全的主題包括配額與限制、庫、審核和PAM。以下几節對此進行詳細說明。</P
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN221"
>進程</A
></H1
><P
>在類Unix系統上，用戶級別的活動由運行的進程來實現。絕大多數Unix系統支持作為獨立概念的“線程”﹔一個進程內的線程共享內存，而且系統的調度器實際上是調度線程。Linux的做法與此不同（依我看是做得更好）：線程與進程沒有本質的差異。在Linux下，在某個進程創建另一個進程時，它可以選擇共享哪些資源（比如內存可以共享）。隨后Linux內核會進行優化以獲得線程級的速度﹔參見clone(2)以了解更多信息。值得注意的是Linux內核的開發者傾向于使用“任務”一詞，而不是“線程”或“進程”，但外界的文檔則傾向于使用進程一詞（所以我在文中如此使用）。在多線程應用程序編程時，使用某個標准的線程庫來隱藏這些差異通常要好一些。這不僅使線程更易于移植，而且有些庫通過把多個應用程序級的線程實現為單個操作系統線程的方法提供一個間接的附加級別﹔這可以改進某些系統上一些應用程序的性能。</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN224"
>進程屬性</A
></H2
><P
>在類Unix系統中，每個進程所有的典型屬性如下：

<P
></P
><UL
><LI
><P
>RUID, RGID -- 運行進程的用戶的真實用戶ID和組ID</P
></LI
><LI
><P
>EUID, EGID -- 用于權限檢查（文件系統除外）的有效用戶ID和組ID</P
></LI
><LI
><P
>SUID, SGID -- 保存的用戶ID和組ID﹔用來支持下面要討論的切換許可“開和關”。不是所有的類Unix系統都支持它。</P
></LI
><LI
><P
>補充群組 -- 用戶有成員資格的群組（GID）列表。</P
></LI
><LI
><P
>umask -- 在創建一個新的文件系統對象時決定缺省訪問控制設置的一組比特位﹔參見umask(2)。</P
></LI
><LI
><P
>scheduling parameters -- 每個進程都有一個調度策略，缺省策略為SCHED_OTHER的進程還具有nice、priority和counter的附加屬性。參見sched_setscheduler(2)以了解更多信息。</P
></LI
><LI
><P
>limits -- 每個進程的資源限制（參見下文）。</P
></LI
><LI
><P
>filesystem root -- 進程角度的根文件系統起始處﹔參見see chroot(2)。</P
></LI
></UL
>&#13;</P
><P
>下面是與進程有關的不太普通的屬性：

<P
></P
><UL
><LI
><P
>FSUID, FSGID -- 用于文件系統訪問檢查的用戶ID和組ID﹔一般等于相應的EUID和EGID﹔這是一個Linux特有的屬性。</P
></LI
><LI
><P
>capabilities -- POSIX能力信息﹔一個進程實際上有三組能力：有效的、可繼承的和許可的能力。參見下文中有關POSIX能力的更多信息。版本2.2以上的Linux內核支持這一點﹔有些其它的類Unix系統也支持，但不夠普遍。</P
></LI
></UL
>&#13;</P
><P
>在Linux下，如果確實需要了解哪些屬性與每個進程相關，最可靠的信息源是Linux源碼，特別是<TT
CLASS="FILENAME"
>/usr/include/linux/sched.h</TT
>中的task_struct定義。</P
><P
>創建新進程的可移植方式是使用fork(2)調用。BSD作為優化技朮引進了一個叫做vfork(2)的變種。vfork(2)的使用原則很簡單：如果可以避免就<I
CLASS="EMPHASIS"
>不要</I
>使用它。vfork(2)與fork(2)不同，在調用execve(2V)或退出之前，子進程借用父進程的內存和控制線程﹔在子進程其資源時，父進程被懸挂。其原理是在舊的BSD系統中，fork(2)實際上會導致內存復制，而vfork(2)則不會。Linux則根本不會出現這個問題﹔因為Linux內部采用寫時復制的語義，只有在改變時才復制內存頁（實際上Linux還是有些表要復制的﹔在絕大多數情況下由此帶來的負荷不大）。盡管如此，由于有些程序依賴于vfork(2)，最近Linux實現了BSD的vfork(2)語義（以前Linux下的vfork(2)只是fork(2)的別名）。vfork(2)的問題在于，進程要想不與其父進程互相干擾需要相當的技巧，特別是使用高級語言。其后果在于：一旦代碼改變，甚或編譯器版本變化，都會很容易使調用了vfork(2)的程序失效。在絕大多數情況下應該避免vfork(2)﹔它的主要用途在于支持需要vfork語義的老程序。</P
><P
>Linux支持Linux特有的clone(2)調用。該調用與fork(2)類似，但允許明確說明哪些資源可以共享（如內存、文件描述符等等）。可移植程序不應該直接使用此調用﹔而是應該象前面所說的那樣，依賴于使用該調用實現線程的線程庫。</P
><P
>本文不是編寫程序的完全手冊，所以將跳過大量存在的處理進程的信息。可以參見wait(2)、exit(2)一類的文檔以了解更多內容。</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN256"
>POSIX能力</A
></H2
><P
>POSIX能力是支持把通常由root擁有的特權分割為更多更專門特權的一組比特位組合。POSIX能力是由一個IEEE標准草案定義的﹔它不是Linux所獨有的，但也并非其它類Unix系統普遍支持的。Linux內核2.0不支持POSIX能力，版本2.2增加了對進程的POSIX能力的支持。當Linux文檔（包括本文）中提到“要求root權限”時，實際上几乎都是意味著像能力文檔中所說的那樣“要求某個能力”。如果想知道要求的特定能力，請在能力文檔中進行查找。</P
><P
>在Linux中，其最終目的是允許能力與文件系統中的文件聯系起來﹔但到本文檔完成時，Linux還不支持這一點。Linux對能力傳遞有支持，但缺省情況下被禁用。版本2.2.11的Linux增加了一個叫做“能力綁定設置”的特性，使能力的應用更直接更有用。能力綁定設置是一組允許被系統中任意進程所擁有的能力（否則，只有特殊的初始化進程可以擁有這些能力）。如果某能力不在此綁定設置中，則無論有沒有權限，都不可以被任意進程所使用。例如，此特性可用來禁止內核模塊加載。利用此特性的一個工具實例是LCAP
<A
HREF="http://pweb.netcom.com/~spoon/lcap/"
TARGET="_top"
>http://pweb.netcom.com/~spoon/lcap/</A
>。</P
><P
>更多有關POSIX能力的資料可以從
<A
HREF="ftp://linux.kernel.org/pub/linux/libs/security/linux-privs"
TARGET="_top"
>ftp://linux.kernel.org/pub/linux/libs/security/linux-privs</A
>
獲得。</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN263"
>進程創建與操作</A
></H2
><P
>進程可以用fork(2)、不推荐使用的vfork(2)或者Linux獨有的clone(2)來創建﹔這些系統調用都復制當前進程，并從中創建兩個進程。一個進程可以通過調用execve(2)、或它的各種前端（參見exec(3)、system(3)和popen(3)）來執行一個不同的程序。</P
><P
>在程序執行時，其文件設置自己的setuid或setgid比特位，進程的EUID或EGID（分別）被設置為文件的EUID或EGID值。在用來支持setuid或setgid腳本時，由于存在競爭狀態，此功能會導致一個老的UNIX安全漏洞。在內核打開文件來查看運行的解釋器和（正在設置ID的）解釋器回轉并重新打開文件以解釋文件之間，攻擊者可以改變文件（直接或通過符號連接）。</P
><P
>不同的類Unix系統采用不同的方法處理setuid腳本的安全問題。某些系統，如Linux，在執行腳本時完全忽略setuid和setgid比特位，這顯然是一個安全的措施。SysVr4和BSD 4.4的大多數現代發行版使用一種不同的方法來避免內核競爭狀態。在這些系統中，當內核把要打開的setuid腳本的名稱傳遞給解釋器時，不使用路徑名（這會允許競爭狀態），而是傳遞文件名/dev/fd/3。這是一個腳本已經打開的特殊文件，所以不會出現攻擊者可以利用的競爭狀態。即使在這些系統上，我依然建議不要在安全程序中使用setuid/setgid腳本編程語言，下面會進一步討論這個問題。</P
><P
>在某些情況下，進程會影響各種UID和GID的值﹔參見setuid(2)、seteuid(2)、setreuid(2)和Linux特有的setfsuid(2)。特別是保存的用戶ID（SUID）屬性允許可信任的程序臨時切換自己的UID。類Unix系統支持按以下規則使用SUID：如果RUID被改變，或者EUID被設置為不等于RUID的值，SUID就被設為新的EUID。非特權用戶可以用自己的SUID來設置EUID，把RUID設為EUID，以及把EUID設為RUID。</P
><P
>Linux特有的進程屬性FSUID是用來允許NFS服務器一類的程序把自己的文件系統權限限制在某些給定的UID上，而不給這些UID向進程發送信號的許可。一旦EUID被改變，FSUID就被改為新的EUID值﹔FSUID的值可以用Linux獨有的調用setfsuid(2)單獨進行設置。注意，非root調用者只能把FSUID設置為當前的RUID、EUID、SEUID或當前的FSUID。</P
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x206.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x270.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>文檔習語</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>文件</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>