<HTML
><HEAD
><TITLE
>Java</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.54"><LINK
REL="HOME"
TITLE="Linux和Unix安全編程HOWTO"
HREF="book1.html"><LINK
REL="UP"
TITLE="特定語言的問題"
HREF="c760.html"><LINK
REL="PREVIOUS"
TITLE="Ada"
HREF="x811.html"><LINK
REL="NEXT"
TITLE="專題"
HREF="c868.html"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Linux和Unix安全編程HOWTO</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x811.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 9. 特定語言的問題</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="c868.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN814"
>Java</A
></H1
><P
>如果要用Java來開發安全程序，坦白地說，第一步（在學習了Java之后）就是要閱讀兩本有關Java安全的教材，即Gong [1999]和McGraw [1999]（后一本特別要看第7.1節）。還應該看一下Sun發布的安全代碼指南<A
HREF="http://java.sun.com/security/seccodeguide.html"
TARGET="_top"
>http://java.sun.com/security/seccodeguide.html</A
>。
有一組描述Java安全模型的幻燈片可以從
<A
HREF="http://www.dwheeler.com/javasec"
TARGET="_top"
>http://www.dwheeler.com/javasec</A
>
免費獲取。</P
><P
>下面是基于Gong [1999]、McGraw [1999]和Sun的指南的若干關鍵要點：

<P
></P
><OL
TYPE="1"
><LI
><P
>不要使用公共域或變量﹔把它們聲明為私有的并提供訪問函數以限制對它們的訪問。</P
></LI
><LI
><P
>除非有很好的理由，把方法都設為私有的（如果確實沒這樣做，說清楚其理由）。這些非私有的方法必須保護自己，因為它們可能會接收到受污染的數據（除非已經用其它方式對它們進行了保護）。</P
></LI
><LI
><P
>避免使用靜態域變量。這樣的變量附著在類（而非類的實例）上，而類可以被其它類所定位。其結果就是靜態域變量可以被其它類找到，因此很難保証它們的安全。</P
></LI
><LI
><P
>永遠不要把可變對象返回給潛在有惡意的代碼（因為代碼可能會改變它）。注意，數組是可變的（即使數組的內容不可變），所以不要返回一個含有敏感數據的內部數組的引用。</P
></LI
><LI
><P
>永遠不要直接保存用戶給定的可變對象（包括對象的數組）。否則，用戶可以把對象交給安全代碼，讓安全代碼“檢查”對象，并在安全代碼試圖使用數據時改變數據。應該在內部存儲數組前復制它們，而且要小心（例如，警惕用戶編寫的復制例程）。</P
></LI
><LI
><P
>不要依賴于初始化。有好几種方法給未初始化的對象分配內存。</P
></LI
><LI
><P
>除非有很好的理由，應該使每件事都是確定的。如果某個類或方法不是確定的，攻擊者就可以用某種危險而無法預知的方法來擴展它。注意，作為安全性的交換，這會帶來可擴展性的喪失。</P
></LI
><LI
><P
>不要在安全性上依賴包的范圍。若干類，如java.lang，缺省是關閉的，而且某些Java虛擬機（JVM）會讓你關閉其它包。否則，Java類是沒有關閉的。因此，攻擊者可以向包中引入一個新類，并用此新類來訪問你以為保護了的信息。</P
></LI
><LI
><P
>不要使用內部類。在內部類轉換為字節代碼時，內部類會轉換為可以訪問包中任意類的類。更糟的是，被封裝類的私有域靜悄悄地變成非私有的，允許內部類訪問！</P
></LI
><LI
><P
>最小化特權。如果可能，完全不要請求任何特殊的許可。McGraw更進一步地推荐不要標記任何代碼﹔我認為可以標記代碼（這樣用戶可以決定“只有列表上的發送者可以運行標記過的代碼”），但在編寫程序時要使程序不需要沙箱設置之外的權限。如果一定要有更大的權限，審讀代碼就會特別困難。</P
></LI
><LI
><P
>如果一定要標記代碼，應該把它們都放在一個檔案文件里。這里最好引用McGraw [1999]的原文：
<BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>此規則的目的是防止攻擊者使用混合匹配攻擊，構建新applet或庫把某些標記類與有惡意的類連接在一起，或者把根本意識不到會被一起使用的標記類連接在一起。通過把一組類標記在一起，就可以使這種攻擊更困難。現有的代碼標記系統在防止混合匹配攻擊上做得還不夠，所以這一規則還不能完全防止此類攻擊。但使用單個答案沒什么壞處。</P
></BLOCKQUOTE
></P
></LI
><LI
><P
>應該使類不可被復制。Java的類復制機制允許攻擊者不運行構建函數就實例化某個類。要使類不可被復制，只要在每個類里定義如下方法：
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>public final void clone() throws java.lang.CloneNotSupportedException {
   throw new java.lang.CloneNotSupportedException();
   }</PRE
></TD
></TR
></TABLE
></P
><P
>如果確實需要使類可被復制，那么可以采用几個保護措施來防止攻擊者重新定義復制方法。如果是定義自己的復制方法，只需要使它是確定的。如果不是定義自己的復制方法，至少可以通過增加如下內容來防止復制方法被惡意地重載：
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>public final void clone() throws java.lang.CloneNotSupportedException {
  super.clone();
  }</PRE
></TD
></TR
></TABLE
></P
></LI
><LI
><P
>應該使類不可序列化。系列化運行攻擊者看到對象的內部狀態，甚至私有部分。要防止這一點，需要在類里增加如下方法：
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>private final void writeObject(ObjectOutputStream out)
  throws java.io.IOException {
     throw new java.io.IOException("Object cannot be serialized");
  }</PRE
></TD
></TR
></TABLE
></P
><P
>甚至在序列化沒問題的情況下，也應該對包含直接處理系統資源的域和包含與地址空間有關信息的域使用臨時關鍵字。否則，解除類的序列化就會允許不適當的訪問。可能還需要把敏感信息標識為臨時的。</P
><P
>如果對類定義了自己的序列化方法，就不應該把內部數組傳遞給需要數組的DataInput/DataOuput方法。其理由在于：所有的DataInput/DataOuput方法都可以被重載。如果某個可序列化的類向某個DataOutput(write(byte [] b))方法直接傳遞了一個私有數組，那么攻擊者就可以構建子類ObjectOutputStream并重載write(byte [] b)方法，從而可以訪問并修改那個私有數組。注意，缺省的序列化并沒有把私有字節數組域暴露給DataInput/DataOutput字節數組方法。</P
></LI
><LI
><P
>應該使類不可被解除序列化。即使類不可被序列化，它依然可以被解除序列化。攻擊者可以構建一個字節序列，使它碰巧是被解除序列化的某個類實例，而且具有攻擊者選定的值。換句化話說，解除序列化是一種公共的構建函數，允許攻擊者選擇對象的狀態 -- 顯然是一個危險的操作！ 要防止這一點，需要在類里增加如下方法： 
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>private final void readObject(ObjectInputStream in)
  throws java.io.IOException {
    throw new java.io.IOException("Class cannot be deserialized");
  }</PRE
></TD
></TR
></TABLE
></P
></LI
><LI
><P
>不要通過名稱來比較類。畢竟攻擊者可以用相同的名稱定義類，而且一不小心就會授予這些類不恰當的權限。因此，下面是一個判斷某個對象是否含有某個給定類的<I
CLASS="EMPHASIS"
>錯誤</I
>方法的例子：
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>  if (obj.getClass().getName().equals("Foo")) {</PRE
></TD
></TR
></TABLE
></P
><P
>如果要判斷兩個對象是否含有完全相同的類，不要對雙方使用getClass()并使用“==”操作符進行比較，而應該使用如下形式：
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>  if (a.getClass() == b.getClass()) {</PRE
></TD
></TR
></TABLE
>
如果確實需要判斷某個對象是否含有某個給定類名，需要嚴格按照規范并確保使用當前名稱空間（當前類的ClassLoader所在名稱空間）。因此，應該使用如下形式：
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>  if (obj.getClass() == this.getClassLoader().loadClass("Foo")) {</PRE
></TD
></TR
></TABLE
></P
><P
>本原則來自McGraw和Felten，而且確實是個好原則。要補充的是，盡可能地避免比較類值通常是個好注意。通常最好是盡力設計類的方法和接口，從而完全不必要做這些事。盡管如此，實際上無法完全做到，所以知道這些技巧還是很重要的。</P
></LI
><LI
><P
>不要把秘密（密鑰、密碼或算法）存儲在代碼或數據里。有惡意的JVM可以迅速看到這一數據。打亂代碼并不能在認真的攻擊者面前實際隱藏代碼。</P
></LI
></OL
>&#13;</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x811.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="c868.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Ada</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c760.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>專題</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>