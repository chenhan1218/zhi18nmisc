<HTML
><HEAD
><TITLE
>避免緩存溢出</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.54"><LINK
REL="HOME"
TITLE="Linux和Unix安全編程HOWTO"
HREF="book1.html"><LINK
REL="PREVIOUS"
TITLE="限制合法的輸入時間和負載水平"
HREF="x499.html"><LINK
REL="NEXT"
TITLE="C/C++中庫的解決方案"
HREF="x515.html"></HEAD
><BODY
CLASS="CHAPTER"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Linux和Unix安全編程HOWTO</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x499.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x515.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
><A
NAME="AEN502"
>Chapter 5. 避免緩存溢出</A
></H1
><TABLE
BORDER="0"
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
CLASS="EPIGRAPH"
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="LEFT"
VALIGN="TOP"
><I
><P
><I
>An enemy will overrun the land;
he will pull down your strongholds and
plunder your fortresses.</I
></P
></I
></TD
></TR
><TR
><TD
WIDTH="45%"
>&nbsp;</TD
><TD
WIDTH="45%"
ALIGN="RIGHT"
VALIGN="TOP"
><I
><SPAN
CLASS="ATTRIBUTION"
>Amos 3:11 (NIV)</SPAN
></I
></TD
></TR
></TABLE
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="c502.html#AEN512"
>C/C++中的危險</A
></DT
><DT
><A
HREF="x515.html"
>C/C++中庫的解決方案</A
></DT
><DT
><A
HREF="x568.html"
>C/C++的編譯解決方案</A
></DT
><DT
><A
HREF="x576.html"
>其它語言</A
></DT
></DL
></DIV
><P
>一個非常普遍的安全性缺陷是“緩存溢出”。從技朮上來說，緩存溢出是程序內部實現的問題，但它是個非常普遍而且嚴重的問題，所以把它放在單獨的一節里進行說明。在CERT，1998年13篇報告中的9篇和至少1999年一半的報告都與緩存溢出有關，這大概可以加深你對該問題重要性的認識。Bugtraq的一項非正式調查發現大約2/3的響應認為緩存溢出是安全性薄弱環節的首要因素（其余的響應認為“配置錯誤”是首要原因）[Cowan 1999]。這是一個古老而且眾所周知的問題，但它還是不斷地重復出現[McGraw 2000]。</P
><P
>如果把一組值（通常是一個字符串）寫入某個固定長度的緩存區并越過緩存邊界（一般是越過緩存的結尾）持續寫入至少一個值時，緩存溢出就發生了。緩存溢出在從用戶那里讀入輸入放進緩存時會發生，但也會在程序的其它處理過程中發生。</P
><P
>如果某個安全程序允許緩存溢出，它就經常會被對手利用。如果該緩存為局部C變量，溢出就可以被用來強迫函數運行攻擊者選擇的代碼。這種特殊的攻擊手段被稱為“堆棧沖擊”攻擊。放置在堆中的緩存也好不到哪里去﹔攻擊者可以用這樣的溢出來控制程序里的變量。更多的細節可以從Aleph1 [1996]、Mudge [1995]或
<A
HREF="http://destroy.net/machines/security/"
TARGET="_top"
>http://destroy.net/machines/security/</A
>
上Nathan P. Smith的“Stack Smashing Security Vulnerabilities”WEB站點上找到。</P
><P
>大多數編程語言從根本上避免了這個問題，或者是因為它們自動地重新設置數組大小（如Perl），或者是因為它們一般檢測并防止緩存溢出（如Ada95）。但是，C語言根本沒有提供對此問題的保護，C++在使用時也很容易導致此問題。</P
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN512"
>C/C++中的危險</A
></H1
><P
>C用戶必須避免使用不檢查邊界的危險函數，除非它們能確保邊界不會被超過。在大多數情況下應避免的函數包括strcpy(3)、strcat(3)、sprintf(3)（以及相近的vsprintf(3)）和gets(3)函數。它們應該被相應的諸如strncpy(3)、strncat(3)、snprintf(3)和fgets(3)函數所替代，但請閱讀下面的討論。函數strlen(3)應該被避免，除非能確定可以找到一個作為終止的NIL字符。scanf()函數族（scanf(3)、fscanf(3)、sscanf(3)、vscanf(3)、vsscanf(3)和vfscanf(3)）在應用時經常是危險的﹔不要在沒有控制最大長度（格式%s是個特別普遍的問題）的情況下使用它來向某個字符串發送數據。其它可能會允許緩存溢出（與應用有關）的危險函數包括realpath(3)、getopt(3)、getpass(3)、streadd(3)、strecpy(3)和strtrns(3)。必須小心getwd(3)﹔發送給getwd(3)的緩存必須至少有PATH_MAX個字節長。如果你很重視可移植性問題，那么還有一個額外的問題：某些系統上的snprintf對緩存溢出并無實際的保護﹔據我所知，Linux下的版本是正確工作的。


       [vf]scanf(const char *format, ...)
              參數可能溢出。 
       realpath(char *path, char resolved_path[])
              路徑緩存可能溢出。
      [v]sprintf(char *str, const char *format, ...)
              str緩存可能溢出。&#13;</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x499.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x515.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>限制合法的輸入時間和負載水平</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>C/C++中庫的解決方案</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>