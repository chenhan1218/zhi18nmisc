<HTML
><HEAD
><TITLE
>特權最小化</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.54"><LINK
REL="HOME"
TITLE="Linux和Unix安全編程HOWTO"
HREF="book1.html"><LINK
REL="UP"
TITLE="程序內部結構與解決方案"
HREF="c579.html"><LINK
REL="PREVIOUS"
TITLE="程序內部結構與解決方案"
HREF="c579.html"><LINK
REL="NEXT"
TITLE="避免創建Setuid/Setgid腳本"
HREF="x643.html"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Linux和Unix安全編程HOWTO</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="c579.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 6. 程序內部結構與解決方案</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x643.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN587"
>特權最小化</A
></H1
><P
>正如前文所說的那樣，使程序只擁有完成任務所必需的最少量特權（被稱為“極小特權”）是一個重要的通用原則。這樣，如果程序被破壞，危害也是有限的。最極端的例子是干脆不寫安全程序 -- 如果可以的話，通常應該這樣做。例如，如果可以，不要讓程序setuid或setgid﹔只讓它作為一個普通程序，要求系統管理員在運行該程序前登錄執行。</P
><P
>在Linux和Unix下，確定進程特權的主要是一組與之相關的ID：每個進程都有用戶和群組的真實、有效和保存ID。Linux還有文件系統uid和gid。處理這些值是使特權最小化的關鍵，而且有若干種方法使它們最小化（在下面討論）。還可以使用chroot(2)最小化文件對程序的可視性。</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN591"
>最小化授予的特權</A
></H2
><P
>可能最有效的技朮就是簡單地最小化授予的最高特權。特別是在可能的情況下，避免授予程序root特權。如果某程序只需要存取一小組文件，不要使它<I
CLASS="EMPHASIS"
>setuid root</I
>﹔考慮為不同的函數分別創建用戶或群組帳戶。</P
><P
>一個常用技朮是創建一個特殊的群組，把文件的群組所有權改為該群組，然后使程序<I
CLASS="EMPHASIS"
>setgid</I
>到該群組。最好在可能的情況下盡量使程序<I
CLASS="EMPHASIS"
>setgid</I
>，而不是<I
CLASS="EMPHASIS"
>setuid</I
>，因為群組成員獲得的權限較少（特別是它不會具有改變文件許可的權利）。</P
><P
>通常這被用于獲取游戲的高分。游戲通常是setgid <I
CLASS="EMPHASIS"
>games</I
>，成績文件屬于群組<I
CLASS="EMPHASIS"
>games</I
>，而程序本身及其配置文件為其他用戶（如root）所有。這樣，破壞一個游戲就允許犯罪者改變高分，但沒有給予他改變游戲的可執行文件或配置文件的特權。重要的是后一點﹔如果攻擊者可以改變游戲的可執行文件或它的配置文件（可用來控制可執行文件的運行），那么他們就可能獲得對運行游戲的用戶的控制。</P
><P
>如果創建一個新群組還不夠，可以考慮創建一個新的偽用戶（一個確實特殊的角色）來管理一組資源。WEB服務器一般就這么做﹔通常WEB服務器是用一個特殊用戶（“nobody”）建立起來的，這樣就可以與別的用戶隔離起來。確實，WEB服務器在此很有教育意義：WEB服務器通常需要root權限來啟動（這樣才可以連接到端口80上），但一旦啟動之后，它們通常放棄所有的權限，以用戶“nobody”身份運行。另外，偽用戶通常不擁有其運行的基本程序，所以破解了該帳戶并不會允許改變程序本身。其結果就是，闖入一個運行著的WEB服務器一般不會自動破壞整個系統的安全。</P
><P
>如果<I
CLASS="EMPHASIS"
>必須</I
>給予某個程序root權限，應該考慮使用Linux 2.2以上版本提供的POSIX能力特性，在程序啟動時就立即使這些權限最小化。在啟動后立刻調用cap_set_proc(3)或Linux特有的capsetp(3)例程，就可以永久地把程序的能力減小為它實際所需要的那些能力。注意，<I
CLASS="EMPHASIS"
>不是</I
>所有類Unix系統都實現了POSIX能力，所以此方案會喪失可移植性﹔盡管如此，如果只是把它作為僅在可用處應用的防護選項，使用此方案實際上就不會限制可移植性。同樣，由于Linux內核2.2以上版本中包含了底層調用，而在某些Linux發行版中沒有安裝簡化這些調用應用的C語言級的庫，這使得在應用程序中的應用變得略微有些復雜。要了解更多有關Linux下POSIX能力的實現，參見
<A
HREF="http://linux.kernel.org/pub/linux/libs/security/linux-privs"
TARGET="_top"
>http://linux.kernel.org/pub/linux/libs/security/linux-privs</A
>。</P
><P
>可用來簡化最小化授予特權的一個Linux獨有的工具是SuSE開發的“compartment”工具。該工具設置文件系統的根目錄、uid、gid和（或）能力集，然后運行給定的程序。它不用修改程序，運行某些其它程序特別方便。下面是版本0.5的句法：

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;句法：compartment [options] /full/path/to/program

Options:
         --chroot path	把根目錄改為path
         --user user	把uid改為user
         --group group	把gid改為group
         --init program	在其它操作前先執行程序/腳本program
         --cap capset	設置capset名稱。可以指定多個capset。
         --verbose	顯示所有提示
         --quiet		不產生日志文件</PRE
></TD
></TR
></TABLE
>&#13;</P
><P
>這樣就可以用以下命令啟動一個更加安全的匿名FTP服務器：
 
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>  compartment --chroot /home/ftp --cap CAP_NET_BIND_SERVICE anon-ftpd</PRE
></TD
></TR
></TABLE
>&#13;</P
><P
>在寫作本文的時候，該工具還不成熟，在通常的Linux發行版中也不提供，但情況會很快改變。你可以通過
<A
HREF="http://www.suse.de/~marc"
TARGET="_top"
>http://www.suse.de/~marc</A
>
下載該程序。</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN613"
>最小化可以使用特權的時間</A
></H2
><P
>如果可能的話，就永久性地放棄特權。有些類Unix系統，包括Linux，實現了保存“以前的”值的“保存”ID。最簡單的方法就是把某個不可信ID 兩次設置為其它ID。在setuid/setgid程序中，需要經常把有效gid和uid設置為真實的gid和uid，特別是在fork(2)之后，除非有不這么做的充分理由。注意，在從root權限改變為其它權限時要先改變gid，否則無效 -- 一旦放棄了root權限，就無法改變很多其它的東西了。</P
><P
>值得注意的是一個眾所周知的相關Bug，即使用POSIX能力會干擾這一最小化。這個Bug影響Linux內核版本2.2.0到2.2.15，可能還涉及具有POSIX能力的若干其它類Unix系統。參見http://www.securityfocus.com上Bugtraq id 1322以了解更多信息。下面是其概要：
<BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>Linux內核最近實現了POSIX“能力”。這些“能力”是特權控制的一種附加格式，以更為明確地控制具有特權的進程可以做些什么。能力是用三個（相當大）比特位域實現的，每個比特代表特權進程可以執行的特別操作。通過設置特定的比特位就可以控制特權進程的操作 -- 只有需要訪問各種函數的程序的特定部分才可以有訪問函數的權利。這是個安全措施。問題在于能力是使用fork()進行復制的，也就是說，如果能力被父進程修改，則修改會被傳遞下去。通過把三個比特位域中每一個的所有能力設為零（即所有比特位都關閉），然后執行一個setuid程序，嘗試在執行代碼前放棄特權，這在以root身份運行時會是危險的，就象sendmail所做的那樣，這樣就可以加以利用。當sendmail使用setuid（getuid()）試圖放棄特權時，由于其比特位域所要求的能力不存在而操作失敗，并且不檢查返回值。sendmail繼續以超級用戶的特權運行，可能會以root身份執行某個用戶發來的文件從而導致完全的危害。</P
></BLOCKQUOTE
>
sendmail使用的一個方案是嘗試在setuid（getuid()）之后執行setuid(0)﹔一般情況下這會失敗。如果成功，程序就停止了。更多的信息可參見http://sendmail.net/?feed=000607linuxbug。在近期這可能是個其它程序中的好主意，雖然很明顯更好的長期解決方案是升級基本系統。</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN619"
>最小化特權有效的時間</A
></H2
><P
>使用setuid(2)、seteuid(2)和相關函數以確保程序的特權只在需要的時刻有效。正如上面說明的那樣，可能在解析用戶輸入時你會希望確保這些特權被禁用，但更一般的情況是，只在確實需要的時候才啟用這些特權。注意，如果某些緩存溢出攻擊成功的話，可以迫使程序運行任意代碼，而且那個代碼可以重新啟用臨時放棄了的特權。因此，最好是盡快完全地放棄特權。盡管如此。臨時禁用這些許可防范了諸如誘使程序寫入某個原來無意寫入的文件的一整類技朮攻擊。由于最小化特權有效時間的技朮防范了很多攻擊，在程序中無法完全放棄特權的地方就值得這么做。</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN622"
>&#62;最小化獲得特權的模塊</A
></H2
><P
>如果只有几個模塊被授予了許可，那么確定它們是否安全就容易得多。這樣做的一個方法是：讓單個模塊使用特權，然后放棄，這樣隨后調用的其它模塊就不會誤用該特權。另一個方案是在不同的可執行文件里使用不同的命令﹔某個命令是可以以某個特權用戶（如root）的身份執行大量任務的一個復雜工具，而其它工具是setuid的，而且是只允許使用一個小的命令子集的簡單工具。這一簡單的小工具檢查輸入是否符合可以接受的各種標准，如果確定輸入是可以接受的，就把輸入傳遞給第一個工具。這甚至可以用多種方法來分層，例如，復雜的用戶工具可以調用一個簡單的setuid“包裹”程序（來檢查輸入為安全值），然后把信息傳遞給另一個復雜的可信工具。該方案對于基于GUI的系統特別有用：讓GUI部分以普通用戶身份運行，然后把與安全相關的請求傳遞給另一個對實際運行有特殊權限的程序。</P
><P
>有些操作系統在單個進程中有多級信任的概念，如Multics的環。標准Unix和Linux無法這樣在單個進程中用函數區分信任的多個級別﹔調用內核會增加特權，但一個給定進程只有單一的信任級別。Linux和其它類Unix系統有時可以通過把一個進程復制成多個進程，每個進程有一個不同的特權來模擬這一能力。要做到這一點，可以建立一個安全的通信通道（一般是使用非命名管道或非命名套接字），然后復制出多個進程并使每個進程放棄盡可能多的特權。然后再使用一個簡單協議來允許低信任度的進程請求高信任度進程的服務，并確保高信任度的進程只支持有限的一組請求。</P
><P
>Java 2和Fluke之類的技朮在此方面有一定的優越性。例如，Java 2可以指定諸如只允許打開某個特定文件的很細的許可。但通用操作系統目前一般沒有這樣的能力﹔在不遠的將來可能情況會有所改變。</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN627"
>考慮用FSUID來限制特權</A
></H2
><P
>每個Linux進程都有兩個叫作文件系統用戶ID（fsuid）和文件系統群組ID（fsgid）的Linux獨有的狀態值。在檢查文件系統許可時使用這兩個值。如果你在構建一個象文件服務器那樣供任意用戶操作的程序（比如NFS服務器），可能就要考慮使用這些Linux擴展了。使用它們時，在保持root權限的同時，在以普通用戶身份存取文件前只需要改變fsuid和fsgid。這個擴展相當有用，它提供了一個無需刪除其它（可能必需的）權限就限制了文件系統訪問權限的機制。只設置fsuid（而不設置euid），本地用戶就無法向進程發送信號。在這種情況下避免競爭情況也容易得多。盡管如此，此方案的一個缺點就是這些調用無法移植到其它類Unix系統上。</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN630"
>考慮使用chroot來最小化可用文件</A
></H2
><P
>可以用chroot(2)來限制對程序可見的文件。這要求仔細地建立一個目錄（稱為“chroot監”）并正確地進入。這可以成為一個增強程序安全性的相當有效的技朮 -- 很難去干擾看不見的文件。但是，這是建立在一整套假設之上的，特別是程序必須沒有root權限，它必須無法獲得root權限，而且chroot監必須恰當地建立。我推荐在適合的地方使用chroot(2)，但不要僅僅依賴于它﹔而是使它作為多層防御的一部分。下面是使用chroot(2)的若干說明：

<P
></P
><UL
><LI
><P
>程序還是可以使用整個機器共享的非文件系統對象（例如System V的IPC對象和網絡套接字）。最好也使用不同的偽用戶和（或）群組，因為所有類Unix系統都包含了隔離用戶的能力﹔這至少可以限制一個被破解的程序可能對其它程序造成的危害。注意，目前絕大多數類Unix系統（包括Linux）都沒有隔離有意進行合作的程序﹔如果擔心惡意的程序合作，就需要獲得一個實現了某種強制訪問控制和（或）限制隱藏通道的系統。</P
></LI
><LI
><P
>如果不希望以后被使用，務必要關閉對外面文件的文件系統描述符。特別是不要打開到chroot監之外目錄的描述符，或者出現這樣的描述符可能被獲取的情況（如通過Unix套接字或著某個/proc的早期實現）。如果程序得到了chroot 監之外目錄的描述符，就可以借此脫離chroot監了。</P
></LI
><LI
><P
>chroot監必須安全地建立。不要用某個普通用戶的根目錄（或子目錄）作為chroot監﹔使用一個獨立的位置或為此目的特別設置的“根”目錄。
把確實最少數目的文件放在那里。一般會有/bin、/etc/、/lib以及一兩個其它可能的目錄（比如FTP服務器就還有個/pub）。只把進行了chroot()之后需要運行的放入/bin﹔有時什么都不需要（盡量避免把shell放在那里，雖然有時這沒什么作用）。可能還需要一個/etc/passwd和/etc/group，這樣在文件列表時可以顯示一些正確的名稱，但在這樣做時，不要包含真實的系統值，而且肯定要把所有密碼替換為“*”。在/lib下只放所必需的﹔用ldd(1)來查詢/bin下的每一個程序，看需要些什么，然后只在該目錄下包括它們。在Linux下，可能需要ld-linux.so.2一類的很少几個基本庫，別的都不需要。一般來說把所有文件都復制下來是個聰明的辦法，而不是生成硬連接﹔雖然這會浪費一些時間和磁盤空間，但它使對chroot監內文件的攻擊不會自動蔓延到正常的系統文件。在支持chroot監的系統上安裝/proc文件系統一般是不明智的。實際上這在Linux的2.0.x版本上是一個已知的安全漏洞，因為/proc下有些偽目錄可以讓chroot的程序逃脫。Linux內核2.2修補了這一已知漏洞，但可能還存在其它問題﹔所以盡可能地不要這么做。</P
></LI
><LI
><P
>如果程序可以獲得root權限，chroot實際上就不起作用。例如，程序可以使用mknod(2)一類的調用來創建一個可以瀏覽物理內存的設備文件，然后利用產生的設備文件來修改內核空間，給予自己任意想得到的特權。另一個root程序如何逃出chroot的例子在
<A
HREF="http://www.suid.edu/source/breakchroot.c"
TARGET="_top"
>http://www.suid.edu/source/breakchroot.c</A
>
上有說明。在該例中，程序為當前目錄打開一個文件描述符，創建并chroot到一個子目錄，把當前目錄設為此前打開的當前目錄，然后從當前目錄重復使用cd回溯（由于在當前chroot之外，就成功地移動到真實文件系統的根目錄），再對其結果調用chroot。在閱讀本文檔的時候，這些漏洞可能已經被填補了，但事實是root特權在傳統上意味著“所有特權”，而且很難被去掉。最好只是假設使用chroot()對要求持續root特權的程序略有幫助而已。當然，也可以把程序分成若干部分，這樣至少可以有一部分可以放在chroot監里。</P
></LI
></UL
>&#13;</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="c579.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x643.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>程序內部結構與解決方案</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c579.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>避免創建Setuid/Setgid腳本</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>