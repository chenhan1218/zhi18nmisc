<HTML
><HEAD
><TITLE
>動態連接庫</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.54"><LINK
REL="HOME"
TITLE="Linux和Unix安全編程HOWTO"
HREF="book1.html"><LINK
REL="UP"
TITLE="Linux和Unix安全特性概要"
HREF="c211.html"><LINK
REL="PREVIOUS"
TITLE="配額與限制"
HREF="x354.html"><LINK
REL="NEXT"
TITLE="審核"
HREF="x378.html"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Linux和Unix安全編程HOWTO</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x354.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 3. Linux和Unix安全特性概要</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x378.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN359"
>動態連接庫</A
></H1
><P
>實際上所有程序執行都依賴于庫。在包括Linux的大多數現代類Unix系統中，程序缺省使用<I
CLASS="EMPHASIS"
>動態連接庫</I
>（DLL）進行編譯。這樣就可以更新某個庫，所有使用該庫的程序如果可能的話，都將使用新的（希望有所改進的）版本。</P
><P
>動態連接庫通常被放在若干特殊目錄下。通常這些目錄包括<TT
CLASS="FILENAME"
>/lib</TT
>、<TT
CLASS="FILENAME"
>/usr/lib</TT
>、有關PAM模塊的<TT
CLASS="FILENAME"
>/lib/security</TT
>、有關X-windows的<TT
CLASS="FILENAME"
>/usr/X11R6/lib</TT
>和<TT
CLASS="FILENAME"
>/usr/local/lib</TT
>。</P
><P
>對于庫的命名和進行庫的符號連接有些特殊約定，這樣就可以更新庫，同時繼續支持需要使用不具有反向兼容的老版本庫的程序。在執行特定程序時可以覆蓋某個指定庫，甚至只覆蓋某個庫里的指定函數。這是類Unix系統相對于類Windows系統的一個實際優點﹔我相信類Unix系統有一個更好的系統來處理庫的更新，這也是Unix和Linux系統被認為比基于Windows的系統更穩定的原因。</P
><P
>在包括所有Linux系統的基于GNU glibc的系統中，程序啟動時自動尋找的目錄列表存儲在文件/etc/ld.so.conf中。很多源于Red Hat的發行版一般在文件<TT
CLASS="FILENAME"
>/etc/ld.so.conf</TT
>中不包含<TT
CLASS="FILENAME"
>/usr/local/lib</TT
>。我認為這是個Bug，要在源于Red Hat的系統里運行很多程序都需要進行一個通用的“修復”，把<TT
CLASS="FILENAME"
>/usr/local/lib</TT
>加入<TT
CLASS="FILENAME"
>/etc/ld.so.conf</TT
>。如果只是想覆蓋某個庫里的若干函數，而想保留該庫的其它部分，可以在<TT
CLASS="FILENAME"
>/etc/ld.so.preload</TT
>中輸入要覆蓋的庫名（.o文件）﹔這些“預載入”的庫會優先于標准庫使用。通常這種預載入文件是用于緊急補丁的﹔發行版在發行時一般不會包含這樣的文件。在程序啟動時尋找所有這些目錄太花時間，所以實際上使用了一個cache管理方法。程序ldconfig(8)缺省讀入文件/etc/ld.so.conf，在動態連接目錄里建立相應的符號連接（這樣就遵循了標准約定），然后把cache寫入/etc/ld.so.cache，這樣就可以被其它程序使用了。所以一旦增加一個DLL，或刪除一個DLL，或者DLL目錄集發生改變，ldconfig就要運行一次﹔在安裝庫時，運行ldconfig通常是軟件包管理程序需要執行的一個步驟。在啟動時，程序使用動態加載程序來讀入文件/etc/ld.so.cache，然后載入其所需的庫。</P
><P
>各種環境變量可以控制這一過程，而且事實上也有允許覆蓋此過程的環境變量（所以可以在某次特別的執行過程中臨時替換某個不同的庫）。在Linux下，環境變量LD_LIBRARY_PATH是一組用逗號隔開的目錄，在查找標准目錄集之前先查找這些庫﹔這在調試新庫或為特殊目的使用非標准庫時很有用。變量LD_PRELOAD列出了覆蓋標准集的函數所在的目標文件，就像/etc/ld.so.preload一樣。</P
><P
>如果不采取特別的措施，允許用戶控制動態連接庫會對setuid/setgid程序造成災難性的后果。因此在實現GNU glibc時，如果是setuid或setgid程序，將忽略這些變量（和其它類似的變量），或者嚴格限制這些變量所起的作用。GNU的glibc庫通過檢查程序的証明來確定其是否為setuid或setgid程序﹔如果uid和euid不同，或者gid和egid不同，則庫就假設該程序為setuid/setgid程序（或者為其子程序），然后嚴格限制它控制連接的能力。如果載入GNU的glibc庫，就可以看到這種情況﹔請特別閱讀一下文件elf/rtld.c和sysdeps/generic/dl-sysdep.c。這就意味著如果使uid和gid等于euid和egid，再調用程序，這些變量就具有完全的效力。其它類Unix系統處理這些情況有所不同，但原因相同：一個setuid/setgid程序不應受到環境變量集的過分影響。</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x354.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x378.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>配額與限制</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c211.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>審核</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>