<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>GNU/Linux AI &amp; Alife HOWTO: Evolutionary Computing</TITLE>
 <LINK HREF="AI-Alife-HOWTO-5.html" REL=next>
 <LINK HREF="AI-Alife-HOWTO-3.html" REL=previous>
 <LINK HREF="AI-Alife-HOWTO.html#toc4" REL=contents>
<SCRIPT src="../menu.js"> function BeginPage() {} function EndPage() {} </SCRIPT> </HEAD> <BODY bgcolor=#EEEEFF MARGINHEIGHT=0 MARGINWIDTH=0> <SCRIPT>BeginPage(1, 8, 1);</SCRIPT>
<A HREF="AI-Alife-HOWTO-5.html"><IMG SRC="../img/next.gif" ALT="Next"></A>
<A HREF="AI-Alife-HOWTO-3.html"><IMG SRC="../img/prev.gif" ALT="Previous"></A>
<A HREF="AI-Alife-HOWTO.html#toc4"><IMG SRC="../img/toc.gif" ALT="Contents"></A>
<HR>
<H2><A NAME="s4">4. Evolutionary Computing</A>    </H2>

<P>Evolutionary computing is actually a broad term for a vast
array of programming techniques, including genetic algorithms,
complex adaptive systems, evolutionary programming, etc.
The main thrust of all these techniques is the idea of
evolution. The idea that a program can be written that will
<I>evolve</I> toward a certain goal.  This goal can be
anything from solving some engineering problem to winning a
game.
<P>
<P>
<H2><A NAME="ss4.1">4.1 EC class/code libraries</A>
    </H2>

<P>
<P>These are libraries of code or classes for use in programming within
the evolutionary computation field.  They are not meant as stand alone
applications, but rather as tools for building your own applications.
<P>
<DL>
<P>
<P>
<A NAME="daga"></A> <DT><B>daga</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://GARAGe.cps.msu.edu/software/software-index.html">GARAGe.cps.msu.edu/software/software-index.html</A></LI>
</UL>
<P>
<P>daga is an experimental release of a 2-level genetic algorithm  
compatible with the GALOPPS GA software. It is a meta-GA which
dynamically evolves a population of GAs to solve a problem presented to
the lower-level GAs. When multiple GAs (with different operators,
parameter settings, etc.) are simultaneously applied to the same
problem, the ones showing better performance have a higher probability
of surviving and "breeding" to the next macro-generation (i.e.,
spawning new "daughter"-GAs with characteristics inherited from the
parental GA or GAs.  In this way, we try to encourage good  
problem-solving strategies to spread to the whole population of GAs.
<P>
<P>
<A NAME="Ease"></A> <DT><B>Ease</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.sprave.com/Ease/Ease.html">www.sprave.com/Ease/Ease.html</A></LI>
</UL>
<P>Ease - Evolutionary Algorithms Scripting Evironment - is an extension
to the Tcl scripting language, providing commands to create, modify,
and evaluate populations of individuals represented by real number
vectors and/or bit strings.
<P>
<P>
<P>
<A NAME="EO"></A> <DT><B>EO</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://geneura.ugr.es/~jmerelo/EO.html">geneura.ugr.es/~jmerelo/EO.html</A></LI>
</UL>
<P>EO is a templates-based, ANSI-C++ compliant evolutionary
computation library. It contains classes for any kind of
evolutionary computation (specially genetic algorithms) you might
come up to. It is component-based, so that if you don't find the
class you need in it, it is very easy to subclass existing  
abstract or concrete class.
<P>
<P>
<P>
<A NAME="Fortran GA"></A> <DT><B>FORTRAN GA</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.staff.uiuc.edu/~carroll/ga.html">www.staff.uiuc.edu/~carroll/ga.html</A></LI>
</UL>
<P>
<P>This program is a FORTRAN version of a genetic algorithm driver.
This code initializes a random sample of individuals with
different parameters to be optimized using the genetic algorithm
approach, i.e.  evolution via survival of the fittest.  The
selection scheme used is tournament selection with a shuffling
technique for choosing random pairs for mating.  The routine
includes binary coding for the individuals, jump mutation, creep
mutation, and the option for single-point or uniform crossover.
Niching (sharing) and an option for the number of children per
pair of parents has been added.  More recently, an option for
the use of a micro-GA has been added.
<P>
<P>
<P>
<A NAME="GAGS"></A> <DT><B>GAGS</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://kal-el.ugr.es/gags.html">kal-el.ugr.es/gags.html</A></LI>
<LI>FTP site: 
<A HREF="ftp://kal-el.ugr.es/GAGS/">kal-el.ugr.es/GAGS/</A></LI>
</UL>
<P>
<P>Genetic Algorithm  application generator and class library
written mainly in C++.
As a class library, and among other thing, GAGS includes:
<UL>
<LI>A <EM>chromosome hierarchy</EM> with variable length
chromosomes.  <EM>Genetic operators</EM>: 2-point crossover,
uniform crossover, bit-flip mutation, transposition (gene
interchange between 2 parts of the chromosome), and
variable-length operators: duplication, elimination, and
random addition.</LI>
<LI><EM>Population level operators</EM> include steady state, roulette
wheel and tournament selection.</LI>
<LI><EM>Gnuplot wrapper</EM>: turns gnuplot into a
<CODE>iostreams</CODE>-like class.</LI>
<LI>Easy sample file loading and configuration file parsing.</LI>
</UL>

As an application generator (written in <CODE>PERL</CODE>),
you only need to supply it with an ANSI-C or C++ fitness
function, and it creates a C++ program that uses the above
library to 90% capacity, compiles it, and runs it, saving
results and presenting fitness thru <CODE>gnuplot</CODE>.
<P>
<P>
<A NAME="GALib"></A> <DT><B>GAlib: Matthew's Genetic Algorithms Library</B><DD><P>
<UL>
<LI>Web Site: 
<A HREF="http://lancet.mit.edu/ga/">lancet.mit.edu/ga/</A> </LI>
<LI>FTP site: 
<A HREF="ftp://lancet.mit.edu/pub/ga/">lancet.mit.edu/pub/ga/</A></LI>
<LI>Register GAlib at: 
<A HREF="http://lancet.mit.edu/ga/Register.html">lancet.mit.edu/ga/Register.html</A></LI>
</UL>
<P>
<P>GAlib contains a set of C++ genetic algorithm objects.  The
library includes tools for using genetic algorithms to do
optimization in any C++ program using any representation and genetic
operators.  The documentation includes an extensive overview of how
to implement a genetic algorithm as well as examples illustrating
customizations to the GAlib classes.
<P>
<P>
<P>
<A NAME="GALOPPS"></A> <DT><B>GALOPPS</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://GARAGe.cps.msu.edu/software/software-index.html">GARAGe.cps.msu.edu/software/software-index.html</A></LI>
<LI>FTP site: 
<A HREF="ftp://garage.cps.msu.edu/pub/GA/galopps/">garage.cps.msu.edu/pub/GA/galopps/</A></LI>
</UL>
<P>
<P>GALOPPS is a flexible, generic GA, in 'C'.  It was based upon
Goldberg's Simple Genetic Algorithm (SGA) architecture, in order to
make it easier for users to learn to use and extend.
<P>
<P>GALOPPS extends the SGA capabilities several fold:
<UL>
<LI> (optional) A new Graphical User Interface, based on TCL/TK, 
for Unix users, allowing easy running of GALOPPS 3.2 (single 
or multiple subpopulations) on one or more processors.  GUI 
writes/reads "standard" GALOPPS input and master files, and 
displays graphical output (during or after run) of 
user-selected variables.</LI>
<LI> 5 selection methods: roulette wheel, stochastic remainder
sampling, tournament selection, stochastic universal sampling,
linear-ranking-then-SUS.</LI>
<LI> Random or superuniform initialization of "ordinary"
(non-permutation) binary or non-binary chromosomes; random
initialization of permutation-based chromosomes; or 
user-supplied initialization of arbitrary types of chromosomes.</LI>
<LI> Binary or non-binary alphabetic fields on value-based
chromosomes, including different user-definable field sizes.</LI>
<LI> 3 crossovers for value-based representations: 1-pt, 2-pt, and
uniform, all of which operate at field boundaries if a 
non-binary alphabet is used.</LI>
<LI> 4 crossovers for order-based reps: PMX, order-based, uniform
order-based, and cycle.</LI>
<LI> 4 mutations: fast bitwise, multiple-field, swap and random
sublist scramble.</LI>
<LI> Fitness scaling: linear scaling, Boltzmann scaling, sigma
truncation, window scaling, ranking.</LI>
<LI><B>Plus</B> a whole lot more....</LI>
</UL>
<P>
<P>
<A NAME="GAS"></A> <DT><B>GAS</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://starship.python.net/crew/gandalf/">starship.skyport.net/crew/gandalf</A></LI>
<LI>FTP site: 
<A HREF="ftp://ftp.coe.uga.edu/users/jae/ai/">ftp.coe.uga.edu/users/jae/ai</A></LI>
</UL>
<P>
<P>GAS means "Genetic Algorithms Stuff".
<P>GAS is freeware.
<P>Purpose of GAS is to explore and exploit artificial evolutions.
Primary implementation language of GAS is Python.  The GAS
software package is meant to be a Python framework for applying
genetic algorithms. It contains an example application where it
is tried to breed Python program strings.  This special problem
falls into the category of Genetic Programming (GP), and/or
Automatic Programming.  Nevertheless, GAS tries to be useful for
other applications of Genetic Algorithms as well.
<P>
<P>
<A NAME="GECO"></A> <DT><B>GECO</B><DD><P>
<UL>
<LI>FTP site: 
<A HREF="ftp://ftp.aic.nrl.navy.mil/pub/galist/src/">ftp://ftp.aic.nrl.navy.mil/pub/galist/src/</A></LI>
</UL>
<P>
<P>GECO (Genetic Evolution through Combination of Objects), an
extendible object-oriented tool-box for constructing genetic algorithms
(in Lisp).  It provides a set of extensible classes and methods
designed for generality. Some simple examples are also provided to
illustrate the intended use.
<P>
<P>
<A NAME="GPdata"></A> <DT><B>GPdata</B><DD><P>
<UL>
<LI>FTP site: 
<A HREF="ftp://ftp.cs.bham.ac.uk/pub/authors/W.B.Langdon/gp-code/">ftp.cs.bham.ac.uk/pub/authors/W.B.Langdon/gp-code/</A> </LI>
<LI>Documentation (GPdata-icga-95.ps): 
<A HREF="ftp://cs.ucl.ac.uk/genetic/papers/">cs.ucl.ac.uk/genetic/papers/</A></LI>
</UL>
<P>
<P>GPdata-3.0.tar.gz (C++) contains a version of Andy Singleton's 
GP-Quick version 2.1 which has been extensively altered to support:
<UL>
<LI>Indexed memory operation (cf. teller)</LI>
<LI>multi tree programs</LI>
<LI>Adfs</LI>
<LI>parameter changes without recompilation</LI>
<LI>populations partitioned into demes</LI>
<LI>(A version of) pareto fitness</LI>
</UL>

This ftp site also contains a small C++ program (ntrees.cc) to 
calculate the number of different there are of a given length and 
given function and terminal set.
<P>
<P>
<A NAME="Java GP - gpjpp"></A> <DT><B>gpjpp Genetic Programming in Java</B><DD><P>
<UL>
<LI>[Dead Link] Web site:
http://www.turbopower.com/~kimk/gpjpp.asp</LI>
<LI>Anyone who knows where to find gpjpp, please let me know.</LI>
</UL>
<P>gpjpp is a Java package I wrote for doing research in genetic
programming. It is a port of the gpc++ kernel written by Adam
Fraser and Thomas Weinbrenner. Included in the package are
four of Koza's standard examples: the artificial ant, the
hopping lawnmower, symbolic regression, and the boolean
multiplexer. Here is a partial list of its features:
<UL>
<LI>graphic output of expression trees</LI>
<LI>efficient diversity checking </LI>
<LI>Koza's greedy over-selection option for large populations</LI>
<LI>extensible GPRun class that encapsulates most details of a
genetic programming test</LI>
<LI>more robust and efficient streaming code, with automatic 
checkpoint and restart built into the GPRun class</LI>
<LI>an explicit complexity limit that can be set on each GP</LI>
<LI>additional configuration variables to allow more testing 
without recompilation</LI>
<LI>support for automatically defined functions (ADFs)</LI>
<LI>tournament and fitness proportionate selection</LI>
<LI>demetic grouping</LI>
<LI>optional steady state population</LI>
<LI>subtree crossover</LI>
<LI>swap and shrink mutation</LI>
</UL>
<P>
<P>
<A NAME="GP Kernel"></A> <DT><B>GP Kernel</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.emk.e-technik.tu-darmstadt.de/~thomasw/gp.html">www.emk.e-technik.tu-darmstadt.de/~thomasw/gp.html</A></LI>
</UL>
<P>The GP kernel is a C++ class library that can be used to apply
genetic programming techniques to all kinds of problems. The
library defines a class hierarchy. An integral component is the
ability to produce automatically defined functions as found in
Koza's "Genetic Programming II". Technical documentation
(postscript format) is included. There is also a short
introduction into genetic programming.
<P>Functionality includes; Automatically defined functions (ADFs),
tournament and fitness proportionate selection, demetic grouping,
optional steady state genetic programming kernel, subtree crossover,
swap and shrink mutation, a way of changing every parameter of the
system without recompilation, capacity for multiple populations,
loading and saving of populations and genetic programs, standard
random number generator, internal parameter checks.
<P>
<P>
<A NAME="jaga"></A> <DT><B>jaga</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://cs.felk.cvut.cz/~koutnij/studium/jaga/jaga.html">cs.felk.cvut.cz/~koutnij/studium/jaga/jaga.html</A></LI>
</UL>
<P>Simple genetic algorithm package written in Java.
<P>
<P>
<A NAME="lil-gp"></A> <DT><B>lil-gp</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://GARAGe.cps.msu.edu/software/software-index.html#lilgp">GARAGe.cps.msu.edu/software/software-index.html#lilgp</A></LI>
<LI>FTP site: 
<A HREF="ftp://garage.cps.msu.edu/pub/GA/lilgp/">garage.cps.msu.edu/pub/GA/lilgp/</A></LI>
</UL>
<P>
<DT><B>patched lil-gp *</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.cs.umd.edu/users/seanl/gp/">www.cs.umd.edu/users/seanl/gp/</A></LI>
</UL>
<P>lil-gp is a generic 'C' genetic programming tool. It was written
with a number of goals in mind: speed, ease of use and support for a
number of options including:
<UL>
<LI> Generic 'C' program that runs on UNIX workstations</LI>
<LI> Support for multiple population experiments, using 
arbitrary and user settable topologies for exchange, for 
a single processor (i.e., you can do multiple population gp 
experiments on your PC).</LI>
<LI> lil-gp manipulates trees of function pointers which are 
allocated in single, large memory blocks for speed and to 
avoid swapping.</LI>
</UL>

* The patched lil-gp kernel is strongly-typed, with modifications on 
multithreading, coevolution, and other tweaks and features.
<P>
<P>
<A NAME="Lithos"></A> <DT><B>Lithos</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.esatclear.ie/~rwallace/lithos.html">www.esatclear.ie/~rwallace/lithos.html</A></LI>
</UL>
<P>Lithos is a stack based evolutionary computation system. Unlike most EC
systems, its representation language is computationally complete, while
also being faster and more compact than the S-expressions used in
genetic programming. The version presented here applies the system to
the game of Go, but can be changed to other problems by simply plugging
in a different evaluation function. ANSI C source code is provided.
<P>
<P>
<P>
<A NAME="PGAPack"></A> <DT><B>PGAPack</B><DD><P>Parallel Genetic Algorithm Library
<UL>
<LI>Web site: 
<A HREF="http://www.mcs.anl.gov/~levine/PGAPACK/">www.mcs.anl.gov/~levine/PGAPACK/</A></LI>
<LI>FTP site: 
<A HREF="ftp://ftp.mcs.anl.gov/pub/pgapack/">ftp.mcs.anl.gov/pub/pgapack/</A></LI>
</UL>
<P>PGAPack is a general-purpose, data-structure-neutral, parallel
genetic algorithm library. It is intended to provide most capabilities
desired in a genetic algorithm library, in an integrated, seamless,
and portable manner. Key features are in PGAPack V1.0 include:
<UL>
<LI>Callable from Fortran or C. </LI>
<LI>Runs on uniprocessors, parallel computers, and workstation networks.</LI>
<LI>Binary-, integer-, real-, and character-valued native data types. </LI>
<LI>Full extensibility to support custom operators and new data types. </LI>
<LI>Easy-to-use interface for novice and application users. </LI>
<LI>Multiple levels of access for expert users. </LI>
<LI>Parameterized population replacement. </LI>
<LI>Multiple crossover, mutation, and selection operators. </LI>
<LI>Easy integration of hill-climbing heuristics. </LI>
<LI>Extensive debugging facilities. </LI>
<LI>Large set of example problems. </LI>
<LI>Detailed users guide.</LI>
</UL>
<P>
<P>
<P>
<A NAME="PIPE"></A> <DT><B>PIPE</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.idsia.ch/~rafal/research.html">www.idsia.ch/~rafal/research.html</A></LI>
<LI>FTP site: 
<A HREF="ftp://ftp.idsia.ch/pub/rafal/">ftp.idsia.ch/pub/rafal</A></LI>
</UL>
<P>Probabilistic Incremental Program Evolution (PIPE) is a novel
technique for automatic program synthesis. The software is written in C. It
<UL>
<LI>is easy to install (comes with an automatic installation tool).</LI>
<LI>is easy to use: setting up PIPE_V1.0 for different problems
requires a minimal amount of programming. User-written, application-
independent program parts can easily be reused.</LI>
<LI>is efficient: PIPE_V1.0 has been tuned to speed up performance.</LI>
<LI>is portable: comes with source code (optimized for SunOS 5.5.1).</LI>
<LI>is extensively documented(!) and contains three example applications.</LI>
<LI>supports statistical evaluations: it facilitates running  multiple
experiments and collecting results in output files.</LI>
<LI>includes testing tool for testing generalization of evolved programs.</LI>
<LI>supports floating point and integer arithmetic.</LI>
<LI>has extensive output features.</LI>
<LI>For lil-gp users: Problems  set up for lil-gp 1.0 can be easily ported to PIPE_v1.0.
The  testing tool can also be used to process programs evolved by
lil-gp 1.0.</LI>
</UL>
<P>
<P>
<P>
<A NAME="Sugal"></A> <DT><B>Sugal</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.trajan-software.demon.co.uk/sugal.htm">www.trajan-software.demon.co.uk/sugal.htm</A></LI>
</UL>
<P>Sugal [soo-gall] is the SUnderland Genetic ALgorithm system. The aim of
Sugal is to support research and implementation in Genetic Algorithms on a
common software platform. As such, Sugal supports a large number of variants
of Genetic Algorithms, and has extensive features to support customization
and extension.
<P>
<P>
<P>
</DL>
<P>
<P>
<H2><A NAME="ss4.2">4.2 EC software kits/applications</A>
    </H2>

<P>
<P>These are various applications, software kits, etc. meant for research
in the field of evolutionary computing. Their ease of use will vary, as they
were designed to meet some particular research interest more than as
an easy to use commercial package.
<P>
<DL>
<P>
<P>
<A NAME="ADATE"></A> <DT><B>ADATE</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www-ia.hiof.no/~rolando/adate_intro.html">www-ia.hiof.no/~rolando/adate_intro.html</A></LI>
</UL>
<P>ADATE (Automatic Design of Algorithms Through Evolution) is a system 
for automatic programming i.e., inductive inference of algorithms, 
which may be the best way to develop artificial and general 
intelligence.
<P>
<P>The ADATE system can automatically generate non-trivial and novel
algorithms. Algorithms are generated through large scale combinatorial
search that employs sophisticated program transformations and
heuristics. The ADATE system is particularly good at synthesizing
symbolic, functional programs and has several unique qualities.
<P>
<P>
<P>
<A NAME="esep-xesep"></A> <DT><B>esep &amp; xesep</B><DD><P>
<UL>
<LI>Web site(esep): 
<A HREF="http://www.iit.edu/~linjinl/esep.html">www.iit.edu/~linjinl/esep.html</A></LI>
<LI>Web site(xesep): 
<A HREF="http://www.iit.edu/~linjinl/xesep.html">www.iit.edu/~linjinl/xesep.html</A></LI>
</UL>
<P>
<P>This is a new scheduler, called Evolution Scheduler, based on
Genetic Algorithms and Evolutionary Programming. It lives with
original Linux priority scheduler.This means you don't have to
reboot to change the scheduling policy. You may simply use the
manager program esep to switch between them at any time, and
esep itself is an all-in-one for scheduling status, commands,
and administration. We didn't intend to remove the original
priority scheduler; instead, at least, esep provides you with
another choice to use a more intelligent scheduler, which
carries out natural competition in an easy and effective way.
<P>
<P>Xesep is a graphical user interface to the esep (Evolution
Scheduling and Evolving Processes). It's intended to show users
how to start, play, and feel the Evolution Scheduling and
Evolving Processes, including sub-programs to display system
status, evolving process status, queue status, and evolution
scheduling status periodically in as small as one mini-second.
<P>
<P>
<A NAME="Corewars"></A> <DT><B>Corewars</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://corewars.sourceforge.net/">corewars.sourceforge.net/</A></LI>
<LI>SourceForge site: 
<A HREF="http://sourceforge.net/project/corewars/">sourceforge.net/project/corewars/</A></LI>
</UL>
<P>Corewars is a game which simulates a virtual machine with a number of
programs. Each program tries to crash the others. The program that 
lasts the longest time wins. A number of sample programs are provided
and new programs can be written by the player. Screenshots are 
available at the Corewars homepage.
<P>
<P>
<P>
<A NAME="Corewar VM"></A> <DT><B>Corewar VM</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.jedi.claranet.fr/">www.jedi.claranet.fr/</A></LI>
</UL>
<P>
<P>This is a virtual machine written in Java (so it is a virtual machine
for another virtual machine !) for a Corewar game.
<P>
<P>
<A NAME="FSM-Evolver"></A> <DT><B>FSM-Evolver</B><DD><P>
<UL>
<LI>Web site (???): 
<A HREF="http://pages.prodigy.net/czarneckid/">pages.prodigy.net/czarneckid</A></LI>
</UL>
<P>
<P>A Java (jdk-v1.0.2+) code library that is used to evolve finite
state machines. The problem included in the package is the
Artificial Ant problem. You should be able to compile the .java
files and then run: java ArtificialAnt.
<P>
<P>
<A NAME="GPsys"></A> <DT><B>GPsys</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.cs.ucl.ac.uk/staff/A.Qureshi/gpsys.html">www.cs.ucl.ac.uk/staff/A.Qureshi/gpsys.html</A></LI>
</UL>
<P>
<P>GPsys (pronounced gipsys) is a Java (requires Java 1.1 or
later) based Genetic Programming system developed by Adil
Qureshi.  The software includes documentation, source and
executables.
<P>
<P>Feature Summary:
<UL>
<LI>Steady State engine</LI>
<LI>ADF support</LI>
<LI>Strongly Typed
<OL>
<LI>supports generic functions and terminals</LI>
<LI>has many built-in primitives</LI>
<LI>includes indexed memory</LI>
</OL>
</LI>
<LI>Save/Load feature
<OL>
<LI>can save/load current generation to/from a file</LI>
<LI>data stored in GZIP compression format to minimise disk 
requirements</LI>
<LI>uses serialisable objects for efficiency</LI>
</OL>
</LI>
<LI>Fully Documented</LI>
<LI>Example Problems
<OL>
<LI>Lawnmower (including GUI viewer)</LI>
<LI>Symbolic Regression</LI>
</OL>
</LI>
<LI>Totally Parameterised</LI>
<LI>Fully Object Oriented and Extensible</LI>
<LI>High Performance</LI>
<LI>Memory Efficient</LI>
</UL>
<P>
<P>
<A NAME="Grany-3"></A> <DT><B>Grany-3</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.mandrakesoft.com/~gc/html/personal-homepage/html/grany.html">www.mandrakesoft.com/~gc/html/personal-homepage/html/grany.html</A></LI>
</UL>
<P>Grany-3 is a full-featured cellular automaton simulator, made in C++
with Gtk--, flex++/bison++, doxygen and gettext, useful to granular
media physicists. 
<P>
<P>
<P>
<A NAME="JGProg"></A> <DT><B>JGProg</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.linuxstart.com/~groovyjava/JGProg/">www.linuxstart.com/~groovyjava/JGProg/</A></LI>
</UL>
<P>Genetic Programming (JGProg) is an open-source Java implementation of
a strongly-typed Genetic Programming experimentation platform. Two 
example "worlds" are provided, in which a population evolves and 
solves the problem.
<P>
<P>
</DL>
<P>
<P>
<P>
<HR>
<A HREF="AI-Alife-HOWTO-5.html"><IMG SRC="../img/next.gif" ALT="Next"></A>
<A HREF="AI-Alife-HOWTO-3.html"><IMG SRC="../img/prev.gif" ALT="Previous"></A>
<A HREF="AI-Alife-HOWTO.html#toc4"><IMG SRC="../img/toc.gif" ALT="Contents"></A>
<SCRIPT>EndPage();</SCRIPT>  </BODY>
</HTML>
