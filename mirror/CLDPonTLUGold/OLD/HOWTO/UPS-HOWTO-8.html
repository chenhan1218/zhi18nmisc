<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>The UPS Howto: Info on selected UPSs</TITLE>
 <LINK HREF="UPS-HOWTO-9.html" REL=next>
 <LINK HREF="UPS-HOWTO-7.html" REL=previous>
 <LINK HREF="UPS-HOWTO.html#toc8" REL=contents>
<SCRIPT src="../menu.js"> function BeginPage() {} function EndPage() {} </SCRIPT> </HEAD> <BODY bgcolor=#EEEEFF MARGINHEIGHT=0 MARGINWIDTH=0> <SCRIPT>BeginPage(1, 8, 1);</SCRIPT>
<A HREF="UPS-HOWTO-9.html"><IMG SRC="../img/next.gif" ALT="Next"></A>
<A HREF="UPS-HOWTO-7.html"><IMG SRC="../img/prev.gif" ALT="Previous"></A>
<A HREF="UPS-HOWTO.html#toc8"><IMG SRC="../img/toc.gif" ALT="Contents"></A>
<HR>
<H2><A NAME="ups-specific"></A> <A NAME="s8">8. Info on selected UPSs</A></H2>

<P>
<P>This section contains UPS specific information.  What I'd like is to
have the UPS control port information (what each pin does and needs to
have done), information on the manufacturer supplied cable (what it
connects where), and a hacked version of powerd.c which works with the
UPS.  What I currently have is fairly complete descriptions of setting
up each UPS.  I'd try to distill out the relevant information, but
since I can't test each UPS, it's hard to decide exactly what's
relevant.  Furthermore, each UPS seems to have some additional quirks
that are nicely described by the authors of each section.  So for now
I'm leaving everything in.  Makes for a hefty Howto.
<P><B>Please send me your experiences for inclusion here.</B>
<P>
<H2><A NAME="ss8.1">8.1 General Experiences.</A>
</H2>

<P>I've been saving peoples comments, but haven't gotten permission yet
to include them here.  Here's a general summary of what I've heard
from people.
<P>APC: 
Won't release info on their smart mode without your signature on
a non-disclosure agreement.  Thus, people are forced to run their
smart UPSs in the dumb mode as outlined above.  Various
people have had varying amounts of success reverse engineering 
<P>Best:
Helpful and friendly.  Supply source code and documentation both
for dumb modes and smart modes.
<P>TrippLite:
One person reported that TrippLite won't release info either.
<P>Upsonic:
One person reported that Upsonic has discussed technical details
over the phone, answered questions via fax and are generally helpful.
<P>
<P>
<H2><A NAME="ss8.2">8.2 Advice 1200 A</A>
</H2>

<P>UPS from Advice Electronics, Tel Aviv Israel (they stick their own
name on the things).
<P>I don't recommend them.  Our experiences with them have been very bad.
We've twice had a 17" monitor fry when the power failed.  We've had
computers spontaneously reboot when the power failed.
<P>None the less, for completeness, here's he UPS Control Port's pin
specifications.
<P>
<UL>
<LI>2 - Power Fail.</LI>
<LI>5 - Battery Low.</LI>
<LI>6 - Shut Down UPS.</LI>
<LI>4 - Common ground for pin 2, 5, 6.</LI>
</UL>
<P>They also gave me the following picture which didn't help me, but
may help you if you want to build a cable yourself:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
         2 ----------+
                     |
                     \
                      \|
                       |--------------
                      /|
                    \/      &lt;--- The "\/" here indicates the type of
                    |            this transister.  I forget what
                    |            denotes what, but this one points
                 +-----+         away from the center line.
                /  /  /


         5 ----------+
                     |
                     \
                      \|
                       |--------------
                      /|
                    \/
                    |
                    |
                 +-----+
                /  /  /


                       +-------------
                       |
                       /
              10K    |/
         6 --\/\/\/--|
                     |\
                       \/
                       |
                       |
                    +-----+
                   /  /  /


         4 ----------+
                     |
                     |
                  +-----+
                 /  /  /
</PRE>
</CODE></BLOCKQUOTE>
<P>Cable supplied
<P>They first gave me a cable that was part of a DOS UPS control
package called RUPS.  I used this for testing.  When I was
satisfied, they gave me a cable they use for Netware servers
connected to UPSs.  It functioned identically.  Here are the
details:
<P>
<UL>
<LI>DTR - Powers cable (make powerd.c keep it high).</LI>
<LI>CTS - Power out (stays high and goes low when power goes out).</LI>
<LI>DSR - Battery low (stays high.  Goes low when battery does).</LI>
<LI>RTS - Turns off UPS (keep it low.  Set it high to turn off UPS).</LI>
</UL>
<P>(The powerd.c that comes with SysVinit set or left RTS high,
causing the UPS to shut off immediately when powerd was started
up!)
<P>
<P>
<H2><A NAME="ciro"></A> <A NAME="ss8.3">8.3 Trust Energy Protector 400/650</A>
</H2>

<P>This section is good for more than just the Trust Energy Protector.
It illustrates how to work with the new features of <CODE>init</CODE>.
<P>How to use a Trust Energy Protector 400/650 under Linux
<P>by 
<A HREF="mailto:ciro@stud.unipg.it">Ciro Cattuto</A><P>Version 1.0 - 31 March 1997
<P>
<P>
<H3>The computer to UPS connection</H3>

<P>The Trust Energy Protector 400/650 is equipped with a remote signal port.
Using a properly designed cable, it is possible to connect the UPS port
to the serial port of a computer, thus making it aware of power failure events.
<P>
<P>
<H3>The UPS signal port</H3>

<P>These are the pin assignments for the DB-9 signal port of the Trust
Energy Protector 400/650, as described in the user's manual:
<P>
<P>
<DL>
<DT><B>pin 2</B><DD><P>The relay will close when input power fails.
<P>
<DT><B>pin 4</B><DD><P>Common for pins 2 and 5.
<P>
<DT><B>pin 5</B><DD><P>The relay will close when the battery inside
the Trust Energy Protector 400/650 has less
than 1.5 minutes of backup time left.
<P>
<DT><B>pin 6</B><DD><P>The user may send a high level signal (+5V - +12V)
for over 1ms to turn off the Trust Energy Protector
400/650. However this option can only be activated
when the input power fails.
<P>
<DT><B>pin 7</B><DD><P>Common for pin 6.
</DL>
<P>
<H3>The Cable</H3>

<P>This is the cable I used to connect the UPS
to the serial port of my computer:
<P>
<BLOCKQUOTE><CODE>
<PRE>
computer side (DB-25)               UPS side (DB-9)
===================================================

 6 DSR --+             [R] = 10 kilo-Ohm resistor
         |
20 DTR --+----+ 
         |    |
        [R]  [R]                           +--- 7
         |    |                            |
 8 DCD --+----|-----------        ---------|--- 2
              |                            |
 7 GND -------|-----------        ---------+--- 4
              |             ....   
 5 CTS -------+-----------        ------------- 5
                                           
 2 TX  -------------------        ------------- 6

===================================================
</PRE>
</CODE></BLOCKQUOTE>
<P>In the case of a DB-9 serial port, the pins 6,20,8,7,5,2 are mapped to
pins 6,4,1,5,8,3.
<P>
<P>
<H3>How the cable works</H3>

<P>The computer raises <CODE>DTR</CODE> and checks whether <CODE>DSR</CODE> is high, to
ensure that the cable is connected to the computer. While the power is
good, <CODE>DCD</CODE> and <CODE>CTS</CODE> are both high (because of the pull-up
resistors).
<P>When the power fails, the relay between pins 2 and 4 of the
UPS port closes, and <CODE>DCD</CODE> becomes low, signalling the failure
condition. 
<P>Similarly, when the UPS batteries are getting low,
the relay between pins 5 and 4 closes, thus lowering <CODE>CTS</CODE>.
<P>During a power failure the computer is able to turn off the UPS
by raising <CODE>TX</CODE> for over 1ms. This can be easily accomplished
sending a <CODE>0xFF</CODE> byte to the serial port, at a low baud rate.
<P>
<P>
<H3>The powerd daemon</H3>

<P>To make use of the information available at the serial port
we need to run a program which monitors the port,
decodes the signals and sends the appropriate messages
to the operating system, i.e. to the <CODE>init</CODE> process.
The <CODE>init</CODE> process can execute scripts and programs
designed to handle (gracefully!) the power failure event.
<P>
<P>
<H3>Compiling powerd</H3>

<P>In Appendix A you'll find the source code of <CODE>powerd</CODE>,
the daemon I use to monitor the Trust Energy Protector 400/650.
To compile it you will need the source code of the sysvinit
package (I used the code from sysvinit-2.60). Just overwrite
the original <CODE>powerd.c</CODE> and compile it.
<P>
<P>
<H3>How powerd works</H3>

<P>As soon as <CODE>powerd</CODE> starts it opens the serial device connected
to the UPS and forces <CODE>DTR</CODE> high. It then forks a daemon and exits,
leaving the daemon running. The <CODE>powerd</CODE> daemon can be in one of
three states: 
<P>
<DL>
<DT><B>State 0 - POWER IS GOOD</B><DD><P>In this state <CODE>powerd</CODE> reads the serial port every
<CODE>T0_SLEEP</CODE> seconds (see the <CODE>#define</CODE> lines at the beginning of
the code).  If <CODE>DCD</CODE> drops, <CODE>powerd</CODE> switches to state 1. If
<CODE>CTS</CODE> drops <CODE>powerd</CODE> switches to state 2 (this shouldn't
happen without <CODE>DCD</CODE> dropping before, but I decided to stay on
the safe side).
<P>
<DT><B>State 1 - POWER FAILURE</B><DD><P>A power failure was detected. <CODE>DCD</CODE> is low and <CODE>powerd</CODE> reads
the UPS port every <CODE>T1_SLEEP</CODE> seconds. If <CODE>DCD</CODE> becomes high,
it switches to state 0. If <CODE>CTS</CODE> drops, it switches to state 2.
<P>
<DT><B>State 2 - POWER CRITICAL</B><DD><P>UPS batteries are low. The <CODE>powerd</CODE> daemon will remain in this
state.
</DL>
<P>Each time <CODE>powerd</CODE> changes state, it notifies the init process,
so that the appropriate action can be taken. These events
are logged using the system logging facility.
<P>If <CODE>DSR</CODE> is low there must be something wrong with the cable.
Powerd keeps monitoring the <CODE>DSR</CODE> line, and every two minutes
sends a warning message to the system logging facility.
<P>
<P>
<H3>Running powerd</H3>

<P>The <CODE>powerd</CODE> daemon should be launched from the system
initialization scripts, during system startup. I added the following
lines to my <CODE>/etc/rc.d/rc.local</CODE> script:
<P>
<BLOCKQUOTE><CODE>
<PRE>
# Add support for the UPS
echo "Starting powerd daemon..."
rm -f /etc/turnUPSoff
stty -crtscts speed 75 &lt; /dev/cua3 > /dev/null
if [ -x /usr/sbin/powerd ]; then
        /usr/sbin/powerd /dev/cua3
fi
</PRE>
</CODE></BLOCKQUOTE>
<P>First we remove (if present) the file <CODE>/etc/turnUPSoff</CODE>.  This
file is used by the system shutdown script (<CODE>/etc/rc.d/rc.0</CODE>,
in my case) to decide whether we want to turn the UPS off.  See later
in this document for more information.
<P>Then we disable hardware flow control on the serial device
connected to the UPS, and set its baud rate to 75.
Now we're confident that the TX signal will stay high
for a time long enough to turn the UPS off, if we send
a character to the serial port (again, see later).
<P>Finally we launch the <CODE>powerd</CODE> daemon, specifying the serial port
to monitor. Notice that we're not going to read characters from the
serial device, so don't worry if you have interrupt conflicts -
they'll do no harm.
<P>
<P>
<H3>The inittab file and the shutdown scripts</H3>

<P>The <CODE>powerd</CODE> process is now running, and it will send signals to
<CODE>init</CODE> whenever a power failure occurs. Now we have to configure the
system so that it can react in a useful way when those signals are
received.
<P>
<P>
<H3>Modifying inittab</H3>

<P>Add the following lines near the beginning of your /etc/inittab file:
<P>
<BLOCKQUOTE><CODE>
<PRE>
# What to do when power fails (delayed shutdown).
pf::powerfail:/etc/powerfail_script

# If power is back before shutdown, cancel the running shutdown.
pg::powerokwait:/etc/powerokay_script

# If UPS batteries are getting low, do an immediate shutdown.
pc::powerfailnow:/etc/powerfailnow_script
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>
<H3>The scripts</H3>

<P>The scripts <CODE>powerfail_script</CODE>, <CODE>powerokay_script</CODE> and
<CODE>powerfailnow_script</CODE> are executed when <CODE>init</CODE> receives the
corresponding signal. They have the responsibility of shutting down
the system in a clean way or cancelling a running shutdown in case
power comes back.  These are the scripts I'm currently using:
<P><CODE>/etc/powerfail_script</CODE>:
<P>
<BLOCKQUOTE><CODE>
<PRE>
#!/bin/sh
/bin/sync
/usr/bin/sleep 10m
kill -9 `ps auxw | grep "shutdown" | grep -v grep | awk '{print $2}'`
> /etc/turnUPSoff
/sbin/shutdown -t30 -h +3 "POWER FAILURE"
</PRE>
</CODE></BLOCKQUOTE>
<P>My Trust Energy Protector 400 powers only the computer, so I have
quite a long backup time. Since power failures only last for some
minutes in my zone, the system responds to a blackout in the following
way: it waits for 10 minutes (usually the power comes back before) and
then halts the system, allowing the users to close their applications
and leave the machine. Before issuing the shutdown command, I make
sure that there are no running shutdowns. I also create the file
<CODE>/etc/turnUPSoff</CODE>, so that the system will turn off the UPS.
<P><CODE>/etc/powerokay_script</CODE>:
<P>
<BLOCKQUOTE><CODE>
<PRE>
#!/bin/sh
kill `ps auxw | grep "powerfail_script" | grep -v grep | awk '{print $2}'`
kill -9 `ps auxw | grep "shutdown" | grep -v grep | awk '{print $2}'`
rm -f /etc/turnUPSoff
</PRE>
</CODE></BLOCKQUOTE>
<P>If power comes back, we kills the running powerfail_script
and any running shutdown. We also remove <CODE>/etc/turnUPSoff</CODE>.
<P><CODE>/etc/powerfailnow_script</CODE>:
<P>
<BLOCKQUOTE><CODE>
<PRE>
#!/bin/sh
kill -9 `ps auxw | grep "shutdown" | grep -v grep | awk '{print $2}'`
> /etc/turnUPSoff
/sbin/shutdown -h now "UPS batteries low. IMMEDIATE SHUTDOWN."
</PRE>
</CODE></BLOCKQUOTE>
<P>If batteries are getting low, we make sure that there are no running
shutdowns, create the <CODE>/etc/turnUPSoff</CODE> file and then shutdown
the system immediately.
<P>
<P>
<H3>The system shutdown script</H3>

<P>When system shutdown is complete, we can turn off the UPS
raising the <CODE>TX</CODE> signal of the serial port for over 1ms.
The serial device is already properly configured (see the
<CODE>stty</CODE> command in the <CODE>rc.local</CODE> script). If the file
<CODE>/etc/turnUPSoff</CODE> is present, we send the byte <CODE>0xff</CODE>
(all '1' bits) to the serial port.
<P>To do this, add the following lines near the bottom of your
system shutdown script (<CODE>/etc/rc.d/rc.0</CODE>, in my case).
The proper place depends on the way your system is configured,
but it should be okay to insert the lines before the echo command
which prints the "System is halted" message.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# Is this a powerfail situation?
if [ -f /etc/turnUPSoff ]; then
  echo "Turning off UPS. Bye."
  sleep 5
  echo -e "\377" > /dev/cua3
  exit 1
fi
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>
<H3>General remarks</H3>

<P>This document contains things I learned while trying to configure
*my* Linux system to use the Trust Energy Protector 400.
Some informations (the path of the system inizialization scripts,
for example) may be specific to my system, and you probably
will need some customization. However, I hope this document
will be a useful trace for those trying to use a Trust Energy
Protector 400/650 under Linux. If you experience difficulties,
look for general information in the rest of this UPS-Howto.
Good luck!
<P>
<P>
<H3>Feedback</H3>

<P>I would greatly appreciate receiving feedback about this document,
so that I can polish it and correct possible mistakes (I know the
English is not very good, but I'm Italian after all!).
Direct any comments/suggestions/critics to the following e-mail address:
<P>
<A HREF="ciro@stud.unipg.it">ciro@stud.unipg.it</A><P>If you have problems using Trust Energy Protector 400/650
under Linux, feel free to contact me.  I'll try to help you.
<P>
<P>
<H3>Legal Issues</H3>

<P>I have no relation at all with Trust Networking Products.
<P>The information contained in this document comes "as is".
Use it at your own risk. I can't be held responsible for
any damage or loss of data resulting from the use of the code
and information given here.
<P>
<P>Ciro Cattuto
<P>
<P>-----
<H3>Appendix A  -  Source code for the powerd daemon</H3>

<P><CODE>powerd.c</CODE>:
<P>
<BLOCKQUOTE><CODE>
<PRE>
/*
 * powerd       Catch power failure signals from
 *              a Trust Energy Protector 400/650
 *              and notify init
 *
 * Usage:       powerd /dev/cua3 (or any other serial device)
 *
 * Author:      Ciro Cattuto &lt;ciro@stud.unipg.it>
 * 
 * Version 1.0 - 31 March 1997
 *
 * This code is heavily based on the original powerd.c code
 * by Miquel van Smoorenburg &lt;miquels@drinkel.ow.org>.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version
 * 2 of the License, or (at your option) any later version.
 * 
 */

/* state 0 - power is good */
#define T0_SLEEP        10      /* interval between port reads, in seconds */
#define T0_DCD          3       /* number of seconds DCD has to be high
                                   to cause an action                      */
#define T0_CTS          3       /* number of seconds CTS has to be high
                                   to cause an action                      */
/* state 1 - power is failing */
#define T1_SLEEP        2       /* interval between ports reads            */
#define T1_DCD          3       /* same as T0_DCD                          */
#define T1_CTS          3       /* same as T0_CTS                          */

#define DSR_SLEEP       2
#define DSR_TRIES       60

/* Use the new way of communicating with init. */
#define NEWINIT

#include &lt;sys/types.h>
#include &lt;sys/stat.h>
#include &lt;sys/ioctl.h>
#include &lt;fcntl.h>
#include &lt;errno.h>
#include &lt;stdlib.h>
#include &lt;unistd.h>
#include &lt;stdio.h>
#include &lt;signal.h>
#include &lt;syslog.h>
#include &lt;string.h>
#include "paths.h"
#ifdef NEWINIT
#include "initreq.h"
#endif

#ifndef SIGPWR
#  define SIGPWR SIGUSR1
#endif

#ifdef NEWINIT
void alrm_handler()
{
}
#endif

/* Tell init that the power has gone (1), is back (0),
   or the UPS batteries are low (2). */
void powerfail(int event)
{
  int fd;
#ifdef NEWINIT
  struct init_request req;

  /* Fill out the request struct. */
  memset(&amp;req, 0, sizeof(req));
  req.magic = INIT_MAGIC;
  switch (event)
        {
        case 0:
                req.cmd = INIT_CMD_POWEROK;
                break;
        case 1:
                req.cmd = INIT_CMD_POWERFAIL;
                break;
        case 2:
        default:
                req.cmd = INIT_CMD_POWERFAILNOW;
        } 

  /* Open the fifo (with timeout) */
  signal(SIGALRM, alrm_handler);
  alarm(3);
  if ((fd = open(INIT_FIFO, O_WRONLY)) >= 0
                &amp;&amp; write(fd, &amp;req, sizeof(req)) == sizeof(req)) {
        close(fd);
        return;
  }
  /* Fall through to the old method.. */
#endif

  /* Create an info file for init. */
  unlink(PWRSTAT);
  if ((fd = open(PWRSTAT, O_CREAT|O_WRONLY, 0644)) >= 0) {
  switch (event)
        { 
        case 0:
                write(fd, "OK\n", 3);
                break;

        case 1:
                write(fd, "FAIL\n", 5);
                break;

        case 2:
        default:
                write(fd, "LOW\n", 4);
                break;
        }
  close(fd);
  }

  kill(1, SIGPWR);
}

/* Main program. */
int main(int argc, char *argv[])
{
  int fd;
  int dtr_bit = TIOCM_DTR;
  int flags;
  int DCD, CTS;
  int status = -1;
  int DCD_count = 0, CTS_count = 0;
  int tries;

  if (argc &lt; 2) {
        fprintf(stderr, "Usage: powerd &lt;device>\n");
        exit(1);
  }

  /* Start syslog. */
  openlog("powerd", LOG_CONS|LOG_PERROR, LOG_DAEMON);

  /* Open monitor device. */
  if ((fd = open(argv[1], O_RDWR | O_NDELAY)) &lt; 0) {
        syslog(LOG_ERR, "%s: %s", argv[1], sys_errlist[errno]);
        closelog();
        exit(1);
  }

  /* Line is opened, so DTR is high. Force it anyway to be sure. */
  ioctl(fd, TIOCMBIS, &amp;dtr_bit);

  /* Daemonize. */
  switch(fork()) {
        case 0: /* Child */
                closelog();
                setsid();
                break;
        case -1: /* Error */
                syslog(LOG_ERR, "can't fork.");
                closelog();
                exit(1);
        default: /* Parent */
                closelog();
                exit(0);
  }

  /* Restart syslog. */
  openlog("powerd", LOG_CONS, LOG_DAEMON);

  /* Now sample the DCD line. */
  while(1) {
        /* Get the status. */
        ioctl(fd, TIOCMGET, &amp;flags);

        /* Check the connection: DSR should be high. */
        tries = 0;
        while((flags &amp; TIOCM_DSR) == 0) {
                /* Keep on trying, and warn every two minutes. */
                if ((tries % DSR_TRIES) == 0)
                    syslog(LOG_ALERT, "UPS connection error");
                sleep(DSR_SLEEP);
                tries++;
                ioctl(fd, TIOCMGET, &amp;flags);
        }
        if (tries > 0)
                syslog(LOG_ALERT, "UPS connection OK");

        /* Calculate present status. */
        DCD = flags &amp; TIOCM_CAR;
        CTS = flags &amp; TIOCM_CTS;

        if (status == -1)
                {
                status = (DCD != 0) ? 0 : 1;
                if (DCD == 0)
                        {
                        syslog(LOG_ALERT, "Power Failure. UPS active.");
                        powerfail(1);
                        }
                }

        switch (status)
                {
                case 0:
                        if ((DCD != 0) &amp;&amp; (CTS != 0))
                                {
                                DCD_count = 0;
                                CTS_count = 0;
                                sleep(T0_SLEEP);
                                continue;
                                }
                        if (DCD == 0)
                                DCD_count++;
                        if (CTS == 0)
                                CTS_count++;
                        if ((DCD_count &lt; T0_DCD) &amp;&amp; (CTS_count &lt; T0_CTS))
                                {
                                sleep(1);
                                continue;
                                }
                        if (CTS_count == T0_CTS)
                                {
                                status = 2;
                                syslog(LOG_ALERT, "UPS batteries low!");
                                break;
                                }
                        status = 1;
                        DCD_count = 0;
                        syslog(LOG_ALERT, "Power Failure. UPS active."); 
                        break;

                case 1:
                        if ((DCD == 0) &amp;&amp; (CTS != 0))
                                {
                                DCD_count = 0;
                                CTS_count = 0;
                                sleep(T1_SLEEP);
                                continue;
                                }
                        if (DCD != 0)
                                DCD_count++;
                        if (CTS == 0)
                                CTS_count++;
                        if ((DCD_count &lt; T1_DCD) &amp;&amp; (CTS_count &lt; T1_CTS))
                                {
                                sleep(1);
                                continue;
                                }
                        if (CTS_count == T1_CTS)
                                {
                                status = 2;
                                syslog(LOG_ALERT, "UPS batteries low!");
                                break;
                                }
                        status = 0;
                        DCD_count = 0;
                        CTS_count = 0;                  
                        syslog(LOG_ALERT, "Power okay.");
                        break;

                case 2:
                        sleep(1);
                        continue;

                default:
                        break;
                }

        powerfail(status);
  }
  /* Never happens */
  return(0);
}
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>
<H2><A NAME="ss8.4">8.4 Trust UPS 400-A</A>
</H2>

<P>I received a submission about the Trust UPS 400-A.  I don't know if
it's the same as the Trust Energy Protector 400, so I'm including the
submission.
<P>
<BLOCKQUOTE><CODE>
<PRE>
From: "Marcel Ammerlaan" &lt;marcel@ch.twi.tudelft.nl>
To: hjstein@math.huji.ac.il
Subject: UPS addition
Date: Wed, 16 Jul 1997 01:17:11 +100

Hello Harvey,

I've got an addition to your UPS Howto. I've got a
"Trust UPS 400-A" which isn't listed. This product doesn't seem
to be manufactured anymore by it's producer (www.trust.box.nl).
But that doesn't mean it's not available anymore, I've got mine
really cheap just a month ago. Also this company just relabels
products so maybe there are others that have got the same UPS.

I have included a picture of the UPS in case anybody got such a beast
under another label.

The cable was easily constructed based on the original powerd cable
and the documentation from trust.
It clearly describes which pins of the D-shell connector of the UPS
carry which signal.

It extends the original design with 2 extra functions:
1) Battery low indication
2) Power down UPS

The cable I created looks like (see the other attachement).

This cable has been tested with powergend by Tom Webster and did work
completely (although your milage may vary).

Type:               "pleur"
Cable Power:        {TIOCM_DTR,0}
Inverter Kill:      {TIOCM_RTS,1}
Inverter Kill Time: 5
Power Check:        {TIOCM_CTS,0}
Battery Check:      {TIOCM_CAR,0}
Cable Check:        {TIOCM_RI,0}

Although (just as the powerd cable) the cable check function isn't
used because the UPS doesn't seem to support it.

Well that's about it I guess. If you need more information about the
UPS the cable or the software feel free to contact me.

And remember, everything described here works for me but I don't
guarantee it will for you.

Marcel Ammerlaan
CEO Pleursoft (explains the cablename doesn't it :-)
The Netherlands

&lt;RSA implemented in 3 lines of perl deleted by the editor ;)>

Marcel Ammerlaan   | &lt;m.j.ammerlaan@twi.tudelft.nl>
Paardenmarkt 78    | Just another nerd on the loose
2611 PD Delft      |
The Netherlands    |
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss8.5">8.5 Sustainer S-40a</A>
</H2>

<P>Information on the Sustainer S-40a.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
From: fnevgeny@plasma-gate.weizmann.ac.il (Evgeny Stambulchik)
To: hjstein@math.huji.ac.il, hjstein@math.huji.ac.il, hjstein@math.huji.ac.il,
        hjstein@math.huji.ac.il
Subject: UPS-HowTo add-ons
Date: Sun, 10 Sep 1995 13:09:50 +0300 (IST)

Hi Harvey,

This is an addition to your UPS-HowTo. I'm using Sustainer S-40a UPS for a few
months with unipower package (now it's called genpower) and home-made cable
constructed as follows (I've sent all this stuff to Tom Webster, author of the
package, too, and it should appear in the next version):

         UPS SIDE                                   LINUX SIDE


               2 POWER FAIL                             1(8) 
   +-----------o-------------------------+----------------o  DCD
   |                                     |
   o                                     |
    /                                    |
   /                                     |
   |           4 COMMON                  |              5(7) 
   +-----------o------+------------------|----------------o  GND
   |                  |                  |
   \                  |                  |
    \                 |                  |
   o                  |                  |
   |           5 BATT | LOW              |              8(5)    
   +-----------o------|------------------|--------+-------o  CTS
                      |                  |        |
                      |                +-+-+    +-+-+
                      |                |   |    |   |
                      |    3 resistors |   |    |   |
                      |                |   |    |   |
                      |    by 10 kOhm  |   |    |   |
                      |                +-+-+    +-+-+
                      |                  |        |     4(20)
                      |                  +--------+-------o  DTR
                      |
|              6 SHUT | DOWN              +-------+     7(4)
+-+       +----o------|-------------------+       +-------o  RTS
  \       |           |                   +-------+
   \|    -+-          | 
    | &lt;- \ /          |
   /|    -+-          |
  /       |    7      |
  |       +----o------+
--+--
 ---
  -
  
  
NOTE!!!: Shutdown pins in the tech info supplied with UPS (4 and 6) are given
incorrectly! The valid ones are 6 and 7, as shown above.
Note2: Pin numbers on the PC side in the brackets are for 25-pin connector,
outside - for 9-pin one.


Here's the unipowerd.h file I used:
    
  
/************************************************************************/
/* File Name            : unipowerd.h                                   */
/* Program Name         : unipowerd                   Version: 1.0.0    */
/* Author               : Tom Webster &lt;webster@kaiwan.com>              */
/* Created              : 1994/04/20                                    */
/* Last Modified By     : Tom Webster                 Date: 1995/04/09  */
/* Last Modified By     : Evgeny Stambulchik (for Sustainer UPS)        */
/*                                                                      */
/* Compiler (created)   : GCC 2.5.8                                     */
/* Compiler (env)       : Linux 1.0.9                                   */
/* ANSI C Compatable    : No                                            */
/* POSIX Compatable     : Yes?                                          */
/*                                                                      */
/* Purpose              : Header file for unipowerd.                    */
/*                      : Contains the configuration information for    */
/*                      : unipowerd.  Edit this file as indicated       */
/*                      : below to activate features and to customize   */
/*                      : unipowerd for your UPS.                       */
/*                                                                      */
/* Copyright            : GNU Copyleft                                  */
/************************************************************************/
 
/* The following are the RS232 control lines      */
/*                                                */
/*                                            D D */
/*                                            T C */
/* Macro           English                    E E */
/* ---------------------------------------------- */
/* TIOCM_DTR       DTR - Data Terminal Ready  --> */
/* TIOCM_RTS       RTS - Ready to send        --> */
/* TIOCM_CTS       CTS - Clear To Send        &lt;-- */
/* TIOCM_CAR       DCD - Data Carrier Detect  &lt;-- */
/* TIOCM_RNG       RI  - Ring Indicator       &lt;-- */
/* TIOCM_DSR       DSR - Data Signal Ready    &lt;-- */
 
#define HIGH            (1)
#define LOW             0
#define PWRSTAT         "/etc/powerstatus"
#define UPSSTAT         "/etc/upsstatus"

/* CABLEPOWER is the line which provides power to */
/* the cable for normal monitoring activities.    */
#define CABLEPOWER      TIOCM_DTR

#define POWERBIT        TIOCM_CAR
#define POWEROK         HIGH

/* Define CABLECHECK as 1 to check for low battery */
/* Define CABLECHECK as 0 value to skip            */
#define CABLECHECK      0
#define CABLEBIT        TIOCM_RNG
#define CABLEOK         HIGH

/* Define BATTCHECK as 1 to check for low battery  */
/* Define BATTCHECK as 0 value to skip.            */
#define BATTCHECK       1
#define BATTBIT         TIOCM_CTS
#define BATTOK          HIGH
 
/* Define INVERTERKILL as 1 to hndle killing the inverter */
/* Define INVERTERKILL as 0 value to skip.                */
/* INVERTERBIT is the line which will kill the inverter   */
/*    while the UPS is in powerfail mode.                 */
/* INVERTERTIME is the time in seconds to hold the line   */
/*    defiined by INVERTERBIT high to kill the inverter.  */
#define INVERTERKILL    1
#define INVERTERBIT     TIOCM_RTS
#define INVERTERTIME    5

/************************************************************************/
/* End of File unipowerd.h                                              */
/************************************************************************/

I'm aware that current name of the package is genpower. I haven't try it yet as
see no reason to switch to the new version meantime; the former seems to work
very stable. Nevertheless, here is the add-on for genpower-1.0.1's genpowerd.h
file (hopefully, I "translated" unipowerd.h correctly):
Add-on for genpower-1.0.1's genpowerd.h file:

/* Evgeny's Sustainer S-40A */
 {"sustainer",   {TIOCM_DTR,0}, {TIOCM_RTS,1},  5, {TIOCM_CAR,0}, {TIOCM_CTS,0},
{0,0}}


Evgeny
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>
<H2><A NAME="ss8.6">8.6 Systel</A>
</H2>

<P>Another Israeli company.  I never ended up purchasing a UPS from
them, but they were very good about getting me detailed documentation
on their communication port.  It should be easy enough to control
their UPS.  Their phone number is 972-8-409-019 (972-8-407-216 for
fax). 
<P>
<H2><A NAME="ss8.7">8.7 Deltec Power, Fiskars Power Systems and Exide.</A>
</H2>

<P>
<A HREF="http://www.fiskars.fi/">Fiskars</A> is a Finnish holding
company.  They used to own 
<A HREF="http://www.deltecpower.com">Deltec Power</A>.  In March of 1996 Fiskars sold
Deltec Power to 
<A HREF="http://www.exide.com/exide">Exide Electronics Group</A>.  At that time, Deltec Power was one
of the world's largest makers of UPSs.
<P>Under Fiskars, Deltec used to make the PowerServers 10, 20, 30, and
40.  The Deltec Power home page mentions other UPSs.
<P>Exide now bundles UPS control software with their UPSs that works
under Linux.  They also sell the software separately.  They say that
their software works with other UPSs too.
<P>I'd like to hear from people using their software.
<P>Here's the advertisement they emailed me:
<P>Exide Electronics announces LanSafe III UPS Power Management Software for
Linux.
<P>LanSafe III is a UPS Power Management application. It provides automatic
orderly shutdown functionality incase of an extended power failure that
should outlast the UPS battery run time.
<P>LanSafe III enables broadcast messages and e-mail to be sent according to
user defined power condition changes. The shutdown procedure can also be
customized.
<P>LanSafe III works together with the vast majority of all Exide Electronics
UPS models. It goes even one step further by supporting basic shutdown
functionality also with other manufacturers UPSs.
<P>LanSafe III for Linux runs on Intel based Linux systems. Both character
based and X11/Motif based user interfaces are provided.
<P>LanSafe III supports all the major OS platforms: Linux, IBM AIX, HP UX,
Digital UNIX, SCO UNIX, Solaris, SunOS, AT&amp;T UNIX, all Windows platforms,
OS/2,
Novell and Macintosh among others.
<P>LanSafe III is bundled with the following Exide Electronics UPSs: OneUPS
Plus, NetUPS, PowerWare Prestige, PowerWare Profile, PowerWare Plus 5xx.
<P>It also ships with FPS Power Systems UPSs: PowerRite Plus, PowerRite Max,
PowerWorks A30, PowerWorks A40, Series 9000 and Series 10000.
<P>It is also possible to purchase a separate software license to use with a
previous UPS model or an other manufactures UPS. Regular licenses are
S$149, with site licenses also available.
<P>For details please visit our Web sites at www.exide.com, www.fiskarsUPS.com
and www.deltecpower.com.
<P>Incidentally, when I tried to connect to www.fiskarsUPS.com, it
prompted me for a username and password.
<P>
<P>
<H2><A NAME="ss8.8">8.8 Beaver model UB500 UPS</A>
</H2>

<P>dan@fch.wimsey.bc.ca (Dan Fandrich) writes:
<P>
<P>I seem to have gotten my old Beaver model UB500 UPS working with genpower.
The interface uses RS-232 compatible voltage levels, so installing it is a
snap.  There is a DE-9 female connector on the back which plugs directly
into a 9-pin PC serial port using a plain 9-pin video monitor extension
cable.
<P>
<P>The DIP switches allow quite versatile pinouts.  To emulate genpower's
apc1-nt type of UPS, they must be set as follows:
<P>
<CENTER><TABLE BORDER><TR><TD>
<BR>
1 </TD><TD> on </TD><TD> (CTS = power fail)</TD></TR><TR><TD>
2 </TD><TD> off </TD><TD> (CTS = low battery)</TD></TR><TR><TD>
3 </TD><TD> off </TD><TD> (DSR = power fail)</TD></TR><TR><TD>
4 </TD><TD> off </TD><TD> (DSR = low battery)</TD></TR><TR><TD>
5 </TD><TD> off </TD><TD> (CD = power fail)</TD></TR><TR><TD>
6 </TD><TD> on </TD><TD> (CD = low battery)</TD></TR><TR><TD>
7 </TD><TD> off </TD><TD> (RI = power fail)</TD></TR><TR><TD>
8 </TD><TD> off </TD><TD> (RI = low battery)</TD></TR><TR><TD>
9 </TD><TD> on </TD><TD> (DTR = inverter off)</TD></TR><TR><TD>
10</TD><TD> off </TD><TD> (RTS = inverter off)</TD></TR><TR><TD>

<CAPTION>   DIP switch SW601 for Beaver model UB500 UPS.</CAPTION>
</TD></TR></TABLE></CENTER>
<P>The switches form groups of adjacent pairs for each output pin.  They
are mutually exclusive--don't try to turn on both switch 5 and 6
simultaneously, for example, or you'll be shorting the low battery and
power fail signals.
<P>That's all there is to it.  Feel free to add this do your documentation.
<P>
<P>
<H2><A NAME="ss8.9">8.9 Sendom</A>
</H2>

<P>Documentation on using the Sendom UPS.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
From: charli &lt;mefistos@impsat1.com.ar>
To: hjstein@math.huji.ac.il
Subject: ups howto contribution
Date: Wed, 13 Nov 1996 19:07:41 -0200

hjstein@math.huji.ac.il


sir:

i connected a sendom ups with the help of your UPS-howto and man powerd
and discovered something useful. perhaps this thing extends to some
other ups.
im using slackware 3.0 distribution. i has the soft configuration in 
/etc/inittab already done. its only needed to add the /rc.local powerd
/cuaX


i used the man powerd diagram:
        9pin    25pin   
                
DTR     4       20      ---------
                         |      >
DSR     6       6       --      &lt; 10k
                                >
DCD     1       8       -------------------------
                                                relais
GND     5       7       -------------------------


the fact is that the sendom ups dont use relais but some electronic
solid state device, and it works one way BUT NO THE OTHER. so if you
make the cable and doesnt work, first try inverting the cable in the
ups "relais"

i hope this can be useful, if you want to include this somewhere, feel
free to correct my english. please aknowledge this mail even with an
empty
mail so i know it arrived
end
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>
<H2><A NAME="ss8.10">8.10 Best</A>
</H2>

<P>
<P>Information on Best UPSs is available on at the 
<A HREF="http://www.bestpower.com/index.html">Best Power</A> website.  Their website
includes the <CODE>checkups.tar</CODE> (section 
<A HREF="UPS-HOWTO-4.html#software">Software</A>) package 
for communicating with Best UPSs, both in smart mode and in dumb mode,
and it includes source code, so you can compile it under Linux.
<P>
<H3>Best Fortress - Using Best's software</H3>

<P>
<P>Linux Best Power UPS Mini-HOWTO
by Michael Stutz (
<A HREF="mailto:stutz@dsl.org">stutz@dsl.org</A>, and 
<A HREF="http://dsl.org/m/">http://dsl.org/m/</A>)
v1.0, 14 Aug 97
<P>
<P>0.0 Disclaimer
<P>Copyright 1997 by Michael Stutz; this information is free; it may be
redistributed and/or modified under the terms of the GNU General Public
License, either Version 2 of the License, or (at your preference) any later
version, and as long as this sentence remains; this information comes
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE; see the GNU General Public License for
more details.
<P>
<P>1.0 Introduction
<P>
<A HREF="http://www.bestpower.com">Best Power</A> are the makers
of high quality UPS products, with their Fortress line in particular
being well-suited for typical Linux users. Although their products are
not currently priced as low as some (such as APC), Best Power provide
source code for their UPS software and have been very respondent to
queries from Linux users.  Furthermore, their hardware seems to be
highly regarded, making Best Power a winning choice for Linux users.
<P>This document describes the installation of a Best Power Fortress
UPS (model used was a 1996-model 660a with accompanying Best Power
CD-ROM) to a Linux box.
<P>
<P>2.0 Installation
<P>
<P>2.1 Hardware
<P>Install the hardware as indicated in the instructions. The Best Power
``Fortress'' series comes with an RS-232 cable that should attach to a spare
serial port on the back of the computer.
<P>
<P>2.2 Software
<P>This is where it differs from the manual, which does not currently have
Linux-specific instructions. The accompanying Fortress CD-ROM, however, does
come with source code for the UPS software, so getting it up and running on
a Linux system is a trivial task. 
<P>To do this, follow these steps, and use the manual as a reference to
get an overall feel for how the software works. I took the liberty of
making a few changes in this HOWTO from the way the Fortress software
is set up on other UNIX systems that I feel are better suited for a
Linux system.  For example, I eliminated the need for an
<CODE>/etc/best</CODE> directory and put the executables in
<CODE>/usr/local/sbin</CODE>, which I feel is a more appropriate place.
<P>
<UL>
<LI>First, create the "upsdown" script that is executed during a
power outage. This one will halt the system:

<BLOCKQUOTE><CODE>
<PRE>
cat > /etc/upsdown &lt;&lt; EOF
#!/bin/sh
shutdown -h now &lt; /dev/console &amp;
EOF
</PRE>
</CODE></BLOCKQUOTE>


</LI>
<LI>Now, make directories for the documentation and the source code:

<BLOCKQUOTE><CODE>
<PRE>
mkdir /usr/doc/best
mkdir /usr/local/src/best
</PRE>
</CODE></BLOCKQUOTE>

</LI>
<LI>Mount the CD-ROM, and untar the unix/checkups.tar file into the /tmp
directory or somewhere similar:

<BLOCKQUOTE><CODE>
<PRE>
cd /tmp
tar /cdrom/unix/checkups.tar
</PRE>
</CODE></BLOCKQUOTE>

</LI>
<LI>Change into the etc/best/advanced directory that should have been
extracted from the checkups tarball.
</LI>
<LI>Copy the documentation and UPS script files to their proper place in the
sytem:

<BLOCKQUOTE><CODE>
<PRE>
cp README /usr/doc/best
cp manual.txt /usr/doc/best
cp bestsend /etc
cp source/*.c /usr/local/src/best
</PRE>
</CODE></BLOCKQUOTE>

</LI>
<LI>Clean up the /tmp mess and compile the software:

<BLOCKQUOTE><CODE>
<PRE>
cd /usr/local/src/best
rm -R /tmp/etc
gcc -o checkups checkups.c
gcc -o mftalk mftalk.c
mv checkups /usr/local/sbin
mv mftalk /usr/local/sbin
</PRE>
</CODE></BLOCKQUOTE>

</LI>
<LI>Test the UPS. Replace ttySx with the serial port of your choice. If you
have a good connection, you should see a row of characters print across the
screen:

<BLOCKQUOTE><CODE>
<PRE>
mftalk /dev/ttySx
</PRE>
</CODE></BLOCKQUOTE>

</LI>
<LI>Make the checkups program run at startup for testing. This can be done in
several different ways (described in the manual).  The way I did it is by
adding this line to /etc/inittab:

<BLOCKQUOTE><CODE>
<PRE>
ups:234:once:/usr/local/sbin/checkups -c500 /dev/ttyS1
</PRE>
</CODE></BLOCKQUOTE>

</LI>
<LI>Test it. Do this by taking out power to UPS by pulling out the fuse
connected to the UPS, and wait a couple of minutes. It print a warning
messages and then halt the system after a few mintues.
</LI>
<LI>If that works, take out the "-c500" from the line in your inittab (which
basically means shut down the system right away instead of when the UPS
power runs out), and you're good to go!
</LI>
</UL>
<P>3.0 Conclusions
<P>I welcome suggestions for improving this document or the techniques
described herein. As of this writing, Best Power seemed interested in
including this or other information in their documentation to help Linux
users with their product, so this is definitely a company to support. Let
them know how you feel at 
<A HREF="sales@bestpower.com">sales@bestpower.com</A> and 
<A HREF="support@bestpower.com">support@bestpower.com</A>.
<P>
<H3>Best Fortress LI-950</H3>

<P>Some comments on the Best Fortress.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
From lnz@dandelion.com Wed May 31 19:53:09 1995
Newsgroups: comp.os.linux.hardware
Subject: Re: UPS for use with Linux?
From: Leonard N. Zubkoff &lt;lnz@dandelion.com>
Date: 25 May 1995 16:27:55 -0700
Organization: Dandelion Digital
NNTP-Posting-Host: dandelion.com
NNTP-Posting-User: root
In-reply-to: nautix@community.net's message of 23 May 1995 09:41:40 -0700

In article &lt;3pt384$sic@odin.community.net> nautix@community.net writes:

  Ditto what Craig says.  APC was very uncooperative, but I have only
  good things to say about Best.  I use their Fortress LI 660 model;
  660 VA, lots of status features on the front, etc.  The CheckUPS
  software costs extra and needs some hacking to fit into my
  FSSTND-ish file system (the directories and file names are hard-coded
  to fit into SunOS 4.1.x).  I'd be happy to send you my diffs, if
  you want them.  (I love it when a vendor ships the source as
  a normal business practice!)

  The CheckUPS software is limited to doing automagic shutdowns, though.
  The UPS can give lots of status information; CheckUPS only asks for
  ``If the power has failed, how much battery time remains?''

  Best follows up on their customer satisfaction cards, too.
  I indicated that I was dissappointed that CheckUPS didn't do more
  status reporting (like input voltage, output voltage, percent load,
  etc.), which is available from the UPS.  I asked for a the
  spec on the interface lingo; they said ``sure'' and had it to me in
  2 days, free.  A full-featured UPS status checker is on my back burner.
  Does anyone see a demand for such a utility?

Let me add yet another recommendation for Best Power.  I just purchased a
Fortress LI-950, though I declined on the CheckUPS software.  Unlike some
other brands, a simple three wire cable is all that's needed to connect the
Fortress to a serial port -- no need for pull-up circuitry in the cabling.
A few minutes hacking and I had program to act as both a shutdown monitor
daemon, and to kill the inverter output when the system is shutdown while
on battery power.

I may eventually want to use the smarter serial communication mode rather
than the simple contact mode, so I asked Best technical support for the
documentation, and it arrived today, a week after I called them.  Once I
peruse the documentation I'll decide if a smarter interface is really
worthwhile, especially since at some point I'll need to shut down two
networked machines sharing the UPS.

                Leonard
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>
<H3>Best Ferrups</H3>

<P>In addition to the doumentation and softare on Best's web site, you
could also use the <CODE>bestups-0.9.tar.gz</CODE> (section 
<A HREF="UPS-HOWTO-4.html#software">Software</A>)
package.  We've just started testing it with our 5kva FERRUPS.
<P>The basic idea is that there are two modules.  One which fields
information requests on a network port, relays those requests to the
UPS, and returns the results.  The second module talks to the first,
interprets the results, and responds with either OK or FAIL.
<P>This is sufficient to allow the <CODE>powerd-2.0.tar.gz</CODE> package
(section 
<A HREF="UPS-HOWTO-4.html#software">Software</A>) to do the rest of the work.
<P>The details can be gotten from the <CODE>bestups-0.9.tar.gz</CODE> package
(section 
<A HREF="UPS-HOWTO-4.html#software">Software</A>).
<P>Incidentally, our 5kva Ferrups has performed flawlessly in keeping our
10 computers and 30 screens humming.
<P>
<P>
<H2><A NAME="gps1000"></A> <A NAME="ss8.11">8.11 GPS1000 from ACCODATA</A>
</H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>
   >From hennus@sky.nl.mugnet.org Thu Mar 10 15:10:22 1994
   Newsgroups: comp.os.linux.help
   Subject: Re: auto-shutdown with UPS
   From: hennus@sky.nl.mugnet.org (Hennus Bergman)
   Date: Tue, 1 Mar 1994 22:17:45 GMT
   Distribution: world
   Organization: The Organization For Removal Of On-Screen Logos

   In article &lt;CRAFFERT.94Feb28125452@nostril.lehman.com>,
   Colin Owen Rafferty &lt;craffert@nostril.lehman.com> wrote:
   >I am about to buy an Uninterruptable Power Supply for my machine, and
   >I would like to get one that has the "auto-shutdown" feature.
   >
   I just got one of those real cheap :-)
   It's a GPS1000 by ACCODATA. Anybody know how good the output
   signal of these things is? [Don't have a scope myself :-(]

   >I assume that these each have some kind of serial connection that
   >tells the system information about it.
   >
   I took it apart to find out how it worked. There were three optocouplers
   (two output, one input) connected to a 9 pin connector at the back.
   One turns on when the power fails, and goes off again when the power
   returns. While the power is off, you can use the `input' to shut the
   battery off. [It releases the power-relay.] The third one is some kind
   of feedback to tell that it did accepted the `shut-down command'.
   I think the interface for my UPS was designed to be connected to TTL-level
   signals, but with some resistors it could be connected to serial port.
   It's wired in such a way that using a RS-232 port you cannot use both
   output optocouplers; but the shutdown feedback is not necessary anyway,
   just use the important one. ;-)
   [Note that it is possible to blow the transistor part in optocouplers
   with RS-232 levels if you wire it the wrong way round ;-)]

   I was hoping I would be able to connect it to my unused game port,
   but that doesn't have an output, does it?
   I'll probably end up getting an extra printer port for this.

   Not all UPS' use optocouplers, some use simple relays, which are
   less critical to connect, but of course not as `nice'.

   >Has anyone written a package that watches the UPS and does a shutdown
   >(or something) when the power is off?
   SysVinit-2.4 (and probably 2.5 as well) has a `powerd' daemon that
   continually watches a serial port for presence of the CD (Carrier
   Detect) line and signals init when it drops. Init then activates
   shutdown with a time delay. If the power returns within a few minutes
   the shutdown is cancelled. Very Nice.
   The only problem I had with it is that it doesn't actually tell the
   UPS to turn off when the shutdown is complete. It just sits there with
   a root prompt. I'll probably write a small program to shut it down
   >from /etc/brc. RSN.

   >    Colin Rafferty, Lehman Brothers &lt;craffert@lehman.com>

   Hennus Bergman
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss8.12">8.12 TrippLite BC750LAN (Standby UPS)</A>
</H2>

<P>Tom Webster (
<A HREF="mailto:webster@kaiwan.com">webster@kaiwan.com</A>, the author of the genpower package)
sent me information on the TrippLite BC750LAN.  If you have one of
these, your probably best off using his package.
<P>
<P>But, for completeness, here's his cable wiring diagram (done by trial
and error, and without documentation):
<P>
<BLOCKQUOTE><CODE>
<PRE>
          UPS                System
         DB-25               DB-25
           1 &lt;-------------->  1       Ground

           2 &lt;-------------->  4       Power Fail
           8 &lt;-------------->  8       Sensing Circuit

           3 &lt;-------------->  2       Inverter Shutdown
          20 &lt;--------------> 22       Circuit
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss8.13">8.13 APC</A>
</H2>

<P>If the above plethora of APC packages doesn't get you running,
maybe the following sections will help.
<P>
<H3>APC Back-UPS</H3>

<P>There seems to be some controversy as to the accuracy of the
information here on APC Back-UPSs.  So, please be careful.  I'm
prefacing this section with one message of caution I received.  It
might not make a lot of sense before the rest of this section is read,
but this way, at least you're more likely to see it.  And again, since
I don't have any APC UPS units, I can't verify the accuracy of either
of these messages.
<P>
<H3>A message of caution</H3>

<P>
<BLOCKQUOTE><CODE>
<PRE>
From ind43@sun1000.ci.pwr.wroc.pl Sun Oct  9 11:00:42 1994
Newsgroups: comp.os.linux.admin
Subject: BUPS-HOWTO warning
From: ind43@sun1000.ci.pwr.wroc.pl (Marek Michalkiewicz)
Date: 6 Oct 1994 18:38:15 GMT
Organization: Technical Univeristy of Wroclaw
NNTP-Posting-Host: ci3ux.ci.pwr.wroc.pl
X-Newsreader: TIN [version 1.2 PL2]

If you want to connect the APC Back-UPS to your Linux box, this might
be of interest to you.

There is a good BUPS-HOWTO which describes how to do this. But it has
one "bug".

The RTS serial port signal is used to shut down the UPS. The UPS will
shut down only if it operates from its battery. The manual says that
the shutdown signal must be high for at least 0.5s. But few milliseconds
is enough, at least for my APC Back-UPS 600.

Using RTS to shut down the UPS can be dangerous, because the RTS goes
high when the serial device is opened. The backupsd program then turns
RTS off, but it is on (high) for a moment. This kills the power when
backupsd is first started and there is a power failure at this time.
This can happen for example when the UPS is shut down, unattended,
and the power comes back for a while.

Either start backupsd before mounting any filesystems for read-write,
or (better) use TX (pin 3) instead of RTS (pin 7) to shut down the
UPS (pin numbers are for 9-pin plug). Use ioctl(fd, TCSBRKP, 10);
to make TX high for one second, for example. Using TX should be safe.
Maybe I will post the diffs if time permits...

-- Marek Michalkiewicz
ind43@ci3ux.ci.pwr.wroc.pl
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>
<H3>BUPS-HOWTO</H3>

<P>Luminated Software Group Presents
<P>HOWTO use Back-UPS (by APC)
(to keep your linux box from frying)
<P>
<P>Version: 1.01  BETA
<P>
<P>
<P>Document by: Christian G. Holtje &lt;docwhat@uiuc.edu&gt;
Cabling info and help: Ben Galliart &lt;bgallia@orion.it.luc.edu&gt;
<P>
<P>
<P>
<P>This document, under one condition, is placed in Public Domain. The
one condition is that credit is given where credit is due.  Modify this as
much as you want, just give some credit to us who worked.
<P>*******************************************************************************
Warning!
I, nor any of us who have written or helped with this document, make
and guarantees or claims for this text/source/hints.  If anything is damaged,
we take NO RESPONSIBILITY!  This works to the BEST OF OUR KNOWLEDGE, but
we may have made mistakes.  So be careful!
*******************************************************************************
<P>Al right, you just bought (or are going to buy) a Back-UPS from APC.
(Other brands might be able to use this info, with little or no modification,
but we don't know)  You've looked at the price of the Power-Chute
software/cabling, and just are not sure it's worth the price.  Well, I made my
own cable, and my own software and am using it to automatically shut off the
power to my linux box when a power failure hits.  Guess what?  You can too!
<P>*** The Cable ***
<P>
<P>This was the hardest part to figure out (I know little about hardware,
so Ben did the most work for this).  To build one, you need to buy from your
local radio shack (or other part supplier) this stuff:
<P>
<BLOCKQUOTE><CODE>
<PRE>
1 9-Position Male D-Subminature Connector (solder-type)
        [Radio Shack cat. no. 276-1537c]
1 9-Position Female D-Subminature Connector (solder-type)
        [Radio Shack cat. no. 276-1538c]
2 casings for the above plugs (usually sold separately)
Some stranded wire (wire made of strands, not solid wire)
</PRE>
</CODE></BLOCKQUOTE>
<P>You also need, but may be able to borrow:
<BLOCKQUOTE><CODE>
<PRE>
1 soldering iron
solder
</PRE>
</CODE></BLOCKQUOTE>
<P>Okay...this is how you connect it up!
<P>These diagrams are looking into the REVERSE SIDE (the side where you solder
the wire onto the plugs)  The letters G, R, and B represent the colors of the
wires I used, and help to distinguish one line from the next.
(NOTE:  I'm use standard rs-232 (as near as we can tell) numbering.  The APC
book uses different numbers.  Ignore them!  Use ours...I already changed the
numbers for you!)
<P>
<BLOCKQUOTE><CODE>
<PRE>
   ---------------------     Male Side! (This goes into the UPS)
    \  B   R  *  *  * /     
      \  *  *  *  G  / 
        ------------


   ---------------------     Female Side! (This goes into your COM port)
    \  R   *  *  *  G /
      \  *  B  *  *  / 
        ------------
</PRE>
</CODE></BLOCKQUOTE>
<P>For those who like the numbers better:
<P>
<BLOCKQUOTE><CODE>
<PRE>
        Male            Female
---------------------------------------
        1               7               Black
        2               1               Red
        9               5               Green
</PRE>
</CODE></BLOCKQUOTE>
<P>---------Aside:  What the rs-232 pins are for!-----------
Since we had to dig this info up anyway:
<P>&gt;From the REAR (the soldering side) the pins are numbered so:
<P>
<BLOCKQUOTE><CODE>
<PRE>
   ---------------------
    \  1   2  3  4  5 /
      \  6  7  8  9  / 
        ------------
</PRE>
</CODE></BLOCKQUOTE>
<P>The pins mean:
<P>
<BLOCKQUOTE><CODE>
<PRE>
        Number  Name                    Abbr. (Sometimes written with D prefix)
        1       Carrier Detect          CD
        2       Receive Data            RD
        3       Transmit Data           TD(?)
        4       Data Terminal Ready     DTR
        5       Signal Ground           Gnd
        6       Data Set Ready          DSR
        7       Request to Send         RTS(?)
        8       Clear to Send           CS
        9       Ring Indicator          RI
</PRE>
</CODE></BLOCKQUOTE>
<P>What we did is connect the UPS's RS-232 Line Fail Output to the CD, the UPS's
chassis to Gnd, and the UPS's RS-232 Shut Down Input to RTS.
Easy now that we told you, no?
<P>I have no idea if the software below will work, if you purchase the cable
from APC.  It might, and it might not.
<P>
<P>*** The Software ***
<P>Okay, I use the SysVInit package by Miquel van Smoorenburg for Linux.
(see end for file locations, credits, email addresses, etc.)  I don't know
what would have to be changed to use someone elses init, but I know this code
(following) will work with Miquel's stuff.
Just so I give credit where credit's due.  I looked at Miquel's code
to figure out how ioctl()'s worked.  If I didn't have that example, I'd have
been in trouble.  I also used the powerfail() routine (verbatim, I think),
since it must interact with his init, I thought that he should know best.
The .c file is at the end of this document, and just needs to be
clipped off.  To clip the file, edit away and extra '.sigs' and junk.  This
document should end on the line /* End of File */.....cut the rest.
<P>This program can either be run as a daemon to check the status of the
UPS and report it to init, or it can be run to send the kill-power command
to the UPS.  The power will only be killed if there is a power problem, and
the UPS is running off the battery.  Once the power is restored, it turns back
on.
<P>To run as a daemon, just type:
backupsd /dev/backups
<P>/dev/backups is a link to /dev/cua0 at the moment (COM 1, for you DOSers).
The niceness of the link is that I can just re-link the device if I change
to com 2 or 3.
<P>Then, if the power dies init will run the commands for the powerwait.
An example (This is from my <CODE>/etc/inittab</CODE>):
<P>
<BLOCKQUOTE><CODE>
<PRE>
#Here are the actions for powerfailure.
pf::powerwait:/etc/rc.d/rc.power start
po::powerokwait:/etc/rc.d/rc.power stop
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>The powerwait will run, if the power goes down, and powerokwait will
run if the power comes back up.
<P>
<P>Here is my entire rc.power:
<P>
<BLOCKQUOTE><CODE>
<PRE>
#! /bin/sh
#
# rc.power      This file is executed by init when there is a powerfailure.
#
# Version:      @(#)/etc/rc.d/rc.power   1.50    1994-08-10
#
# Author:       Christian Holtje, &lt;docwhat@uiuc.edu>
#

  # Set the path.
  PATH=/sbin:/etc:/bin:/usr/bin:/sbin/dangerous

  # Find out how we were called.
  case "$1" in
        start)
                echo "Warning there is Power problems."  | wall
                # Save current Run Level
                ps | gawk '{ if (($5 == "init") &amp;&amp; ($1 == "1")) print $6 }' \
                         | cut -f2 -d[ | cut -f1 -d] \
                         > /tmp/run.level.power
                /sbin/shutdown -h +1m
                ;;
        stop)
                echo "Power is back up.  Attempting to halt shutdown." | wall
                shutdown -c
                ;;
        *)
                echo "Usage:  $0 [start|stop]"
                exit 1
                ;;
  esac
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Pretty nifty, no?  Actually, there is a problem here...I haven't had
time to figure it out...If there is a 'sh' wizard out there....
<P>There is one little detail left, that is having the UPS turn off the power if
it was halted with the power out.  This is accomplished by adding this line
into the end of your halt script:
<P>
<BLOCKQUOTE><CODE>
<PRE>
  /sbin/backupsd /dev/backups killpower
</PRE>
</CODE></BLOCKQUOTE>
<P>This will only kill the power if there is no power being supplied to your
UPS.
<P>
<P>*** Testing the stuff ***
<P>This is just a short section saying this:
<P>BE CAREFUL!
<P>I recommend backing up your linux partitions, syncing several times
before testing and just being careful in general.  Of course, I'm just
recommending this.  I wasn't careful at all, and had to clean my partition
several times testing my config.  But it works.  :)
<P>
<P>*** Where to Get It ***
<P>Miquel van Smoorenburg's SysVInit can be gotten at:
<P><CODE>sunsite.unc.edu:/pub/Linux/system/Daemons/SysVinit-2.50.tgz</CODE>
<P>and a fix for some bash shells is right next-door as:
<P><CODE>sunsite.unc.edu:/pub/Linux/system/Daemons/SysVinit-2.50.patch1</CODE>
<P>As to getting this HOWTO, you can email me.
docwhat@uiuc.edu  with the subject saying 'request'
and the keyword 'backups' in body of the letter.
(I may automate this, and other stuff)
<P>*** Credit Where Credit's Due Dept. ***
<P>Thanks to Miquel van Smoorenburg &lt;miquels@drinkel.nl.mugnet.org&gt;
for his wonderful SysVInit package and his powerd.c which helped me very much.
<P>Christian Holtje &lt;docwhat@uiuc.edu&gt;
Documentation
backupsd.c (what wasn't Miquel's)
rc.power
<P>Ben Galliart &lt;bgallia@orion.it.luc.edu&gt;
The cable
Information for the RS-232 standard
Lousy Jokes (none quoted here)
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
/*  backupsd.c -- Simple Daemon to catch power failure signals from a
 *                Back-UPS (from APC).
 * 
 *  Parts of the code are from Miquel van Smoorenburg's powerd.c
 *  Other parts are original from Christian Holtje &lt;docwhat@uiuc.edu>
 *  I believe that it is okay to say that this is Public Domain, just
 *  give credit, where credit is due.
 *
 *  Disclaimer:  We make NO claims to this software, and take no
 *               resposibility for it's use/misuse.
 */

#include &lt;sys/types.h>
#include &lt;sys/ioctl.h>
#include &lt;fcntl.h>
#include &lt;errno.h>
#include &lt;stdlib.h>
#include &lt;unistd.h>
#include &lt;stdio.h>
#include &lt;signal.h>

/* This is the file needed by SysVInit */
#define PWRSTAT         "/etc/powerstatus"

void powerfail(int fail);

/* Main program. */
int main(int argc, char **argv)
{
  int fd;
  int killpwr_bit = TIOCM_RTS;
  int flags;
  int status, oldstat = -1;
  int count = 0;

  if (argc &lt; 2) {
        fprintf(stderr, "Usage: %s &lt;device> [killpower]\n", argv[0]);
        exit(1);
  }

  /* Open the the device */
  if ((fd = open(argv[1], O_RDWR | O_NDELAY)) &lt; 0) {
        fprintf(stderr, "%s: %s: %s\n", argv[0], argv[1], sys_errlist[errno]);
        exit(1);
  }

  if ( argc >= 3  &amp;&amp; (strcmp(argv[2], "killpower")==0) )
      {
          /* Let's kill the power! */
          fprintf(stderr, "%s: Attempting to kill the power!\n",argv[0] );
          ioctl(fd, TIOCMBIS, &amp;killpwr_bit); 
          /* Hmmm..... If you have a power outtage, you won't make it! */
          exit(0);
      }
  else
      /* Since we don't want to kill the power, clear the RTS. (killpwr_bit) */
      ioctl(fd, TIOCMBIC, &amp;killpwr_bit); 

/* Become a daemon. */
  switch(fork()) {
  case 0: /* I am the child. */
                setsid();
                break;
  case -1: /* Failed to become daemon. */
                fprintf(stderr, "%s: can't fork.\n", argv[0]);
                exit(1);
  default: /* I am the parent. */
                exit(0);
  }


  /* Now sample the DCD line. */
  while(1) {
      ioctl(fd, TIOCMGET, &amp;flags);
      status = (flags &amp; TIOCM_CD); 
      /* Did DCD jumps to high? Then the power has failed. */
      if (oldstat == 0 &amp;&amp; status != 0) {
          count++;
          if (count > 3) powerfail(0);
          else { sleep(1); continue; }
      }
      /* Did DCD go down again? Then the power is back. */
      if (oldstat > 0 &amp;&amp; status == 0) {
          count++;
          if (count > 3) powerfail(1);
          else { sleep(1); continue; }
      }
      /* Reset count, remember status and sleep 2 seconds. */
      count = 0;
      oldstat = status;
      sleep(2);
  }
  /* Error! (shouldn't happen) */
  return(1);
}


/* Tell init the power has either gone or is back. */
void powerfail(ok)
int ok;
{
  int fd;

  /* Create an info file needed by init to shutdown/cancel shutdown */
  unlink(PWRSTAT);
  if ((fd = open(PWRSTAT, O_CREAT|O_WRONLY, 0644)) >= 0) {
        if (ok)
                write(fd, "OK\n", 3);
        else
                write(fd, "FAIL\n", 5);
        close(fd);
  }
  kill(1, SIGPWR);
}

/* End of File */
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H3>More notes</H3>

<P>
<BLOCKQUOTE><CODE>
<PRE>
From ockers@carnot02.maem.umr.edu Mon Jan 16 15:27:29 1995
Newsgroups: comp.os.linux.hardware
Subject: Back-UPS, backupsd, and low battery signal
From: ockers@carnot02.maem.umr.edu (Jim Ockers)
Date: 12 Jan 1995 04:22:44 GMT
Reply-To: ockers@umr.edu
Organization: the all-male wasteland of Rolla, MO
NNTP-Posting-Host: carnot02.maem.umr.edu
X-Newsreader: TIN [version 1.2 PL2]

Hello all,

I use the backupsd on my linux system and I like it a lot.  I also
run Windows NT when I have to and it has a UPS daemon too.  The pinouts
required by Windows NT are different from the ones you specify in the
program but that is easily changed since I have the source for your
program..

Anyways I was browsing through the Windows NT knowledge base (KB) and
found something interesting.  If you look in the documentation for your
Back-UPS under "computer interface port" you will see that this UPS will
send a Low Battery signal at least two minutes before the battery fails.

At least the manual for my Back-UPS 400 says that...

However they also speak some Electrical Engineering gibberish ("Outputs ...
are actually open collector outputs which must be pulled up to a common
referenced supply no greater than +40 Vdc.  The transistors are capable
of a maximum non-inductive load of 25mAdc.)

Well that means nothing to me, but what I discovered in the NT KB was
that it is possible to use the low battery signal in the same manner that
the other signals are used.  The output from pin 5 on the UPS should go
to the pin on which you are reading the LowBatt signal into the computer.
When that line goes high, the battery is running out of charge.  When
the situation is normal, that line will be low.  (Hi/Lo in a standard
RS-232 signal, just like the other lines.)

What they don't tell you in the APC manual, and they should, is that
you need to buy a 10 KOhm resistor (50 cents at Radio Shack) and connect
pins 5 and 8 on the UPS side using the resistor.  Pin 8 provides the
"common referenced supply no greater than 40vdc".  Here's how you would
make the cable (the 1st three lines are the same as the HOWTO):

       PC side                         UPS side
pin      7 &lt;------------------------------> 1                 ShutDownUPS
         1 &lt;------------------------------> 2                 LineFail
         5 &lt;------------------------------> 4 (same as 9 )    GND
         ? your choice  &lt;-----------------> 5                 LowBatt
                                            |
                                             > 10
                                            &lt;  KOhm
                                            |
                                            8

So then when the LowBatt line is HIGH then the computer has 2 minutes
to shut down before the battery runs out.

This is not mentioned in the Back-UPS HOWTO nor is it addressed in the
backupsd source.  However I would think that it would be a Good Thing
to have in there; especially since a power failure would not require
a shutdown unless the UPS batteries were low.  In most cases it would
mean that the backupsd could send a warning to everyone if the LineFails,
and give everyone a one (or two) minute warning when the batteries start
running down.

As far as I know this applies to all the APC Back-UPS and Smart-UPS
products.  These instructions were for a Smart-UPS 900,1250, and 2000
according to the NT KB.  However they have been tested with a Back-UPS
400 running Windows NT and everything works properly...

I'd sure like to have a backupsd that handled the LowBatt situation too.
Does anyone feel like modifying the backupsd.c source so that it will do
this too?  (I can't program in C yet...)

P.S. The APC manual says to use only pin 4 as the common and even though
in the diagram it says that pin 9 is connected to pin 4 you might want to
be sure and use pin 4 .  This differs from the instructions in the HOWTO.

P.P.S. I mailed this to the Back-UPS HOWTO authors.

--
Jim  (ockers@umr.edu)                   Ask me about Linux!
http://www.umr.edu/~ockers/ - home page
</PRE>
</CODE></BLOCKQUOTE>
<P>
<BLOCKQUOTE><CODE>
<PRE>
From: Peter Kammer &lt;pkammer@liege.ICS.UCI.EDU>
To: "Harvey J. Stein" &lt;hjstein@math.huji.ac.il>
cc: "Christian G. Holtje" &lt;docwhat@uiuc.edu>
Subject: UPS-Howto--minor correction
Date: Mon, 07 Oct 1996 12:00:16 -0700


Mr. Stein,

        Let me first thank you for putting together and maintaining the
Linux UPS-HowTo document.  I recently attached a APC Back-UPS 400 to a
a Linux box and the document turned out to be very helpful.  
        I would like to suggest a correction to the the text diagrams which
accompany the description in section 11.5.2.  The diagrams are presented as
being the rear of the plug.  This in mind, the diagram of the male is
backwards:

         ---------------------     Male Side! (This goes into the UPS)
          \  B   R  *  *  * /     
            \  *  *  *  G  / 
              ------------


_From the rear_, the pins on the male connector are numbered
right-to-left.  The correct diagram should be:

         ---------------------     Male Side! (This goes into the UPS)
          \  *   *  *  R  B /     
            \  G  *  *  *  / 
              ------------


Similarly, the numbered diagram should be labeled as for the rear of the
female plug. 

         ---------------------
          \  1   2  3  4  5 /
            \  6  7  8  9  / 
              ------------

The rear of the male is numbered the reverse:

         ---------------------
          \  5   4  3  2  1 /
            \  9  8  7  6  / 
              ------------


This caused us some confusion until we realized our mistake.  With four
different configurations to be aware of (front, rear) x (male, female) it
is easy to get confused.  Even now, reference in hand, I keep reexamining
my diagrams.

It might also be helpful to add a reference to the APC technical document
for the Back-UPS line which is available on-line at:

   http://www.apcc.com/english/techs/techref4/224e.htm 

Once we corrected our wiring, setting up the software was relatively simple
thanks to your documentation.  We used the alternative (using TD to kill
the UPS power rather than RTS) wiring scheme and ran into few problems.
Your efforts in maintaining this information are much appreciated.

------------
Peter Kammer                       Dept. of Information and Computer Science
pkammer@ics.uci.edu                University of California
http://www.ics.uci.edu/~pkammer/   Irvine, CA 92697-3425
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H3>APC Back-UPS Pro 650</H3>

<P>
<BLOCKQUOTE><CODE>
<PRE>
From: Troy Muller &lt;tmuller@agora.rdrop.com>
Sender: tmuller@napalm.it.wsu.edu
To: abel@netvision.net.il
Subject: APC Back-UPS Pro 650
Date: Sun, 06 Apr 1997 12:50:40 -0700

Dear Mr. Stein,

I have a Back-UPS Pro 650 from APC and finally got it working with a
standard APC cable.

I used cable number 940-0023A and Enhanced_APC_BackUPS software.  My
only grudge is the software broadcasts every 2 seconds, but hacking the
dowall.c code to sleep 10 sec before broadcasting seems to limit it to
every 10 seconds with a 2-3 message queued to be printed (ie. much more
acceptable).
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H3>APC Smart-UPS</H3>

<P>Many people have APC Smart UPSs.  There seem to be packages for using
them in smart modes (see the afore mentioned packages
<CODE>Enhanced_APC_UPSD-v1.4.tar.gz</CODE>, <CODE>apcd-0.5.tar.gz</CODE>, and
<CODE>smupsd-0.7-1.i386.rpm</CODE> described in section 
<A HREF="UPS-HOWTO-4.html#software">Software</A>).  I
don't know how the support in each package is.  It seems that APC
<B>still</B> refuses to release the protocol for the ``smart'' mode
without a non-disclosure agreement, so everyone's left reverse engineering it.
<P>The general consensus is to buy from a brand which does release the
information, such as Best.
<P>Another possibility is to run the SCO Unix version of APC's Powerchute
UPS control software under Linux via the iBCS compatibility package.
I'm told by Clive A. Stubbings (
<A HREF="mailto:cas@vjet.demon.co.uk">cas@vjet.demon.co.uk</A>) that
this works nicely after some install script adjustments.  He says that
the only problem is "the GUI stuff seems to have difficulty
controlling non-local UPSs across the net".
<P>If you have an APC Smart-UPS, and you can't get any of the above
software to work in smart mode, you can still use it in dumb mode.
The following sections detail how to do that.  In particular, I've
received messages from people regarding the Model 600, the Model 700,
and the model 1400.  You'll probably have to hack <CODE>powerd.c</CODE> as
outlined in section 
<A HREF="UPS-HOWTO-6.html#hacking">Reverse-engineering cables and hacking powerd.c</A>.
<P>
<H3>APC Smart-UPS, Model 600</H3>

<P>
<BLOCKQUOTE><CODE>
<PRE>
From dangit@netcom.com Mon Aug 22 10:16:23 1994
Newsgroups: comp.os.linux.misc
Subject: UPS Monitoring Cable For APC
From: dangit@netcom.com (Lam Dang)
Date: Fri, 19 Aug 1994 11:56:28 GMT
Organization: NETCOM On-line Communication Services (408 261-4700 guest)
X-Newsreader: TIN [version 1.2 PL1]

[Didn't make it the first time.]

A few netters have asked about UPS monitoring cables.  This is what I
found when I made one for my APC Smart-UPS, Model 600.  A disclaimer is in
order.  This is just an experimenter's report; use it at your own risks.
Please read the User's Manual first, especially Section 6.4, Computer
Interface Port.

The cable is to run between a 9-pin female connector on the UPS and a
25-pin male connector on the PC.  Since I cut off one end of a 9-pin
cable and replaced it with a 25-pin connector, I had to be VERY
CAREFUL ABOUT PIN NUMBERS.  The 25-pin hood is big enough to contain a
voltage regulator and two resistors.  I got all the materials (listed
below) from Radio Shack for less than 10 bucks.  As required by Windows NT
Advanced Server 3.5 (Beta 2), the "interface" between the UPS connector
and the PC connector is as follows:

        UPS (9-pin)              PC (25-pin)

        1 (Shutdown)             20 (DTR)
        3 (Line Fail)             5 (CTS)
        4 (Common)                7 (GND)
        5 (Low Battery)           8 (DCD)
        9 (Chassis Ground)        1 (Chassis Ground)

This is pretty straightforward.  You can use UPS pin 6 instead of 3
(they're the inverse of each other).  The complication is in pulling up
UPS open collector pins 3 (or 6) and 5.

This APC model provides an unregulated output of 24 Vdc at UPS pin 8. The
output voltage is available all the time (at least until some time after
Low Battery has been signalled).  The supply is limited to 40 mA.  To
pull up, UPS pin 8 is input to a +5 Vdc voltage regulator.  The output of
the regulator goes into two 4.7K resistors.  The other end of one
resistor connects both UPS pin 3 (Line Fail) and PC pin 5 (CTS).  That
of the other resistor connects both UPS pin 5 (Low Battery) and PC pin 8
(DCD).  The two resistors draw about 2 mA when closed.

Test your cable without connecting it to the PC.  When the UPS is on
line, pins 5 (CTS) and 8 (DCD) at the PC end of the cable should be very
close to 5 Vdc, and applying a high to pin 20 (DTR) for 5 seconds should
have no effect.  Now pull the power plug to put the UPS on battery.  Pin
5 (CTS) should go down to zero Vdc, pin 8 (DCD) should stay the same at 5
Vdc, and applying a high to pin 20 (DTR), e.g., by shorting pins 8 and 20,
should shut down the UPS after about 15 seconds.

Keep the UPS on battery until Low Battery is lighted on its front panel.
Now pin 8 (DCD) should go down to zero Vdc too.  Wait until the UPS
battery is recharged.  Then connect your cable to the PC, disable the UPS
option switches by turning all of them ON, and run your favorite UPS
monitoring software.

For those who want to run it with Windows NT Advanced Server, the UPS
interface voltages are NEGATIVE for both power failure (using UPS pin 3)
and low battery conditions, and POSITIVE for remote shutdown.  Serial
line parameters such as baud rate don't matter.

I haven't tested my cable with Linux powerd.  When you do, please let us
know.  I run NT as often as Linux on the same PC.  I must conform to NT's
UPS scheme.  Perhaps somebody can modify powerd to work with it and post
the source code here.

List of materials:

        1 shielded D-sub connector hood (Radio Shack 276-1510)
        1 25-pin female D-sub crimp-type connector (276-1430)
        1 7805 +5Vdc voltage regulator (276-1770)
        2 4.7K resistors
        1 component perfboard (276-148)
        1 cable with at least one 9-pin male connector.

You'll need a multimeter, a soldering iron, and a couple of hours.

Hope this helps.

Regards,

--
Lam Dang
dangit@netcom.com
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H3><A NAME="apc700"></A> APC Smart-UPS 700</H3>

<P>Here're some details for running an APC Smart-UPS 700 in dumb mode.
<P>It has a clever usage of a transistor in the cable so that the
UPS will turn off when the computer is turned off.  And it includes a
<CODE>powerd.c</CODE> which also does a fast low battery shutdown.
<P>Also, note that Markus' is also using <CODE>init</CODE>'s new capabilities.
So we have here another illustration of how to use the new <CODE>init</CODE>
to your advantage.
<P>
<BLOCKQUOTE><CODE>
<PRE>
From: Markus Eiden &lt;Markus@eiden.de>
Sender: eiden@eiden.de
To: "Harvey J. Stein" &lt;abel@netvision.net.il>
Subject: Re: APC Smart-UPS
Date: Sun, 30 Mar 1997 16:21:05 +0200

I'm using an APC Smart-UPS 700 for my Linux box, running 2.0.21 on an
ASUS-Board.

To use some features of the UPS you need four things:


1) You have to build a RS232-cable with a small interface.
2) You need the powerd-source from the sysvinit-package (I use version 2.65
    from Miquel van Smoorenburg). Then you have to patch his powerd.
3) You have to change your /etc/inittab
4) You need a script to run some commands if the power is down or battery 
   is low.


Some features:

When the power goes down, a script will start and a syslog-entry is done.

If the battery is low, an other  script will start 
(which shutdown your computer of course) and a syslog-entry is done. 

If you shutdown your computer and the power is down, the UPS will be shut
down too.





 1)Let's start with the cable:
================================

If you have a look at the back side of you UPS you will see a female
connector like this:



             8             1: Shutdown the UPS when the power is down and    
                               pin 1 is high.
     X   X   X   X         3: Goes low on "Linefail"
   X   X   X   X   X       4: GND
                           5: Goes low on  "Low battery"
   1       3   4   5       8: +24V




On the other hand at the back side of your PC there exist a male
connector like this:


         8       6         1: DCD
     X   X   X   X         4: DTR
   X   X   X   X   X       5: GND
   5   4           1       6: DSR
                           8: CTS



You have to build the following interface between these connectors:





 PC                                                           UPS



                                         #------------------  (8)       
                                         |
                                        470 Ohm
                                         |
           #-----#-----#-----#-----#-----#----- ca. 9-12V
           |     |     |     |     |     |
           47    3.3   3.3   3.3   1     470
           kOhm  kOhm  kOhm  kOhm  kOhm  Ohm
           |     |     |     |     |     |
 (8) ------------------------#     |     |
           |     |     |           |     |
 (6) ------------#------------------------------------------- (5)
           |           |           |     |
 (1) ------------------#------------------------------------- (3)
           |                       |     |
           |                      C#------------------------- (1)
           |                      -|     |
           |                    B/       |
 (4) ------#-----12kOhm---------|        |
                                 \>E     |
                                 |       |
 (5)-----------------------------#-------#------------------- (4)





  -I use a "BC140" - transistor, but nearly any simple NPN-transistor
   should work  ;-)

  -The transistor works as an "inverter". If you shutdown your PC,
   AND the power ist down, then pin 4(PC) goes low and 1(UPS) goes
   high. This shuts down the UPS  for saving batteries power.

 

 2) The powerd-Source:
=======================

I patched the powerd-source very little (so it is really the source
of Miquel).

(a) Give an "alert" to the syslogd if 8(PC, CTS) is down (Cause
     the cable is not connected)

(b) DCD droped to zero => power has failed => call powerfail(0)
    => Give INIT_CMD_POWERFAIL to the init-process

(c) DCD comes up again => power is back => call powerfail(1)
    => Give INIT_CMD_POWEROK to the init-process

(d) DSR and DCD are dropped to zero => power has failed and 
    battery is low => call powerfail(2) => Give 
    INIT_CMD_POWERFAILNOW to the init-process

 Thats it.


------------------------------>8---- Schnipp ----------------------------


/*
 * powerd       Monitor the DCD line of a serial port connected to
 *              an UPS. If the power goes down, notify init.
 *              If the power comes up again, notify init again.
 *              As long as the power is OK, the DCD line should be
 *              "HIGH". When the power fails, DCD should go "LOW".
 *              Powerd keeps DTR high so that you can connect
 *              DCD and DTR with a resistor of 10 Kilo Ohm and let the
 *              UPS or some relais pull the DCD line to ground.
 *              You also need to connect DTR and DSR together. This
 *              way, powerd can check now and then if DSR is high
 *              so it knows the UPS is connected!!
 *
 * Usage:       powerd /dev/cua4 (or any other serial device).
 *
 * Author:      Miquel van Smoorenburg, &lt;miquels@drinkel.cistron.nl>.
 *              Some minor changes by Markus Eiden, &lt;Markus@Eiden.de>
 *              for the APC-Smart-UPS-powerd.
 *
 * Version:     1.31,  29-Feb-1996.
 *
 *              This program was originally written for my employer,
 *                      ** Cistron Electronics **
 *              who has given kind permission to release this program
 *              for general puppose.
 *
 *              Copyright 1991-1996 Cistron Electronics.
 *
 *              This program is free software; you can redistribute it and/or
 *              modify it under the terms of the GNU General Public License
 *              as published by the Free Software Foundation; either version
 *              2 of the License, or (at your option) any later version.
 *
 *              Some minor changes for the APC-powerd by Markus Eiden
 *              Markus@Eiden.de
 */

/* Use the new way of communicating with init. */
#define NEWINIT

#include &lt;sys/types.h>
#include &lt;sys/stat.h>
#include &lt;sys/ioctl.h>
#include &lt;fcntl.h>
#include &lt;errno.h>
#include &lt;stdlib.h>
#include &lt;unistd.h>
#include &lt;stdio.h>
#include &lt;signal.h>
#include &lt;syslog.h>
#include &lt;string.h>
#include "paths.h"
#ifdef NEWINIT
#include "initreq.h"
#endif

#ifndef SIGPWR
#  define SIGPWR SIGUSR1
#endif

#ifdef NEWINIT
void alrm_handler()
{
}
#endif

/* Tell init the power has either gone or is back. */
void powerfail(ok)
int ok;
{
  int fd;
#ifdef NEWINIT
  struct init_request req;

  /* Fill out the request struct. */
  memset(&amp;req, 0, sizeof(req));
  req.magic = INIT_MAGIC;


  /* INIT_CMD_* are definied in initreq.h                   *
   * Have a look at  init.c and /etc/inittab                *
   *                                                        *
   * ok=0 -> INIT_CMD_POWERFAIL      -> powerwait           *
   * ok=1 -> INIT_CMD_POWEROK        -> powerokwait         *
   * ok=2 -> INIT_CMD_POWERFAILNOW   -> powerfailnow        */

  
  switch (ok) {
    case 0 : req.cmd = INIT_CMD_POWERFAIL;
             /* Linefail -> warning */
             break;
    case 1 : req.cmd = INIT_CMD_POWEROK;
             /* Power is back -> cancel warning */
             break;
    case 2 : req.cmd = INIT_CMD_POWERFAILNOW;
             /* Linefail and LowBatt -> reboot */
             break;
             }
                                                         
  /* Open the fifo (with timeout) */
  signal(SIGALRM, alrm_handler);
  alarm(3);
  if ((fd = open(INIT_FIFO, O_WRONLY)) >= 0
                &amp;&amp; write(fd, &amp;req, sizeof(req)) == sizeof(req)) {
        close(fd);
        return;
  }
  /* Fall through to the old method.. */
#endif

  /* Create an info file for init. */
  unlink(PWRSTAT);
  if ((fd = open(PWRSTAT, O_CREAT|O_WRONLY, 0644)) >= 0) {
        if (ok)
                write(fd, "OK\n", 3);
        else
                write(fd, "FAIL\n", 5);
        close(fd);
  }
  kill(1, SIGPWR);
}

/* Main program. */
int main(int argc, char **argv)
{
  int fd;
  int dtr_bit = TIOCM_DTR;
  int flags;
  int status, oldstat = -1;
  int count = 0;
  int tries = 0;
  int powerfailed = 0;
  int rebootnow   = 0;

  if (argc &lt; 2) {
        fprintf(stderr, "Usage: powerd &lt;device>\n");
        exit(1);
  }

  /* Start syslog. */
  openlog("powerd", LOG_CONS|LOG_PERROR, LOG_DAEMON);

  /* Open monitor device. */
  if ((fd = open(argv[1], O_RDWR | O_NDELAY)) &lt; 0) {
        syslog(LOG_ERR, "%s: %s", argv[1], sys_errlist[errno]);
        closelog();
        exit(1);
  }
  
  /* Line is opened, so DTR is high. Force it anyway to be sure. */

  /* USE: low Batt -> Reboot -> DTR goes low                     *
   * transistor is open -> shutdown-pin  of the UPS goes         *
   * high -> UPS goes down after about 20s. If there is a        *
   * linefail and the computer is off, the                       *
   * UPS goes down. If the power is back, the                    *
   * UPS goes on, the computer boots, and powerd                 *
   * is startet.                                                 */

 /* Verwendung: Die UPS meldet low Batt -> Reboot -> DTR geht   *
   * auf Low -> Transistor oeffnet -> Shutdown der UPS geht auf  *
   * High -> UPS schaltet sich nach circa 20s aus. Bei jedem     *
   * Linefail und ausgeschaltetem Computer, schaltet sich die    *
   * UPS aus. Kommt der Strom zurueck, dann schaltet sich die    *
   * UPS selbstaendig ein, der Computer bootet, und der powerd   *
   * wird gestartet.                                             */

  ioctl(fd, TIOCMBIS, &amp;dtr_bit);




  /* Daemonize. */
  switch(fork()) {
        case 0: /* Child */
                closelog();
                setsid();
                break;
        case -1: /* Error */
                syslog(LOG_ERR, "can't fork.");
                closelog();
                exit(1);
        default: /* Parent */
                closelog();
                exit(0);
  }

  /* Restart syslog. */
  openlog("powerd", LOG_CONS, LOG_DAEMON);
  
   syslog(LOG_INFO, "APCpowerd started...");

  /* Now sample the DCD line. */
  while(1) {
        /* Get the status. */
        ioctl(fd, TIOCMGET, &amp;flags);

        /* Check the connection: CTS should be high. */
        tries = 0;
        /* TIOCM_*- have a look at  .../ams/termios.h */ 
        while((flags &amp; TIOCM_CTS) == 0) {
                /* Keep on trying, and warn every two minutes. */
                if ((tries % 60) == 0)
                    syslog(LOG_ALERT, "UPS connection error");
                sleep(2);
                tries++;
                ioctl(fd, TIOCMGET, &amp;flags);
        }
        if (tries > 0)
                syslog(LOG_ALERT, "UPS connection OK");

        /* Calculate present status. */
        status = (flags &amp; TIOCM_CAR);

        /* Did DCD drop to zero? Then the power has failed. */
        if (oldstat != 0 &amp;&amp; status == 0) {
                count++;
                if (count > 3) {
                        powerfailed = 1;
                        powerfail(0);
                        }
                else {
                        sleep(1);
                        continue;
                }
        }
        /* Did DCD come up again? Then the power is back. */
        if (oldstat == 0 &amp;&amp; status > 0) {
                count++;
                if (count > 3) {
                        powerfailed = 0;
                        
                        /* eigentlich unnoetig: */
                        rebootnow = 0;
                        
                        powerfail(1);
                        }      
                else {
                        sleep(1);
                        continue;
                }
        }
        
        /* Low battery and Linefail ? */
        if (rebootnow==0)
        if (powerfailed==1) 
        if ((flags &amp; TIOCM_DSR) == 0)
        { 
           rebootnow=1;  
           powerfail(2);
        
        }

        /* Reset count, remember status and sleep 2 seconds. */
        count = 0;
        oldstat = status;
        sleep(2);
  }
  /* Never happens */
  return(0);
}
    

------------------- schnap ------------ 8&lt;-----------------------------

 3) Change your inittab:
=========================


Init gets the INIT_CMDs and will start a script:

pf::powerwait:/sbin/init.d/powerfail    start
pn::powerfailnow:/sbin/init.d/powerfail now
po::powerokwait:/sbin/init.d/powerfail  stop

(Which means for example: if the power has failed (powerwait) start the
script /sbin/init.d/powerfail with the parameter "start".)



4) The powerfail-Script
========================



------------------ 8&lt; ------- schnipp ---------------

#! /bin/sh
# Copyright (c) 1997 Markus Eiden, Markus@Eiden.de
#

case "$1" in
    start)
        echo "THE POWER IS DOWN!" | wall
        logger "Powerfail"
        ;;
    now)
        echo "BATTERY IS LOW! Shutdown in 1 minute" | wall
        logger "Battery is low, shutdown in 1 minute"
        sync
        /sbin/shutdown -r -t 5 +1
        ;;
    stop)
        echo "THE POWER IS BACK!!" | wall
        logger "Power is back"

        /sbin/shutdown -c >/dev/null 2>/dev/null  

        ;;
  *)
        echo "Usage: $0 {start|now|stop}"
        exit 1
        ;;
esac

exit 0

--------------------- >8 ----------- schnapp -------------

Well, that should be easy ;-)



You are ready now, but be careful: It works for me, but I really can't
guarantee that any of this will work for you. 

Some advice at the end:  If /sbin/init.d/powerfail shuts down your
PC  then DTR goes down, so the shutdown pin (UPS) goes high. 
>From that time it takes about 20 or 30 seconds for the UPS to shut down. 
It is your job to prevent your Linux-box from booting within these 20
seconds (in particular to mount the filesystem). On my system it was no
problem. There are four easy ways to prevent the PC from the fast booting:

 1) The BIOS should do some routines (Like searching the number of
     tracks of your floppydisk if you have one)

 2) If you have LILO installed, tell him to wait.

 3) You do nothing (like I did)

 4) You buy some more memory so that counting the memory takes 30 seconds.
    That should be about 1024 Megabytes ;-).

 
Markus Eiden

Markus@Eiden.de


-- 
-----------------------------------------------------------------------
StR Dipl.-Ing. Markus Eiden \\://                       Markus@eiden.de
Am alten Sportplatz 3       (o -)        http://www.rp.schule.de/eiden/
D-67599 Gundheim      ---ooO-(_)-Ooo---             NIC-HDL: ME256-RIPE
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>
<H3>APC Smart-UPS 1400</H3>

<P>Another day, another APC.  This is for the Smart-UPS 1400, in dumb
mode.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
From: "Slavik Terletsky" &lt;ts@polynet.lviv.ua>
To: hjstein@math.huji.ac.il
Subject: my contribution to UPS HOWTO
Date: Mon, 27 Jan 1997 21:10:16 +0000

Hello
I just hacked ups daemon, if you want, you may enclose it
in your UPS HOWTO document (i used some info from).
Please replay.
--

UPS daemon for FreeBSD (2.1.5 - tested).
Interacts with APC Smart-UPS 1400.

Connection scheme:

UPS (pin, signal name)          PC (pin, signal name)
----------------------          ---------------------
1 Shutdown              >----------->   4 Data Terminal Ready
2 Line Failed           >----------->   8 Clear To Send
4 Common                >----------->   5 Ground
5 Battery Low           >--------+-->   1 Data Carrier Detector
8 Battery (+24V)        >--|10K|-+


UPSD DESCRIPTION

usage: upsd &lt;device> [wait [script]]

device  - device name upsd interacts thru (e.g. /dev/cuaa1)
wait    - time (secs) to wait before running script, (default value 0 sec).
script  - system shutdown script (default /etc/rc.shutdown).

Actions:
upsd logs all the changes of UPS status (power {up,down}, battery {low,ok}).
When "power down" and "battery low" upsd activates UPS SHUTDOWN signal,
waits for a &lt;wait> seconds, and then runs system shutdown script - &lt;script>.

Script sample:

#!/bin/sh
# Script is executed when system is going down.

PATH=/sbin:/bin:/usr/sbin:/usr/bin

echo "System is going DOWN right NOW" | wall

reboot


Upsd source:
/* UPS daemon
 * Copyright 1997 Slavik Terletsky. All rights reserved.
 * Author: Slavik Terletsky &lt;ts@polynet.lviv.ua>
 * System: FreeBSD
 */
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;signal.h>
#include &lt;syslog.h>
#include &lt;unistd.h>
#include &lt;varargs.h>
#include &lt;fcntl.h>
#include &lt;errno.h>
#include &lt;sys/uio.h>
#include &lt;sys/types.h>
#include &lt;sys/ioctl.h>
#include &lt;sys/ttycom.h>

int status;
int wait = 0;
FILE *fd;
char *scr = "/etc/rc.shutdown";
char *idf = "/var/run/upsd.pid";

void upsterm();
void upsdown(int);

int main(int argc, char *argv[]) {
 int pd;
 int zero = 0;
 char d5, d6, d7;
 char low = 0;
 char pow = 1;

 /* check arguments */
 switch(argc) {
 case  4:
 scr = argv[3];
 case  3:
 wait = atoi(argv[2]);
 case  2:
 break;
 default:
 fprintf(stderr, "usage: %s &lt;device> [wait [script]]\n", argv[0]);
 exit(1);
 }

 /* check if script exists */
 if(!(fd = fopen(scr, "r"))) {
 fprintf(stderr, "fopen: %s: %s\n", scr, sys_errlist[errno]);
 exit(1);
 }
 fclose(fd);

 /* check if upsd is already running */
 if(fd = fopen(idf, "r")) {
 fprintf(stderr, "fopen: %s: File already exists\n", idf);
 exit(1);
 }

 /* become a daemon */
 switch(fork()) {
 case -1:       /* error */
 fprintf(stderr, "fork: %s\n", sys_errlist[errno]);
 exit(1);
 case  0:       /* child */
 break;
 default:       /* parent */
 exit(0);
 }

 /* save the pid */
 if(!(fd = fopen(idf, "w"))) {
 fprintf(stderr, "fopen: %s: %s\n", idf, sys_errlist[errno]);
 exit(1);
 }
 fprintf(fd, "%d\n", (int)getpid());
 fclose(fd);

 /* open monitor device */
 if((pd = open(argv[1], O_RDWR | O_NDELAY)) &lt; 0) {
 fprintf(stderr, "open: %s: %s\n", argv[1], sys_errlist[errno]);
 exit(1);
 }

 /* daemon is alive */
 openlog("upsd", LOG_PID, LOG_DAEMON);
 syslog(LOG_INFO, "daemon started");

 /* signal reaction */
 (void)signal(SIGTERM, upsterm);

 /* monitor device */
 while(1) {
 /* clear bits */
 if(ioctl(pd, TIOCMSET, &amp;zero) &lt; 0) {
  fprintf(stderr, "ioctl: %s\n", sys_errlist[errno]);
  exit(1);
 }

 /* get device status */
 if(ioctl(pd, TIOCMGET, &amp;status) &lt; 0) {
  fprintf(stderr, "ioctl: %s\n", sys_errlist[errno]);
  exit(1);
 }

 /* determin status */
 d5 = status &amp; 0x20;
 d6 = status &amp; 0x40;
 d7 = status &amp; 0x80;

 /* power up */
 if(!(d7 + d5)) {
  if(!pow) {
   syslog(LOG_CRIT, "power up");
   pow = 1;
  }
 /* power down */
 } else {
  if(pow) {
   syslog(LOG_CRIT, "power down");
   pow = 0;
  }
 }

 /* battery low */
 if(!d6 &amp;&amp; !low) {
  syslog(LOG_ALERT, "battery low");
  low = 1;

  /* down ups */
  if(!pow) {
   upsdown(pd);
  }
 }

 /* battery ok */
 if(d6 &amp;&amp; low) {
  syslog(LOG_CRIT, "battery ok");
  low = 0;
 }

 sleep(1);
 }

 /* not reached */
 return 0;

}

void upsterm() {
 /* log termination message */
 syslog(LOG_INFO, "daemon terminated");

 /* remove pid file */
 unlink(idf);

 exit(0);
}

void upsdown(int pd) {
 /* log shutdown message */
 syslog(LOG_ALERT, "system is going down");

 /* remove pid file */
 unlink(idf);

 /* save our filesystem */
 system("/bin/sync");
 system("/bin/sync");
 system("/bin/sync");

 /* shutdown ups */
 status = TIOCM_DTR;
 if(ioctl(pd, TIOCMSET, &amp;status) &lt; 0) {
 fprintf(stderr, "ioctl: %s\n", sys_errlist[errno]);
 exit(1);
 }

 /* wait and then run script */
 sleep(wait);
 system(scr);
}
# Slavik Terletsky      # University "Lvivska Poytechnika" #
# Network Administrator # mailto:ts@polynet.lviv.ua        #
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>
<HR>
<A HREF="UPS-HOWTO-9.html"><IMG SRC="../img/next.gif" ALT="Next"></A>
<A HREF="UPS-HOWTO-7.html"><IMG SRC="../img/prev.gif" ALT="Previous"></A>
<A HREF="UPS-HOWTO.html#toc8"><IMG SRC="../img/toc.gif" ALT="Contents"></A>
<SCRIPT>EndPage();</SCRIPT>  </BODY>
</HTML>
