<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>GNU/Linux AI &amp; Alife HOWTO: Traditional Artificial Intelligence</TITLE>
 <LINK HREF="AI-Alife-HOWTO-3.html" REL=next>
 <LINK HREF="AI-Alife-HOWTO-1.html" REL=previous>
 <LINK HREF="AI-Alife-HOWTO.html#toc2" REL=contents>
<SCRIPT src="../menu.js"> function BeginPage() {} function EndPage() {} </SCRIPT> </HEAD> <BODY bgcolor=#EEEEFF MARGINHEIGHT=0 MARGINWIDTH=0> <SCRIPT>BeginPage(1, 8, 1);</SCRIPT>
<A HREF="AI-Alife-HOWTO-3.html"><IMG SRC="../img/next.gif" ALT="Next"></A>
<A HREF="AI-Alife-HOWTO-1.html"><IMG SRC="../img/prev.gif" ALT="Previous"></A>
<A HREF="AI-Alife-HOWTO.html#toc2"><IMG SRC="../img/toc.gif" ALT="Contents"></A>
<HR>
<H2><A NAME="s2">2. Traditional Artificial Intelligence</A>    </H2>

<P>Traditional AI is based around the ideas of logic, rule
systems, linguistics, and the concept of rationality.  At its
roots are programming languages such as Lisp and Prolog.
Expert systems are the largest successful example of this
paradigm.  An expert system consists of a detailed knowledge
base and a complex rule system to utilize it.  Such systems
have been used for such things as medical diagnosis support
and credit checking systems.
<P>
<P>
<H2><A NAME="ss2.1">2.1 AI class/code libraries</A>
</H2>

<P>
<P>These are libraries of code or classes for use in programming within
the artificial intelligence field.  They are not meant as stand alone
applications, but rather as tools for building your own applications.
<P>
<P>
<P>
<DL>
<P>
<A NAME="ACL2"></A> <DT><B>ACL2</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://ww.telent.net/cliki/ACL2">www.telent.net/cliki/ACL2</A></LI>
</UL>
<P>ACL2 (A Computational Logic for Applicative Common Lisp) is a theorem
prover for industrial applications. It is both a mathematical logic and
a system of tools for constructing proofs in the logic.  ACL2 works
with GCL (GNU Common Lisp).
<P>
<P>
<A NAME="AI Search II"></A>  
<DT><B>AI Search II</B><DD><P>
<UL>
<LI>WEB site: 
<A HREF="http://www.bell-labs.com/topic/books/ooai-book/">www.bell-labs.com/topic/books/ooai-book/</A></LI>
</UL>

Submitted by: 
<A HREF="mailto:peter@NOSPAM-icce.rug.nl">Peter M. Bouthoorn</A><P>
<P>Basically, the library offers the programmer a set of search
algorithms that may be used to solve all kind of different
problems. The idea is that when developing problem solving software
the programmer should be able to concentrate on the representation of
the problem to be solved and should not need to bother with the
implementation of the search algorithm that will be used to actually
conduct the search. This idea has been realized by the implementation
of a set of search classes that may be incorporated in other software
through <B>C++</B>'s features of derivation and inheritance.  The
following search algorithms have been implemented:
<P>
<P>
<UL>
<LI>depth-first tree and graph search.</LI>
<LI>breadth-first tree and graph search.</LI>
<LI>uniform-cost tree and graph search.</LI>
<LI>best-first search.</LI>
<LI>bidirectional depth-first tree and graph search.</LI>
<LI>bidirectional breadth-first tree and graph search.</LI>
<LI>AND/OR depth tree search.</LI>
<LI>AND/OR breadth tree search.</LI>
</UL>
<P>
<P>This library has a corresponding book, "
<A HREF="http://www.bell-labs.com/topic/books/ooai-book/">Object-Oriented Artificial Instelligence, Using C++</A>".
<P>
<P>
<P>
<A NAME="Chess In List"></A> <DT><B>Chess In Lisp (CIL)</B><DD><P>
<UL>
<LI>FTP site: 
<A HREF="ftp://chess.onenet.net/pub/chess/uploads/projects/">chess.onenet.net/pub/chess/uploads/projects/</A></LI>
</UL>
<P>
<P>The CIL (Chess In Lisp) foundation is a Common Lisp
implementaion of all the core functions needed for development
of chess applications.  The main purpose of the CIL project is
to get AI researchers interested in using Lisp to work in the
chess domain.
<P>
<P>
<P>
<P>
<A NAME="DAI"></A> <DT><B>DAI</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://starship.python.net/crew/gandalf/DNET/AI/">starship.python.net/crew/gandalf/DNET/AI/</A></LI>
</UL>
<P>A library for the Python programming language that provides an
object oriented interface to the CLIPS expert system tool. It 
includes an interface to COOL (CLIPS Object Oriented Language)
that allows:
<UL>
<LI>Investigate COOL classes</LI>
<LI>Create and manipulate with COOL instances</LI>
<LI>Manipulate with COOL message-handler's</LI>
<LI>Manipulate with Modules</LI>
</UL>
<P>
<P>
<A NAME="HTK"></A> <DT><B>HTK</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://htk.eng.cam.ac.uk/">htk.eng.cam.ac.uk</A></LI>
</UL>
<P>The Hidden Markov Model Toolkit (HTK) is a portable toolkit for
building and manipulating hidden Markov models.  HTK consists of a set
of library modules and tools available in C source form. The tools
provide sophisticated facilities for speech analysis, HMM training,
testing and results analysis. The software supports HMMs using both
continuous density mixture Gaussians and discrete distributions and can
be used to build complex HMM systems.  The HTK release contains
extensive documentation and examples.
<P>
<P>
<A NAME="LK"></A> <DT><B>LK</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.cs.utoronto.ca/~neto/research/lk/">www.cs.utoronto.ca/~neto/research/lk/</A></LI>
</UL>
<P>LK is an implementation of the Lin-Kernighan heuristic for the
Traveling Salesman Problem and for the minimum weight perfect matching
problem. It is tuned for 2-d geometric instances, and has been applied
to certain instances with up to a million cities. Also included are
instance generators and Perl scripts for munging TSPLIB instances. 
<P>This implementation introduces ``efficient cluster compensation'', an
experimental algorithmic technique intended to make the Lin-Kernighan
heuristic more robust in the face of clustered data.
<P>
<P>
<A NAME="Nyquist"></A>  
<DT><B>Nyquist</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.cs.cmu.edu/afs/cs.cmu.edu/project/music/web/music.html">www.cs.cmu.edu/afs/cs.cmu.edu/project/music/web/music.html</A></LI>
</UL>
<P>
<P>The Computer Music Project at CMU is developing computer music
and interactive performance technology to enhance human musical
experience and creativity. This interdisciplinary effort draws
on Music Theory, Cognitive Science, Artificial Intelligence and
Machine Learning, Human Computer Interaction, Real-Time Systems,
Computer Graphics and Animation, Multimedia, Programming
Languages, and Signal Processing. A paradigmatic example of
these interdisciplinary efforts is the creation of interactive
performances that couple human musical improvisation with
intelligent computer agents in real-time.
<P>
<P>
<P>
<A NAME="PDKB"></A> <DT><B>PDKB</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://lynx.eaze.net/~pdkb/web/">lynx.eaze.net/~pdkb/web/</A></LI>
<LI>SourceForge site: 
<A HREF="http://sourceforge.net/project/pdkb/">sourceforge.net/project/pdkb</A></LI>
</UL>
<P>Public Domain Knowledge Bank (PDKB) is an Artificial Intelligence
Knowledge Bank of common sense rules and facts. It is based on the Cyc
Upper Ontology and the MELD language.
<P>
<P>
<P>
<A NAME="Python Fuzzy Logic Module"></A> <DT><B>Python Fuzzy Logic Module</B><DD><P>
<UL>
<LI>FTP site: 
<A HREF="ftp://ftp.csh.rit.edu/pub/members/retrev/">ftp://ftp.csh.rit.edu/pub/members/retrev/</A></LI>
</UL>
<P>A simple python module for fuzzy logic. The file is 'fuz.tar.gz' in
this directory. The author plans to also write a simple genetic
algorithm and a neural net library as well. Check the 00_index file in
this directory for release info.
<P>
<P>
<A NAME="QUANT/1"></A> <DT><B>QUANT1</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://linux.irk.ru/projects/QUANT/">linux.irk.ru/projects/QUANT/</A></LI>
</UL>
<P>QUANT/1 stands for type QUANTifier. It aims to be an alternative to
Prolog-like (Resulutional-like) systems. Main features include a lack
of necessity for eliminating Quantifiers, scolemisation, ease of
comprehension, large scale formulae operation, acceptance of nonHorn
formulaes, and Iterative deeping. The actual library implemented in
this project is called ATPPCF (Automatic Theorem Prover in calculus of
Positively Constructed Formulae).
<P>ATPPCF will be a library (inference engine) and an extension of the
Predicate Calculus Language as a new logical language. The library will
be incorporable in another software such as TCL, Python, Perl. The
engine's primary inference method will be the "search of inference in
language of Positively Constructed Formulas (PCFs)" (a subset of
Predicate Calculus well translated in both directions). The language
will be used as scripting language to the engine. But there will be
possibility to replace it with extensions languages of main software.
<P>
<P>
<P>
<A NAME="Screamer"></A> <DT><B>Screamer</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.cis.upenn.edu/~screamer-tools/home.html">www.cis.upenn.edu/~screamer-tools/home.html</A></LI>
</UL>
<P>Screamer is an extension of Common Lisp that adds support for
nondeterministic programming. Screamer consists of two
levels. The basic nondeterministic level adds support for
backtracking and undoable side effects.  On top of this
nondeterministic substrate, Screamer provides a comprehensive
constraint programming language in which one can formulate and
solve mixed systems of numeric and symbolic
constraints. Together, these two levels augment Common Lisp with
practically all of the functionality of both Prolog and
constraint logic programming languages such as CHiP and CLP(R).
Furthermore, Screamer is fully integrated with Common
Lisp. Screamer programs can coexist and interoperate with other
extensions to Common Lisp such as CLOS, CLIM and Iterate.
<P>
<P>
<P>
<A NAME="ThoughtTreasure"></A> <DT><B>ThoughtTreasure</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.signiform.com/tt/htm/tt.htm">www.signiform.com/tt/htm/tt.htm</A></LI>
</UL>
<P>ThoughtTreasure is a project to create a database of commonsense rules
for use in any application. It consists of a database of a little over
100K rules and a C API to integrate it with your applications. Python,
Perl, Java and TCL wrappers are already available.
<P>
<P>
<P>
</DL>
<P>
<P>
<P>
<P>
<P>
<H2><A NAME="ss2.2">2.2 AI software kits, applications, etc.</A>
    </H2>

<P>
<P>These are various applications, software kits, etc. meant for research
in the field of artificial intelligence. Their ease of use will vary,
as they were designed to meet some particular research interest more
than as an easy to use commercial package.
<P>
<DL>
<P>
<A NAME="ASA"></A> <DT><B>ASA - Adaptive Simulated Annealing</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.ingber.com/#ASA-CODE">www.ingber.com/#ASA-CODE</A></LI>
<LI>FTP site: 
<A HREF="ftp://ftp.ingber.com/">ftp.ingber.com/</A></LI>
</UL>
<P>
<P>ASA (Adaptive Simulated Annealing) is a powerful global
optimization C-code algorithm especially useful for nonlinear and/or
stochastic systems.
<P>
<P>ASA is developed to statistically find the best global fit of a
nonlinear non-convex cost-function over a D-dimensional space. This
algorithm permits an annealing schedule for 'temperature' T decreasing
exponentially in annealing-time k, T = T_0 exp(-c k^1/D).
The introduction of re-annealing also permits adaptation to changing
sensitivities in the multi-dimensional parameter-space. This annealing
schedule is faster than fast Cauchy annealing, where T = T_0/k,
and much faster than Boltzmann annealing, where T = T_0/ln k.  
<P>
<P>
<A NAME="Babylon"></A>  
<DT><B>Babylon</B><DD><P>
<UL>
<LI>FTP site: 
<A HREF="ftp://ftp.gmd.de/gmd/ai-research/Software/Babylon/">ftp.gmd.de/gmd/ai-research/Software/Babylon/</A></LI>
</UL>
<P>BABYLON is a modular, configurable, hybrid environment for
developing expert systems. Its features include objects, rules with
forward and backward chaining, logic (Prolog) and constraints. BABYLON
is implemented and embedded in Common Lisp.
<P>
<P>
<A NAME="cfengine"></A> <DT><B>cfengine</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.iu.hioslo.no/cfengine/">www.iu.hioslo.no/cfengine/</A></LI>
</UL>
<P>Cfengine, or the configuration engine is a very high level language for
building expert systems which administrate and configure large computer
networks. Cfengine uses the idea of classes and a primitive form of
intelligence to define and automate the configuration of large systems
in the most economical way possible. Cfengine is design to be a part of
computer immune systems.
<P>
<P>
<A NAME="CLEARS"></A> <DT><B>CLEARS</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.coli.uni-sb.de/~clears/">www.coli.uni-sb.de/~clears/</A></LI>
</UL>
<P>The CLEARS system is an interactive graphical environment for
computational semantics. The tool allows exploration and
comparison of different semantic formalisms, and their
interaction with syntax. This enables the user to get an idea of
the range of possibilities of semantic construction, and also
where there is real convergence between theories.
<P>
<P>
<A NAME="CLIG"></A> <DT><B>CLIG</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.ags.uni-sb.de/~konrad/clig.html">www.ags.uni-sb.de/~konrad/clig.html</A></LI>
</UL>
<P>CLIG is an interactive, extendible grapher for visualizing linguistic
data structures like trees, feature structures, Discourse
Representation Structures (DRS), logical formulas etc. All of these can
be freely mixed and embedded into each other. The grapher has been
designed both to be stand-alone and to be used as an add-on for
linguistic applications which display their output in a graphical
manner.
<P>
<P>
<A NAME="CLIPS"></A> <DT><B>CLIPS</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.jsc.nasa.gov/~clips/CLIPS.html">www.jsc.nasa.gov/~clips/CLIPS.html</A></LI>
<LI>FTP site: 
<A HREF="ftp://cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/areas/expert/systems/clips">cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/areas/expert/systems/clips</A></LI>
</UL>
<P>CLIPS is a productive development and delivery expert system tool
which provides a complete environment for the construction of rule
and/or object based expert systems.  
<P>
<P>CLIPS provides a cohesive tool for handling a wide variety of
knowledge with support for three different programming paradigms:
rule-based, object-oriented and procedural.  Rule-based programming
allows knowledge to be represented as heuristics, or "rules of thumb,"
which specify a set of actions to be performed for a given
situation. Object-oriented programming allows complex systems to be
modeled as modular components (which can be easily reused to model
other systems or to create new components).  The procedural
programming capabilities provided by CLIPS are similar to capabilities
found in languages such as C, Pascal, Ada, and LISP.
<P>
<P>
<A NAME="EMA-XPS"></A> <DT><B>EMA-XPS - A Hybrid Graphic Expert System Shell</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://wmwap1.math.uni-wuppertal.de:80/EMA-XPS/">wmwap1.math.uni-wuppertal.de:80/EMA-XPS/</A></LI>
</UL>
<P>
<P>EMA-XPS is a hybrid graphic expert system shell based on the
ASCII-oriented shell Babylon 2.3 of the German National Research
Center for Computer Sciences (GMD). In addition to Babylon's AI-power
(object oriented data representation, forward and backward chained
rules - collectible into sets, horn clauses, and constraint networks)
a graphic interface based on the X11 Window System and the OSF/Motif
Widget Library has been provided.
<P>
<P>
<A NAME="Fool-Fox"></A> <DT><B>FOOL &amp; FOX</B><DD><P>
<UL>
<LI>FTP site: 
<A HREF="ftp://ntia.its.bldrdoc.gov/pub/fuzzy/prog/">ntia.its.bldrdoc.gov/pub/fuzzy/prog/</A></LI>
</UL>
<P>
<P>FOOL stands for the Fuzzy Organizer OLdenburg. It is a result from
a project at the University of Oldenburg. FOOL is a graphical user
interface to develop fuzzy rulebases.  FOOL will help you to invent
and maintain a database that specifies the behavior of a
fuzzy-controller or something like that.
<P>
<P>FOX is a small but powerful fuzzy engine which reads this database,
reads some input values and calculates the new control value.
<P>
<P>
<A NAME="FUF-SURGE"></A> <DT><B>FUF and SURGE</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.dfki.de/lt/registry/generation/fuf.html">www.dfki.de/lt/registry/generation/fuf.html</A></LI>
<LI>FTP site: 
<A HREF="ftp://ftp.cs.columbia.edu:/pub/fuf/">ftp.cs.columbia.edu/pub/fuf/</A></LI>
</UL>
<P>FUF is an extended implementation of the formalism of functional
unification grammars (FUGs) introduced by Martin Kay specialized to
the task of natural language generation. It adds the following
features to the base formalism:
<UL>
<LI>Types and inheritance. </LI>
<LI>Extended control facilities (goal freezing, intelligent backtracking). </LI>
<LI>Modular syntax.</LI>
</UL>

These extensions allow the development of large grammars which can be
processed efficiently and can be maintained and understood more
easily.  SURGE is a large syntactic realization grammar of English
written in FUF. SURGE is developed to serve as a black box syntactic
generation component in a larger generation system that encapsulates a
rich knowledge of English syntax. SURGE can also be used as a platform
for exploration of grammar writing with a generation perspective.
<P>
<P>
<A NAME="Grammar Workbench"></A> <DT><B>The Grammar Workbench</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.cs.kun.nl/agfl/GWB.html">www.cs.kun.nl/agfl/GWB.html</A></LI>
</UL>
     
<P>
<P>The Grammar Workbench, or GWB for short, is an environment for the
comfortable development of Affix Grammars in the AGFL-formalism. Its
purposes are: 
<UL>
<LI>to allow the user to input, inspect and modify a grammar; </LI>
<LI>to perform consistency checks on the grammar; </LI>
<LI>to compute grammar properties; </LI>
<LI>to generate example sentences; </LI>
<LI>to assist in performing grammar transformations. </LI>
</UL>
<P>
<P>
<A NAME="GSM Suite"></A> <DT><B>GSM Suite</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.slip.net/~andrewm/gsm/">www.slip.net/~andrewm/gsm/</A></LI>
</UL>
<P>The GSM Suite is a set of programs for using Finite State
Machines in a graphical fashion. The suite consists of programs
that edit, compile, and print state machines. Included in the
suite is an editor program, gsmedit, a compiler, gsm2cc, that
produces a C++ implementation of a state machine, a PostScript
generator, gsm2ps, and two other minor programs. GSM is licensed
under the GNU Public License and so is free for your use under
the terms of that license.
<P>
<P>
<A NAME="Illuminator"></A> <DT><B>Illuminator</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://documents.cfar.umd.edu/resources/source/illuminator.html">documents.cfar.umd.edu/resources/source/illuminator.html</A></LI>
</UL>
<P>Illuminator is a toolset for developing OCR and Image
Understanding applications.  Illuminator has two major parts: a
library for representing, storing and retrieving OCR
information, heretofore called dafslib, and an X-Windows "DAFS"
file viewer, called illum. Illuminator and DAFS lib were
designed to supplant existing OCR formats and become a standard
in the industry. They particularly are extensible to handle more
than just English.
<P>The features of this release: 
<UL>
<LI>5 magnification levels for images</LI>
<LI>flagged characters and words</LI>
<LI>unicode support -- American, British, French, German, 
Greek, Italian, MICR, Norwegian, Russian, Spanish, Swedish, 
keyboards </LI>
<LI>reads DAFS, TIFF's, PDA's (image only)</LI>
<LI>save to DAFS, ASCII/UTF or Unicode</LI>
<LI>Entity Viewer - shows properties, character choices, 
bounding boxes image fragment for a selected entity, change 
type, change content, hierarchy mode</LI>
</UL>
<P>
<P>
<A NAME="Isabelle"></A> <DT><B>Isabelle</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://isabelle.in.tum.de/">isabelle.in.tum.de</A></LI>
</UL>
<P>Isabelle is a popular generic theorem prover developed at Cambridge
University and TU Munich. Existing logics like Isabelle/HOL provide a
theorem proving environment ready to use for sizable applications.
Isabelle may also serve as framework for rapid prototyping of deductive
systems. It comes with a large library including Isabelle/HOL
(classical higher-order logic), Isabelle/HOLCF (Scott's Logic for
Computable Functions with HOL), Isabelle/FOL (classical and
intuitionistic first-order logic), and Isabelle/ZF (Zermelo-Fraenkel
set theory on top of FOL).
<P>
<P>
<A NAME="Jess"></A> <DT><B>Jess, the Java Expert System Shell</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://herzberg.ca.sandia.gov/jess/">herzberg.ca.sandia.gov/jess/</A></LI>
</UL>
<P>Jess is a clone of the popular CLIPS expert system shell written
entirely in Java. With Jess, you can conveniently give your
applets the ability to 'reason'. Jess is compatible with all
versions of Java starting with version 1.0.2. Jess implements
the following constructs from CLIPS: defrules, deffunctions,
defglobals, deffacts, and deftemplates.  
<P>
<P>
<A NAME="learn"></A> <DT><B>learn</B><DD><P>
<UL>
<LI>FTP site: 
<A HREF="http://sunsite.unc.edu/pub/Linux/apps/cai/">sunsite.unc.edu/pub/Linux/apps/cai/</A></LI>
</UL>
<P>Learn is a vocable learning program with memory model. 
<P>
<P>
<A NAME="LISA"></A> <DT><B>LISA</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://lisa.sourceforge.net/">lisa.sourceforge.net</A></LI>
</UL>
<P>LISA (Lisp-based Intelligent Software Agents) is a production-rule
system heavily influenced by JESS (Java Expert System Shell). It has at
its core a reasoning engine based on the Rete pattern matching
algorithm. LISA also provides the ability to reason over ordinary CLOS
objects.
<P>
<P>
<A NAME="NICOLE"></A> <DT><B>NICOLE</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://nicole.sourceforge.net/">nicole.sourceforge.net</A></LI>
</UL>
<P>NICOLE (Nearly Intelligent Computer Operated Language Examiner) is a
theory or experiment that if a computer is given enough combinations of
how words, phrases and sentences are related to one another, it could
talk back to you. It is an attempt to simulate a conversation by
learning how words are related to other words. A human communicates
with NICOLE via the keyboard and NICOLE responds back with its own
sentences which are automatically generated, based on what NICOLE has
stored in it's database. Each new sentence that has been typed in, and
NICOLE doesn't know about, is included into NICOLE's database, thus
extending the knowledge base of NICOLE.
<P>
<P>
<A NAME="Otter"></A> <DT><B>Otter: An Automated Deduction System</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www-unix.mcs.anl.gov/AR/otter/">www-unix.mcs.anl.gov/AR/otter/</A></LI>
</UL>
<P>Our current automated deduction system  Otter is designed to prove
theorems stated in first-order logic with equality.  Otter's
inference rules are based on resolution and paramodulation, and it
includes facilities for term rewriting, term orderings, Knuth-Bendix
completion, weighting, and strategies for directing and restricting
searches for proofs.   Otter can also be used as a symbolic
calculator and has an embedded equational programming system.
<P>
<P>
<A NAME="PVS"></A> <DT><B>PVS</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://pvs.csl.sri.com/">pvs.csl.sri.com/</A></LI>
</UL>
<P>PVS is a verification system: that is, a specification language
integrated with support tools and a theorem prover. It is
intended to capture the state-of-the-art in mechanized formal
methods and to be sufficiently rugged that it can be used for
significant applications. PVS is a research prototype: it
evolves and improves as we develop or apply new capabilities,
and as the stress of real use exposes new requirements.
<P>
<P>
<P>
<A NAME="RIPPER"></A> <DT><B>RIPPER</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.research.att.com/~wcohen/ripperd.html">www.research.att.com/~wcohen/ripperd.html</A></LI>
</UL>
<P>
<P>Ripper is a system for fast effective rule induction. Given a set
of data, Ripper will learn a set of rules that will predict the 
patterns in the data. Ripper is written in ASCI C and comes with
documentation and some sample problems.
<P>
<P>
<P>
<A NAME="SNePS"></A> <DT><B>SNePS</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.cs.buffalo.edu/pub/sneps/WWW/">www.cs.buffalo.edu/pub/sneps/WWW/</A></LI>
<LI>FTP site: 
<A HREF="ftp://ftp.cs.buffalo.edu/pub/sneps/">ftp.cs.buffalo.edu/pub/sneps/</A></LI>
</UL>
<P>The long-term goal of The SNePS Research Group is the design and
construction of a natural-language-using computerized cognitive
agent, and carrying out the research in artificial intelligence,
computational linguistics, and cognitive science necessary for
that endeavor. The three-part focus of the group is on knowledge
representation, reasoning, and natural-language understanding
and generation. The group is widely known for its development of
the SNePS knowledge representation/reasoning system, and Cassie,
its computerized cognitive agent.  
<P>
<P>
<P>
<P>
<A NAME="Soar"></A> <DT><B>Soar</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://bigfoot.eecs.umich.edu/~soar/">bigfoot.eecs.umich.edu/~soar/</A></LI>
<LI>FTP site: 
<A HREF="ftp://cs.cmu.edu/afs/cs/project/soar/public/Soar6/">cs.cmu.edu/afs/cs/project/soar/public/Soar6/</A></LI>
</UL>
<P>
<P>Soar has been developed to be a general cognitive architecture.
We intend ultimately to enable the Soar architecture to:
<UL>
<LI>work on the full range of tasks expected of an
intelligent agent, from highly routine to extremely difficult,
open-ended problems</LI>
<LI>represent and use appropriate forms of knowledge, such as
procedural, declarative, episodic, and possibly iconic</LI>
<LI>employ the full range of problem solving methods </LI>
<LI>interact with the outside world and </LI>
<LI>learn about all aspects of the tasks and its performance on them. </LI>
</UL>

In other words, our intention is for Soar to support all the
capabilities required of a general intelligent agent.
http://wwwis.cs.utwente.nl:8080/&nbsp;tcm/index.html
<P>
<P>
<A NAME="TCM"></A> <DT><B>TCM</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://wwwis.cs.utwente.nl:8080/~tcm/index.html">wwwis.cs.utwente.nl:8080/~tcm/index.html</A></LI>
<LI>FTP site: 
<A HREF="ftp://ftp.cs.vu.nl/pub/tcm/">ftp.cs.vu.nl/pub/tcm/</A></LI>
</UL>
<P>
<P>TCM (Toolkit for Conceptual Modeling) is our suite of graphical
editors. TCM contains graphical editors for Entity-Relationship
diagrams, Class-Relationship diagrams, Data and Event Flow
diagrams, State Transition diagrams, Jackson Process Structure
diagrams and System Network diagrams, Function Refinement trees
and various table editors, such as a Function-Entity table
editor and a Function Decomposition table editor.  TCM is easy
to use and performs numerous consistency checks, some of them
immediately, some of them upon request.
<P>
<P>
<P>
<A NAME="WEKA"></A> <DT><B>WEKA</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.cs.waikato.ac.nz/~ml/">lucy.cs.waikato.ac.nz/~ml/</A></LI>
</UL>
<P>
<P>WEKA (Waikato Environment for Knowledge Analysis) is an
state-of-the-art facility for applying machine learning
techniques to practical problems. It is a comprehensive software
"workbench" that allows people to analyse real-world data. It
integrates different machine learning tools within a common
framework and a uniform user interface. It is designed to
support a "simplicity-first" methodology, which allows users to
experiment interactively with simple machine learning tools
before looking for more complex solutions.
<P>
<P>
</DL>
<P>
<P>
<HR>
<A HREF="AI-Alife-HOWTO-3.html"><IMG SRC="../img/next.gif" ALT="Next"></A>
<A HREF="AI-Alife-HOWTO-1.html"><IMG SRC="../img/prev.gif" ALT="Previous"></A>
<A HREF="AI-Alife-HOWTO.html#toc2"><IMG SRC="../img/toc.gif" ALT="Contents"></A>
<SCRIPT>EndPage();</SCRIPT>  </BODY>
</HTML>
