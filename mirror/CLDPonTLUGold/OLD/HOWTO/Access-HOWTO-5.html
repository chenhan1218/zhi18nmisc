<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Linux Access HOWTO: Physical Problems</TITLE>
 <LINK HREF="Access-HOWTO-6.html" REL=next>
 <LINK HREF="Access-HOWTO-4.html" REL=previous>
 <LINK HREF="Access-HOWTO.html#toc5" REL=contents>
<SCRIPT src="../menu.js"> function BeginPage() {} function EndPage() {} </SCRIPT> </HEAD> <BODY bgcolor=#EEEEFF MARGINHEIGHT=0 MARGINWIDTH=0> <SCRIPT>BeginPage(1, 8, 1);</SCRIPT>
<A HREF="Access-HOWTO-6.html"><IMG SRC="../img/next.gif" ALT="Next"></A>
<A HREF="Access-HOWTO-4.html"><IMG SRC="../img/prev.gif" ALT="Previous"></A>
<A HREF="Access-HOWTO.html#toc5"><IMG SRC="../img/toc.gif" ALT="Contents"></A>
<HR>
<H2><A NAME="s5">5. Physical Problems</A></H2>

<P>Many of these problems have to be handled individually.  The needs
of the individual, the ways that they can generate input and other
factors vary so much that all that this HOWTO can provide is a general
set of pointers to useful software and expertise.
<P>
<H2><A NAME="ss5.1">5.1 Unable to Use a Mouse/Pointer</A>
</H2>

<P>Limited mobility can make it difficult to use a mouse.  For some
people a tracker ball can be a very good solution, but for others the
only possible input device is a keyboard (or even something which
simulates a keyboard).  For normal use of Linux this shouldn't be a
problem (but see the section 
<A HREF="#keyb-behave">Making the keyboard behave</A>), but for users of X, this may cause major problems
under some circumstances.
<P>Fortunately, the <CODE>fvwm</CODE> window manager has been designed for use
without a pointer and most things can be done using this.  I actually
do this myself when I lose my mouse (don't ask) or want to just keep
typing.  <CODE>fvwm</CODE> is included with all distributions of Linux that I
know of.  Actually using other programs will depend on their ability
to accept key presses.  Many X programs do this for all functions.
Many don't.  I sticky mouse keys, which are supposedly present in the
current release of X should make this easier.
<P>
<H3>Unable to Use a Keyboard</H3>

<P>People who are unable to use a keyboard normally can sometimes use
one through a headstick or a mouthstick.  This calls for special setup
of the keyboard.  Please see also the section 
<A HREF="#keyb-behave">Making the keyboard behave</A>.
<P>
<H3>Other Input Hardware (X Windows System only)</H3>

<P>For others, the keyboard cannot be used at all and only pointing
devices are available.  In this case, no solution is available under
the standard Linux Console and X will have to be used.  If the X-Input
extension can be taught to use the device and the correct software for
converting pointer input to characters can be found (I haven't seen it
yet) then any pointing should be usable without a keyboard.
<P>There are a number of devices worth considering for such input such as
touch screens and eye pointers.  Many of these will need a `device
driver' written for them.  This is not terribly difficult if the
documentation is available, but requires someone with good C
programming skills.  Please see the <I>Linux Kernel Hackers guide</I>
and other kernel reference materials for more information.  Once this
is set up, it should be possible to use these devices like a normal
mouse.
<P>
<H3>Controlling Physical Hardware From Linux</H3>

<P>The main group of interest here are the Linux Lab Project.
Generally, much GPIB (a standard interface to scientific equipment,
also known as the IEEE bus) hardware can be controlled.  This
potentially gives much potential for very ambitious accessibility
projects.  As far as I know none have yet been attempted.
<P>
<P>
<H2><A NAME="ss5.2">5.2 Speech Recognition</A>
</H2>

<P>Speech recognition is a very powerful tool for enabling computer
use.  There are two recognition systems that I know of for Linux, the
first is <CODE>ears</CODE> which is described as ``recognition is not optimal.
But it is fine for playing and will be improved'', the second is
<CODE>AbbotDemo</CODE> ``A speaker independent continuous speech recognition
system'' which may well be more interesting, though isn't available
for commercial use without prior arrangement.  See the Linux software
map for details (see section 
<A HREF="Access-HOWTO-7.html#linux-docs">other Linux documents</A>).
<P>
<H2><A NAME="keyb-behave"></A> <A NAME="ss5.3">5.3 Making the Keyboard Behave</A>
</H2>

<H3>X Window System.</H3>

<P>The latest X server which comes with Linux can include many
features which assist in input.  This includes such features as
StickKeys, MouseKeys, RepeatKeys, BounceKeys, SlowKeys, and TimeOut.
These allow customisation of the keyboard to the needs of the user.
These are provided as part of the <CODE>XKB</CODE>> extension in versions of X
after version 6.1.  To find out your version and see whether you have
the extension installed, you can try.
<P>
<PRE>
xdpyinfo -queryExtensions
</PRE>
<P>
<H3>Getting Rid of Auto Repeat</H3>

<P>To turn off key repeat on the Linux console run this command (I think
it has to be run once per console; a good place to run it would be in
your login files, <CODE>.profile</CODE> or <CODE>.login</CODE> in your home directory).
<P>
<PRE>
setterm -repeat off
</PRE>
<P>
<P>To get rid of auto repeat on any X server, you can use the command 
<P>
<PRE>
xset -r 
</PRE>
<P>
<P>which you could put into the file which get runs when you start using
X (often <CODE>.xsession</CODE> or <CODE>.xinit</CODE> under some setups)
<P>
<P>Both of these commands are worth looking at for more ways of changing
behaviour of the console.
<P>
<H3>Macros / Much input, few key presses</H3>

<P>Often in situations such as this, the biggest problem is speed of
input.  Here the most important thing to aim for is the most number of
commands with the fewest key presses.  For users of the shell
(<CODE>bash</CODE> / <CODE>tcsh</CODE>) you should look at the manual page, in
particular command and filename completion (press the tab key and bash
tries to guess what should come next).  For information on macros
which provide sequences of commands for just one key press, have a
look at the Keystroke HOWTO.
<P>
<H3><A NAME="sticky-key"></A> Sticky Keys</H3>

<P>Sticky keys are a feature that allow someone who can only reliably
press one button at a time to use a keyboard with all of the various
modifier keys such as shift and control.  These keys, instead of
having to be held on at the same time as the other key instead become
like the caps lock key and stay on while the other key is pressed.
They may then either switch off or stay on for the next key depending
on what is needed.  For information about how to set this up please
see the Linux Keyboard HOWTO, especially section `I can use only one
finger to type with' (section 15 in the version I have) for more
information on this.  - Information from Toby Reed.
<P>
<HR>
<A HREF="Access-HOWTO-6.html"><IMG SRC="../img/next.gif" ALT="Next"></A>
<A HREF="Access-HOWTO-4.html"><IMG SRC="../img/prev.gif" ALT="Previous"></A>
<A HREF="Access-HOWTO.html#toc5"><IMG SRC="../img/toc.gif" ALT="Contents"></A>
<SCRIPT>EndPage();</SCRIPT>  </BODY>
</HTML>
