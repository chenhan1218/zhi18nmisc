<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>GNU/Linux AI &amp; Alife HOWTO: Agents</TITLE>
 <LINK HREF="AI-Alife-HOWTO-7.html" REL=next>
 <LINK HREF="AI-Alife-HOWTO-5.html" REL=previous>
 <LINK HREF="AI-Alife-HOWTO.html#toc6" REL=contents>
<SCRIPT src="../menu.js"> function BeginPage() {} function EndPage() {} </SCRIPT> </HEAD> <BODY bgcolor=#EEEEFF MARGINHEIGHT=0 MARGINWIDTH=0> <SCRIPT>BeginPage(1, 8, 1);</SCRIPT>
<A HREF="AI-Alife-HOWTO-7.html"><IMG SRC="../img/next.gif" ALT="Next"></A>
<A HREF="AI-Alife-HOWTO-5.html"><IMG SRC="../img/prev.gif" ALT="Previous"></A>
<A HREF="AI-Alife-HOWTO.html#toc6"><IMG SRC="../img/toc.gif" ALT="Contents"></A>
<HR>
<H2><A NAME="s6">6. Agents</A>    </H2>

<P> 
Also known as intelligent software agents or just agents, this
area of AI research deals with simple applications of small
programs that aid the user in his/her work. They can be mobile
(able to stop their execution on one machine and resume it on
another) or static (live in one machine). They are usually
specific to the task (and therefore fairly simple) and meant
to help the user much as an assistant would. The most popular
(ie. widely known) use of this type of application to date are
the web robots that many of the indexing engines
(eg. webcrawler) use.
<P>
<P>
<DL>
<P>
<P>
<A NAME="AgentK"></A> <DT><B>AgentK</B><DD><P>
<UL>
<LI>FTP site: 
<A HREF="ftp://ftp.csd.abdn.ac.uk/pub/wdavies/agentk">ftp.csd.abdn.ac.uk/pub/wdavies/agentk</A></LI>
</UL>
<P>
<P>This package synthesizes two well-known agent paradigms:
Agent-Oriented Programming, Shoham (1990), and the Knowledge Query
&amp; Manipulation Language, Finin (1993). The initial implementation
of AOP, Agent-0, is a simple language for specifying agent
behaviour. KQML provides a standard language for inter-agent
communication. Our integration (which we have called Agent-K)
demonstrates that Agent-0 and KQML are highly compatible. Agent-K
provides the possibility of inter-operable (or open) software agents,
that can communicate via KQML and which are programmed using the AOP
approach.
<P>
<P>
<P>
<A NAME="Agent"></A> <DT><B>Agent</B><DD><P>
<UL>
<LI>FTP site: 
<A HREF="http://www.cpan.org/modules/by-category/23_Miscellaneous_Modules/Agent/">www.cpan.org/modules/by-category/23_Miscellaneous_Modules/Agent/</A></LI>
</UL>
<P>
<P>The Agent is a prototype for an Information Agent system. It is
both platform and language independent, as it stores contained
information in simple packed strings. It can be packed and shipped
across any network with any format, as it freezes itself in its
current state.
<P>
<P>
<A NAME="agentTool"></A> <DT><B>agentTool</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://en.afit.af.mil/ai/agentool.htm">en.afit.af.mil/ai/agentool.htm</A></LI>
<LI>Download site: 
<A HREF="http://en.afit.af.mil/ai/_vti_bin/shtml.dll/registration.htm">en.afit.af.mil/ai/_vti_bin/shtml.dll/registration.htm</A></LI>
</UL>
<P>Another Java based agent development framework. Fairly unique in that
it emphasizes the use of a GUI for designing the system which will
"semi-automatically synthesize multiagent systems to meet those
requirements". You need a java enabled browser to download. :P
<P>
<P>
<A NAME="Aglets"></A> <DT><B>Aglets Workbench</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.trl.ibm.co.jp/aglets/">www.trl.ibm.co.jp/aglets/</A></LI>
</UL>
<P>
<P>An aglet is a Java object that can move from one host on the
Internet to another.  That is, an aglet that executes on one host can
suddenly halt execution, dispatch to a remote host, and resume
execution there. When the aglet moves, it takes along its program code
as well as its state (data). A built-in security mechanism makes it
safe for a computer to host untrusted aglets. The Java Aglet API
(J-AAPI) is a proposed public standard for interfacing aglets and
their environment. J-AAPI contains methods for initializing an aglet,
message handling, and dispatching, retracting,
deactivating/activating, cloning, and disposing of the aglet. J-AAPI
is simple, flexible, and stable. Application developers can write
platform-independent aglets and expect them to run on any host that
supports J-AAPI.
<P>
<P>
<A NAME="A.L.I.C.E."></A> <DT><B>A.L.I.C.E.</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.alicebot.org/">www.alicebot.org</A></LI>
</UL>
<P>The ALICE software implements AIML (Artificial Intelligence Markup
Language), a non-standard evolving markup language for creating chat
robots. The primary design feature of AIML is minimalism. Compared with
other chat robot languages, AIML is perhaps the simplest. The pattern
matching language is very simple, for example permitting only one
wild-card ('*') match character per pattern. AIML is an XML language,
implying that it obeys certain grammatical meta-rules. The choice of
XML syntax permits integration with other tools such as XML editors.
Another motivation for XML is its familiar look and feel, especially to
people with HTML experience.  
<P>
<P>
<A NAME="Ara"></A> <DT><B>Ara</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://wwwagss.informatik.uni-kl.de/Projekte/Ara/index_e.html">wwwagss.informatik.uni-kl.de/Projekte/Ara/index_e.html</A></LI>
</UL>
<P>
<P>Ara is a platform for the portable and secure execution of
mobile agents in heterogeneous networks. Mobile agents in this
sense are programs with the ability to change their host machine
during execution while preserving their internal state. This
enables them to handle interactions locally which otherwise had
to be performed remotely. Ara's specific aim in comparison to
similar platforms is to provide full mobile agent functionality
while retaining as much as possible of established programming
models and languages.
<P>
<P>
<A NAME="BattleBots"></A> <DT><B>BattleBots</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.bluefire.nu/battlebots/">www.bluefire.nu/battlebots/</A></LI>
</UL>
<P>AI programming game where you design the bot by selecting hardware and
programming its CPU, then competing with other bots. Competitions can have
teams and special rules for a game. 
<P>The hardware for use in your bot includes weapons, engine, scanners, CPU,
etc. The programming lauguage is dependent on the CPU type and is similar
to an assembly language. 
<P>
<P>
<A NAME="Bee-gent"></A> <DT><B>Bee-gent</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www2.toshiba.co.jp/beegent/index.htm">www2.toshiba.co.jp/beegent/index.htm</A></LI>
</UL>
<P>Bee-gent is a new type of development framework in that it is a 100%
pure agent system. As opposed to other systems which make only some use
of agents, Bee-gent completely "Agentifies" the communication that
takes place between software applications. The applications become
agents, and all messages are carried by agents. Thus, Bee-gent allows
developers to build flexible open distributed systems that make optimal
use of existing applications.
<P>
<P>
<A NAME="Bond"></A> <DT><B>Bond</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://bond.cs.purdue.edu/">bond.cs.purdue.edu/</A></LI>
</UL>
<P>Yet another java agent system...
<P>Bond is a Java based distributed object system and agent framework. It
implements a message based middleware and associated services like
directory, persistence, monitoring and security. Bond allows to easily
build multi agent, distributed applications. Another application of
Bond will be a Virtual Laboratory supporting data annotation and
metacomputing. 
<P>
<P>
<A NAME="Bots"></A> <DT><B>Bots</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://utenti.tripod.it/Claudio1977/bots.html">utenti.tripod.it/Claudio1977/bots.html</A></LI>
</UL>
<P>Another AI-robot battle simulation.  Utilizing probablistic logic as a
machine learning technique.  Written in C++ (with C++ bots).
<P>
<P>
<A NAME="Cadaver"></A> <DT><B>Cadaver</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.erikyyy.de/cadaver/">www.erikyyy.de/cadaver/</A></LI>
</UL>
<P>Cadaver is a simulated world of cyborgs and nature in realtime.  The
battlefield consists of forests, grain, water, grass, carcass (of
course) and lots of other things. The game server manages the game and
the rules.  You start a server and connect some clients.  The clients
communicate with the server using a very primitive protocol.  They can
order cyborgs to harvest grain, attack enemies or cut forest.  The game
is not intended to be played by humans!  There is too much to control.
Only for die-hards: Just telnet to the server and you can enter
commands by hand.  Instead the idea is that you write artificial  
intelligence clients to beat the other artificial intelligences.  You
can choose a language (and operating system) of your choice to do that
task.  It is enough to write a program that communicates on standard
input and standard output channels.  Then you can use programs like
"socket" to connect your clients to the server.  It is NOT needed to
write TCP/IP code, although i did so :) The battle shall not be boring,
and so there is the so called spyboss client that displays the action
graphically on screen.
<P>
<P>
<A NAME="D'Agent"></A> <DT><B>D'Agent (was AGENT TCL)</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://agent.cs.dartmouth.edu/software/agent2.0/">agent.cs.dartmouth.edu/software/agent2.0/</A></LI>
<LI>FTP site: 
<A HREF="ftp://ftp.cs.dartmouth.edu/pub/agents/">ftp.cs.dartmouth.edu/pub/agents/</A></LI>
</UL>
<P>
<P>A transportable agent is a program that can migrate from machine
to machine in a heterogeneous network.  The program chooses when and
where to migrate.  It can suspend its execution at an arbitrary point,
transport to another machine and resume execution on the new machine.
For example, an agent carrying a mail message migrates first to a
router and then to the recipient's mailbox.  The agent can perform
arbitrarily complex processing at each machine in order to ensure that
the message reaches the intended recipient.
<P>
<P>
<A NAME="Dunce"></A> <DT><B>Dunce</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.boswa.com/boswabits/">www.boswa.com/boswabits/</A> </LI>
</UL>
<P>Dunce is a simple chatterbot (conversational AI) and a language for
programming such chatterbots. It uses a basic regex pattern matching
and a semi-neural rule/response firing mechanism (with excitement/decay
cycles).
<P>Dunce is listed about halfway down the page.
<P>
<P>
<A NAME="FIPA-OS"></A> <DT><B>FIPA-OS</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://fipa-os.sourceforge.net/">fipa-os.sourceforge.net</A></LI>
<LI>Secondary Web site: 
<A HREF="http://www.nortelnetworks.com/products/announcements/fipa/">www.nortelnetworks.com/products/announcements/fipa/</A></LI>
</UL>
<P>FIPA-OS is an open source implementation of the mandatory elements
contained within the FIPA specification for agent interoperability. In
addition to supporting the FIPA interoperability concepts, FIPA-OS also
provides a component based architecture to enable the development of
domain specific agents which can utilise the services of the FIPA
Platform agents. It is implemented in Java.
<P>
<P>
<A NAME="FishMarket"></A> <DT><B>FishMarket</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.iiia.csic.es/Projects/fishmarket/newindex.html">www.iiia.csic.es/Projects/fishmarket/</A></LI>
</UL>
<P>FM - The FishMarket project conducted at the Artificial Intelligence
Research Institute (IIIA-CSIC) attempts to contribute in that direction
by developing FM, an agent-mediated electronic auction house which has
been evolved into a test-bed for electronic auction markets. The
framework, conceived and implemented as an extension of FM96.5 (a
Java-based version of the Fishmarket auction house), allows to define
trading scenarios based on fish market auctions (Dutch auctions). FM
provides the framework wherein agent designers can perform controlled
experimentation in such a way that a multitude of experimental market
scenarios--that we regard as tournament scenarios due to the
competitive nature of the domain-- of varying degrees of realism and
complexity can be specified, activated, and recorded; and trading
(buyer and seller) heterogeneous (human and software) agents compared,
tuned and evaluated.
<P>
<P>
<A NAME="GNU Robots"></A> <DT><B>GNU Robots</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.gnu.org/software/robots/robots.html">www.gnu.org/software/robots/robots.html</A></LI>
</UL>
<P>GNU Robots is a game/diversion where you construct a program for a
little robot, then watch him explore a world. The world is
filled with baddies that can hurt you, objects that you can bump into,
and food that you can eat. The goal of the game is to collect as
many prizes as possible before are killed by a baddie or you run out of
energy. Robots can be written in Guile scheme or using a GUI.
<P>
<P>
<A NAME="Grasshopper"></A> <DT><B>Grasshopper</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.grasshopper.de/">www.grasshopper.de/</A></LI>
</UL>
<P>Another Java agent system. Full featured and actively developed.
Commercial, but free. Historically targeted at embedded systems.
<P>
<P>
<P>
<A NAME="Hive"></A> <DT><B>Hive</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://hive.sourceforge.net/">hive.sourceforge.net</A></LI>
<LI>Web site: 
<A HREF="http://www.hivecell.net/">www.hivecell.net</A></LI>
</UL>
<P>Hive is a Java software platform for creating distributed applications.
Using Hive, programmers can easily create systems that connect and use
data from all over the Internet. At its heart, Hive is an environment
for distributed agents to live, communicating and moving to fulfill
applications. We are trying to make the Internet alive.
<P>
<P>
<A NAME="ICM"></A> <DT><B>ICM</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.nar.fujitsulabs.com/icm/">www.nar.fujitsulabs.com/icm/</A></LI>
<LI>SourceForge site: 
<A HREF="http://sourceforge.net/projects/networkagent/">sourceforge.net/projects/networkagent/</A></LI>
</UL>
<P>The Inter-Agent Communication Model (ICM) is a communication mechanism
that can be used for sending messages between agents in an asynchronous
fashion. Its intended application area is as a transportation mechanism
for agent communication languages (ACLs), such as KQML and FIPA's ACL.  
<P>
<P>
<A NAME="Jacomma"></A> <DT><B>Jacomma</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://jacomma.sourceforge.net/">jacomma.sourceforge.net</A></LI>
<LI>SourceForge site: 
<A HREF="http://sourceforge.net/projects/jacomma/">sourceforge.net/projects/jacomma/</A></LI>
</UL>
<P>Jacomma is an agent development platform/framework for developing
distributed, mobile, and reactive information agents with heterogeneous
communication capabilities, in Java and JPython.
<P>Jacomma provides a development framework and an execution environment,
which sits on top of the Inter-Agent Communication Model
infrastructure. The ICM defines a communication protocol, a store and
forward messaging architecture, and low level communication
infrastructure for message exchange.  Communication is truly
asynchronous, based on TCP sockets.
<P>ICM has an entry in this howto, or you can find it via a link off the
site.
<P>
<P>
<P>
<A NAME="Jade"></A> <DT><B>Jade</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://sharon.cselt.it/projects/jade/">sharon.cselt.it/projects/jade/</A></LI>
</UL>
<P>JADE (Java Agent DEvelopment Framework) is a software framework fully
implemented in Java language. It simplifies the implementation of
multi-agent systems through a middle-ware that claims to comply with
the FIPA specifications and through a set of tools that supports the
debugging and deployment phase. The agent platform can be distributed
across machines (which not even need to share the same OS) and the
configuration can be controlled via a remote GUI. The configuration can
be even changed at run-time by moving agents from one machine to
another one, as and when required.
<P>
<P>
<P>
<A NAME="JAFMAS"></A> <DT><B>JAFMAS</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.ececs.uc.edu/~abaker/JAFMAS/">www.ececs.uc.edu/~abaker/JAFMAS</A></LI>
</UL>
<P>
<P>JAFMAS provides a framework to guide the coherent development of
multiagent systems along with a set of classes for agent
deployment in Java. The framework is intended to help beginning
and expert developers structure their ideas into concrete agent
applications. It directs development from a speech-act
perspective and supports multicast and directed communication,
KQML or other speech-act performatives and analysis of
multiagent system coherency and consistency.
<P>
<P>Only four of the provided Java classes must be extended for any
application. Provided examples of the N-Queens and Supply Chain
Integration use only 567 and 1276 lines of additional code
respectively for implementation.
<P>
<P>
<P>
<A NAME="JAM Agent"></A> <DT><B>JAM Agent</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://members.home.net/marcush/IRS/">members.home.net/marcush/IRS/</A></LI>
</UL>
<P>JAM supports both top-down, goal-based reasoning and bottom-up
data-driven reasoning. JAM selects goals and plans based on maximal
priority if metalevel reasoning is not used, or user-developed
metalevel reasoning plans if they exist. JAM's conceptualization of
goals and goal achievement is more classically defined (UMPRS is more
behavioral performance-based than truly goal-based) and makes the
distinction between plans to achieve goals and plans that simply encode
behaviors. Goal-types implemented include achievement (attain a
specified world state), maintenance (re-attain a specified world
state), and performance. Execution of multiple simultaneous goals are
supported, with suspension and resumption capabilities for each goal
(i.e., intention) thread. JAM plans have explicit precondition and
runtime attributes that restrict their applicability, a postcondition
attribute, and a plan attributes section for specifying 
plan/domain-specific plan features. Available plan constructs include:
sequencing, iteration, subgoaling, atomic (i.e., non-interruptable)
plan segments, n-branch deterministic and non-deterministic conditional
execution, parallel execution of multiple plan segments, goal-based or
world state-based synchronization, an explicit failure-handling
section, and Java primitive function definition through building it
into JAM as well as the invocation of predefined (i.e., legacy) class
members via Java's reflection capabilities without having to build it
into JAM.
<P>
<P>
<P>
<A NAME="JATLite"></A> <DT><B>JATLite</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://java.stanford.edu/java_agent/html/">java.stanford.edu/java_agent/html/</A></LI>
</UL>
<P>
<P>JATLite is providing a set of java packages which makes easy to
build multi-agent systems using Java. JATLite provides only
light-weight, small set of packages so that the developers can
handle all the packages with little efforts. For flexibility
JATLite provides four different layers from abstract to Router
implementation. A user can access any layer we are
providing. Each layer has a different set of assumptions. The
user can choose an appropriate layer according to the
assumptions on the layer and user's application. The
introduction page contains JATLite features and the set of
assumptions for each layer.
<P>
<P>
<P>
<A NAME="JATLiteBeans"></A> <DT><B>JATLiteBeans</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://waitaki.otago.ac.nz/JATLiteBean/">waitaki.otago.ac.nz/JATLiteBean/</A></LI>
</UL>
<P>
<UL>
<LI>Improved, easier-to-use interface to JATLite features
including KQML message parsing, receiving, and sending.
            </LI>
<LI>Extensible architecture for message handling and agent
"thread of control" management 
            </LI>
<LI>Useful functions for parsing of simple KQML message content
            </LI>
<LI>JATLiteBean supports automatic advertising of agent
capabilities to facilitator agents 
        </LI>
<LI>Automatic, optional, handling of the "forward" performative
        </LI>
<LI>Generic configuration file parser
        </LI>
<LI>KQML syntax checker
        </LI>
</UL>
<P>
<P>
<P>
<A NAME="Java Agent Template"></A> <DT><B>Java(tm) Agent Template</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://cdr.stanford.edu/ABE/JavaAgent.html">cdr.stanford.edu/ABE/JavaAgent.html</A></LI>
</UL>
<P>
<P>The JAT provides a fully functional template, written entirely in
the Java language, for constructing software agents which communicate
peer-to-peer with a community of other agents distributed over the
Internet. Although portions of the code which define each agent are
portable, JAT agents are not migratory but rather have a static
existence on a single host. This behavior is in contrast to many other
"agent" technologies. (However, using the Java RMI, JAT agents could
dynamically migrate to a foreign host via an agent resident on that
host).  Currently, all agent messages use KQML as a top-level protocol
or message wrapper. The JAT includes functionality for dynamically
exchanging "Resources", which can include Java classes (e.g. new
languages and interpreters, remote services, etc.), data files and
information inlined into the KQML messages.
<P>
<P>
<P>
<A NAME="Java-To-Go"></A> <DT><B>Java-To-Go</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://ptolemy.eecs.berkeley.edu/dgm/javatools/java-to-go/">ptolemy.eecs.berkeley.edu/dgm/javatools/java-to-go/</A></LI>
</UL>
<P>
<P>Java-To-Go is an experimental infrastructure that assists in the
development and experimentation of mobile agents and agent-based
applications for itinerative computing (itinerative computing:
the set of applications that requires site-to-site
computations. The main emphasis here is on a easy-to-setup
environment that promotes quick experimentation on mobile
agents.
<P>
<P>
<P>
<A NAME="Kafka"></A> <DT><B>Kafka</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.fujitsu.co.jp/hypertext/free/kafka/">www.fujitsu.co.jp/hypertext/free/kafka/</A></LI>
</UL>
<P>
<P>Kafka is yet another agent library designed for constructing
multi-agent based distributed applications. Kafka is a
flexible, extendable, and easy-to-use java class library for
programmers who are familiar with distributed programming. It
is based on Java's RMI and has the following added features:
<UL>
<LI>Runtime Reflection:
Agents can modify their behaviour (program codes) at
runtime. The behaviour of the agent is represented by an
abstract class Action. It is useful for remote maintenance or
installation services.</LI>
<LI>Remote Evaluation:
Agents can receive and evaluate program codes (classes)
with or without the serialized object. Remote evaluation is a
fundamental function of a mobile agent and is thought to be a
push model of service delivery.</LI>
<LI>Distributed Name Service:
Agents have any number of logical names that don't contain the host
name. These names can be managed by the distributed directories.</LI>
<LI>Customizable security policy:
a very flexible, customizable, 3-layered security model is
implemented in Kafka.</LI>
<LI>100% Java and RMI compatible:
Kafka is written completely in Java. Agent is a Java RMI
server object itself. So, agents can directly communicate with
other RMI objects.</LI>
</UL>
<P>
<P>
<P>
<A NAME="Khepera Sim"></A> <DT><B>Khepera Simulator</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://diwww.epfl.ch/lami/team/michel/khep-sim/index.html">diwww.epfl.ch/lami/team/michel/khep-sim/</A></LI>
</UL>
<P>
<P>Khepera Simulator is a public domain software package written by
<A HREF="http://diwww.epfl.ch/lami/team/michel/">Olivier MICHEL</A>
during the preparation of his Ph.D. thesis, at the Laboratoire I3S,
URA 1376 of CNRS and University of Nice-Sophia Antipolis, France. It
allows to write your own controller for the mobile robot Khepera using
C or C++ languages, to test them in a simulated environment and
features a nice colorful X11 graphical interface. Moreover, if you own
a Khepera robot, it can drive the real robot using the same control
algorithm. It is mainly oriented toward to researchers studying autonomous
agents.
<P>
<A NAME="lyntin"></A> <DT><B>lyntin</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://lyntin.sourceforge.net/">lyntin.sourceforge.net/</A></LI>
</UL>
<P>Lyntin is an extensible Mud client and framework for the creation of
autonomous agents, or bots, as well as mudding in general. Lyntin is
centered around Python, a dynamic, object-oriented, and fun programming
language and based on TinTin++ a lovely mud client.
<P>
<P>
<A NAME="Mole"></A> <DT><B>Mole</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://mole.informatik.uni-stuttgart.de/">mole.informatik.uni-stuttgart.de/</A></LI>
</UL>
<P>
<P>Mole is an agent system supporting mobile agents programmed in
Java.  Mole's agents consist of a cluster of objects, which have
no references to the outside, and as a whole work on tasks given
by the user or another agent. They have the ability to roam a
network of "locations" autonomously. These "locations" are an
abstraction of real, existing nodes in the underlying
network. They can use location-specific resources by
communicating with dedicated agents representing these
services. Agents are able to use services provided by other
agents and to provide services as well.
<P>
<P>
<A NAME="Narval"></A> <DT><B>Narval</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.logilab.org/">www.logilab.org</A></LI>
</UL>
<P>Narval is the acronym of "Network Assistant Reasoning with a Validating
Agent Language". It is a personal network assistant based on artificial
intelligence and agent technologies. It executes recipes (sequences of
actions) to perform tasks. It is easy to specify a new action using XML
and to implement it using Python.  Recipes can be built and debugged
using a graphical interface. 
<P>
<P>
<A NAME="NeL"></A> <DT><B>NeL</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.nevrax.org/">www.nevrax.org</A></LI>
</UL>
<P>NeL is actually a game development library (for massive multi-player
games), but I'm including it here as it (will) include a fairly 
sizable AI library. Here's a blurb from the whitepaper:
<P>The purpose of the AI library is to provide a pragmatic approach to
creating a distributed agents platform. Its focus is agents; individual
entities that communicate regardless of location, using an
action-reaction model. 
<P>
<P>
<A NAME="PAI"></A> <DT><B>PAI</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://utenti.tripod.it/Claudio1977/pai.html">utenti.tripod.it/Claudio1977/pai.html</A></LI>
</UL>
<P>AI (Programmable Artificial Intelligence) is a program capable of
having a conversation in its mother tongue, English. Written in 
C++.
<P>
<P>
<A NAME="Penguin!"></A> <DT><B>Penguin!</B><DD><P>
<UL>
<LI>FTP site: 
<A HREF="http://www.perl.org/CPAN/modules/by-category/23_Miscellaneous_Modules/Penguin/FSG/">www.perl.org/CPAN/modules/by-category/23_Miscellaneous_Modules/Penguin/FSG/</A></LI>
</UL>
<P>
<P>Penguin is a Perl 5 module. It provides you with a set of functions which
allow you to:
<UL>
<LI>send encrypted, digitally signed Perl code to a remote machine to be
executed.</LI>
<LI>receive code and, depending on who signed it, execute it in an
arbitrarily secure, limited compartment.</LI>
</UL>

The combination of these functions enable direct Perl coding of
algorithms to handle safe internet commerce, mobile
information-gathering agents, "live content" web browser helper
apps, distributed load-balanced computation, remote software
update, distance machine administration, content-based
information propagation, Internet-wide shared-data applications,
network application builders, and so on.
<P>
<P>
<A NAME="Ps-i"></A> <DT><B>Ps-i</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://ps-i.sourceforge.net/">ps-i.sourceforge.net</A></LI>
</UL>
<P>Ps-i is an environment for running agent-based simulations. It is
cross-platform, with binaries available for Win32. Features include: 
<P>
<UL>
<LI>declarative language for model specification</LI>
<LI>industry standard Tcl/Tk scripting
with built-in routine optimization, speculative evaluation
and xf86 JIT compiler users can create complex models without
sacrificing perfomance </LI>
<LI>user friendly interface </LI>
<LI>save and restore program runs </LI>
<LI>change model parameters on the fly </LI>
<LI>data visualization: field display with multiple agent shapes and
color, statistics window, agent viewer, routine browser and
highlight agents tool </LI>
</UL>
<P>
<P>
<A NAME="RealTimeBattle"></A> <DT><B>RealTimeBattle</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.lysator.liu.se/realtimebattle/">www.lysator.liu.se/realtimebattle/</A></LI>
</UL>
<P>RealTimeBattle is a programming game, in which robots controlled by 
programs are fighting each other. The goal is to destroy the enemies, 
using the radar to examine the environment and the cannon to shoot. 
<P>
<UL>
<LI>Game progresses in real time, with the robot programs 
running as child processes to RealTimeBattle.</LI>
<LI>The robots communicate with the main program using the 
standard input and output.</LI>
<LI>Robots can be constructed in almost any programming language.</LI>
<LI>Maximum number of robots can compete simultaneously.</LI>
<LI>A simple messaging language is used for communication, which
makes it easy to start constructing robots.</LI>
<LI>Robots behave like real physical object.</LI>
<LI>You can create your own arenas.</LI>
<LI>Highly configurable.</LI>
</UL>
<P>
<P>
<P>
<A NAME="Remembrance Agents"></A> <DT><B>Remembrance Agents</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://rhodes.www.media.mit.edu/people/rhodes/RA/">rhodes.www.media.mit.edu/people/rhodes/RA/</A></LI>
</UL>
<P>Remembrance Agents are a set of applications that watch over a user's
shoulder and suggest information relevant to the current situation.
While query-based memory aids help with direct recall, remembrance
agents are an augmented associative memory.  For example, the
word-processor version of the RA continuously updates a list of
documents relevant to what's being typed or read in an emacs buffer.
These suggested documents can be any text files that might be relevant
to what you are currently writing or reading.  They might be old emails
related to the mail you are currently reading, or abstracts from papers
and newspaper articles that discuss the topic of your writing.
<P>
<P>
<P>
<A NAME="SimRobot"></A> <DT><B>SimRobot</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.informatik.uni-bremen.de/~simrobot/">www.informatik.uni-bremen.de/~simrobot/</A> </LI>
<LI>FTP site: 
<A HREF="ftp://ftp.uni-bremen.de/pub/ZKW/INFORM/simrobot/">ftp.uni-bremen.de/pub/ZKW/INFORM/simrobot/</A></LI>
</UL>
<P>
<P>SimRobot is a program for simulation of sensor based robots in a
3D environment. It is written in C++, runs under UNIX and X11 and
needs the graphics toolkit XView.
<UL>
<LI>Simulation of robot kinematics</LI>
<LI>Hierarchically built scene definition via a simple definition
language</LI>
<LI>Various sensors built in: camera, facette eye, distance 
measurement, light sensor, etc.</LI>
<LI>Objects defined as polyeders</LI>
<LI>Emitter abstractly defined; can be interpreted e.g. as
light or sound</LI>
<LI>Camera images computed according to the raytracing or
Z-buffer algorithms known from computer graphics</LI>
<LI>Specific sensor/motor software interface for communicating 
with the simulation</LI>
<LI>Texture mapping onto the object surfaces: bitmaps in various 
formats</LI>
<LI>Comprehensive visualization of the scene: wire frame w/o
hidden lines, sensor and actor values</LI>
<LI>Interactive as well as batch driven control of the agents
and operation in the environment</LI>
<LI>Collision detection</LI>
<LI>Extendability with user defined object types</LI>
<LI>Possible socket communication to e.g. the Khoros image 
processing software</LI>
</UL>
<P>
<P>
<P>
<A NAME="Sulawesi"></A> <DT><B>Sulawesi</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://wearables.essex.ac.uk/sulawesi/">wearables.essex.ac.uk/sulawesi/</A></LI>
</UL>
<P>A framework called Sulawesi has been designed and implemented to
tackle what has been considered to be important challenges in a
wearable user interface. The ability to accept input from any 
number of modalities, and perform if necessary a translation to any
number of modal outputs. It does this primarily through a set
of proactive agents to act on the input.
<P>
<P>
<P>
<A NAME="TclRobots"></A> <DT><B>TclRobots</B><DD><P>
<UL>
<LI>FTP site: 
<A HREF="ftp://ftp.neosoft.com/pub/tcl/sorted/games/tclrobots-2.0/">ftp.neosoft.com/pub/tcl/sorted/games/tclrobots-2.0/</A></LI>
<LI>Redhat Patch: 
<A HREF="ftp://ftp.coe.uga.edu/users/jae/ai/tclrobots-redhat.patch">ftp.coe.uga.edu/users/jae/ai/tclrobots-redhat.patch</A></LI>
<LI>RPMs (search at): 
<A HREF="http://rufus.w3.org/">http://rufus.w3.org/</A></LI>
</UL>
<P>
<P>TclRobots is a programming game, similar to 'Core War'.  To play
TclRobots, you must write a Tcl program that controls a robot.  The
robot's mission is to survive a battle with other robots.  Two, three,
or four robots compete during a battle, each running different
programs (or possibly the same program in different robots.)  Each
robot is equipped with a scanner, cannon, drive mechanism.  A single
match continues until one robot is left running.  Robots may compete
individually, or combine in a team oriented battle.  A tournament
can be run with any number of robot programs, each robot playing every
other in a round-robin fashion, one-on-one.  A battle simulator is
available to help debug robot programs.
<P>
<P>The TclRobots program provides a physical environment, imposing
certain game parameters to which all robots must adhere.  TclRobots
also provides a view on a battle, and a controlling user interface.
TclRobots requirements: a wish interpreter built from Tcl 7.4 and Tk
4.0.
<P>
<P>
<P>
<A NAME="TKQML"></A> <DT><B>TKQML</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.csee.umbc.edu/tkqml/">www.csee.umbc.edu/tkqml/</A> </LI>
</UL>
<P>TKQML is a KQML application/addition to Tcl/Tk, which allows Tcl
based systems to communicate easily with a powerful agent
communication language.
<P>
<P>
<P>
<A NAME="Tocoma Project"></A> <DT><B>The Tocoma Project</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.tacoma.cs.uit.no/">www.tacoma.cs.uit.no/</A></LI>
</UL>
<P>
<P>An agent is a process that may migrate through a computer network
in order to satisfy requests made by clients. Agents are an attractive
way to describe network-wide computations.
<P>
<P>The TACOMA project focuses on operating system support for agents and
how agents can be used to solve problems traditionally addressed by
operating systems. We have implemented a series of prototype systems
to support agents.
<P>
<P>TACOMA Version 1.2 is based on UNIX and TCP. The system supports
agents written in C, Tcl/Tk, Perl, Python, and Scheme (Elk). It is
implemented in C. This TACOMA version has been in public domain since
April 1996.
<P>
<P>We are currently focusing on heterogeneity, fault-tolerance, security
and management issues. Also, several TACOMA applications are under
construction. We implemented StormCast 4.0, a wide-area network
weather monitoring system accessible over the internet, using TACOMA
and Java. We are now in the process of evaluating this application,
and plan to build a new StormCast version to be completed by June
1997.
<P>
<P>
<A NAME="Ummon"></A> <DT><B>Ummon</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.spacetide.com/projects/ummon/">www.spacetide.com/projects/ummon/</A></LI>
</UL>
<P>Ummon is an advanced Open Source chatterbot. The main principle of the
bot is that it has no initial knowledge of either words or grammar; it
learns everything "on the fly." Numerous AI techniques will be explored
in the development of Ummon to achieve realistic "human" communication
with support for different, customizable personalities.
<P>
<P>
<P>
<A NAME="UMPRS Agent"></A> <DT><B>UMPRS Agent</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://members.home.net/marcush/IRS/">members.home.net/marcush/IRS/</A></LI>
</UL>
<P>UMPRS supports top-down, goal-based reasoning and selects goals and
plans based on maximal priority. Execution of multiple simultaneous
goals are supported, with suspension and resumption capabilities for
each goal (i.e., intention) thread. UMPRS plans have an integrated
precondition/runtime attribute that constrain their applicability.
Available plan constructs include: sequencing, iteration, subgoaling,
atomic (i.e., non-interruptable) blocks, n-branch deterministic
conditional execution, explicit failure-handling section, and C++
primitive function definition.
<P>
<P>
<P>
<A NAME="ViSe"></A> <DT><B>Virtual Secretary Project (ViSe)</B><DD><P>(Tcl/Tk)  
<UL>
<LI>Web site: 
<A HREF="http://www.cs.uit.no/DOS/Virt_Sec/">www.cs.uit.no/DOS/Virt_Sec</A></LI>
</UL>
<P>
<P>The motivation of the Virtual Secretary project is to construct
user-model-based intelligent software agents, which could in
most cases replace human for secretarial tasks, based on modern
mobile computing and computer network. The project includes two
different phases: the first phase (ViSe1) focuses on information
filtering and process migration, its goal is to create a secure
environment for software agents using the concept of user
models; the second phase (ViSe2) concentrates on agents'
intelligent and efficient cooperation in a distributed
environment, its goal is to construct cooperative agents for
achieving high intelligence. (Implemented in Tcl/TclX/Tix/Tk)
<P>
<P>
<P>
<P>
<A NAME="VWORLD"></A> <DT><B>VWORLD</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://zhar.net/projects/vworld/">zhar.net/projects/vworld/</A></LI>
</UL>
<P>
<P>Vworld is a simulated environment for research with autonomous
agents written in prolog. It is currently in something of an
beta stage. It works well with SWI-prolog, but should work with
Quitnus-prolog with only a few changes.  It is being designed to
serve as an educational tool for class projects dealing with
prolog and autonomous agents. It comes with three demo worlds or
environments, along with sample agents for them. There are
two versions now. One written for SWI-prolog and one written for
LPA-prolog. Documentation is roughly done (with a
student/professor framework in mind), and a graphical interface
is planned.
<P>
<P>
<P>
<A NAME="WebMate"></A> <DT><B>WebMate</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.cs.cmu.edu/~softagents/webmate/">www.cs.cmu.edu/~softagents/webmate/</A></LI>
</UL>
<P>
<P>WebMate is a personal agent for World-Wide Web browsing and
searching. It accompanies you when you travel on the internet
and provides you what you want. 
<P>Features include:
<UL>
<LI>Searching enhancement, including parallel search, searching
keywords refinement using our relevant keywords extraction technology,
relevant feedback, etc.
</LI>
<LI>Browsing assistant, including learning your current interesting,
recommending you new URLs according to your profile and selected
resources, monitoring bookmarks of Netscape or IE, sending the current
browsing page to your friends, etc.
</LI>
<LI>Offline browsing, including downloading the following pages from
the current page for offline browsing.
</LI>
<LI>Filtering HTTP header, including recording http header and all
the transactions between your browser and WWW servers, etc.
</LI>
<LI>Checking the HTML page to find the errors or dead links,  etc.
</LI>
<LI>Programming in Java, independent of operating system, runing in
multi-thread.
</LI>
</UL>
<P>
<P>
<P>
<A NAME="Zeus"></A> <DT><B>Zeus</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.labs.bt.com/projects/agents/zeus/">www.labs.bt.com/projects/agents/zeus/</A></LI>
</UL>
<P>The construction of multi-agent systems involves long development
times and requires solutions to some considerable technical 
difficulties. This has motivated the development of the ZEUS
toolkit, which provides a library of software components and tools
that facilitate the rapid design, development and deployment of 
agent system
<P>
<P>
<P>
</DL>
<P>
<HR>
<A HREF="AI-Alife-HOWTO-7.html"><IMG SRC="../img/next.gif" ALT="Next"></A>
<A HREF="AI-Alife-HOWTO-5.html"><IMG SRC="../img/prev.gif" ALT="Previous"></A>
<A HREF="AI-Alife-HOWTO.html#toc6"><IMG SRC="../img/toc.gif" ALT="Contents"></A>
<SCRIPT>EndPage();</SCRIPT>  </BODY>
</HTML>
