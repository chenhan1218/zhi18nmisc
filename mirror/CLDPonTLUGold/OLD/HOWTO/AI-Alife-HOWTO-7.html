<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>GNU/Linux AI &amp; Alife HOWTO: Programming languages</TITLE>
 <LINK HREF="AI-Alife-HOWTO-6.html" REL=previous>
 <LINK HREF="AI-Alife-HOWTO.html#toc7" REL=contents>
<SCRIPT src="../menu.js"> function BeginPage() {} function EndPage() {} </SCRIPT> </HEAD> <BODY bgcolor=#EEEEFF MARGINHEIGHT=0 MARGINWIDTH=0> <SCRIPT>BeginPage(1, 8, 1);</SCRIPT>
<IMG SRC="../img/next.gif" ALT="Next">
<A HREF="AI-Alife-HOWTO-6.html"><IMG SRC="../img/prev.gif" ALT="Previous"></A>
<A HREF="AI-Alife-HOWTO.html#toc7"><IMG SRC="../img/toc.gif" ALT="Contents"></A>
<HR>
<H2><A NAME="s7">7. Programming languages</A>    </H2>

<P>
<P>While any programming language can be used for artificial
intelligence/life research, these are programming languages which
are used extensively for, if not specifically made for, artificial
intelligence programming.  
<P>
<P>
<DL>
<P>
<P>
<A NAME="Allegro CL"></A> <DT><B>Allegro CL</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.franz.com/">www.franz.com</A></LI>
</UL>
<P>Franz Inc's free linux version of their lisp development
environment. You can download it or they will mail you a
CD free (you don't even have to pay for shipping). It is
generally considered to be one of the better lisp platforms.
<P>
<P>
<A NAME="APRIL"></A> <DT><B>APRIL</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://sourceforge.net/project/networkagent/">sourceforge.net/project/networkagent/</A></LI>
</UL>
<P>APRIL is a symbolic programming language that is designed for writing
mobile, distributed and agent-based systems especially in an Internet
environment. It has advanced features such as a macro sub-language,
asynchronous message sending and receiving, code mobility, pattern
matching, higher-order functions and strong typing. The language is
compiled to byte-code which is then interpreted by the APRIL
runtime-engine.  APRIL now requires the InterAgent Communications Model
(ICM) to be installed before it can be installed. [Ed. ICM can be found
at the same web site]
<P>
<P>
<A NAME="B-Prolog"></A> <DT><B>B-Prolog</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.sci.brooklyn.cuny.edu/~zhou/bprolog.html">www.sci.brooklyn.cuny.edu/~zhou/bprolog.html</A></LI>
<LI>Web site: 
<A HREF="http://www.cad.mse.kyutech.ac.jp/people/zhou/bprolog.html">www.cad.mse.kyutech.ac.jp/people/zhou/bprolog.html</A></LI>
</UL>
<P>B-Prolog is a compact and complete CLP system that runs Prolog and 
CLP(FD) programs. An emulator-based system, B-Prolog has a performance
comparable with SICStus-Prolog.
<P>
<UL>
<LI>In addition to Edinburgh-style programs, B-Prolog accepts 
canonical-form programs that can be compiled into more compact
and faster code than standard Prolog programs.  </LI>
<LI>B-Prolog includes an interpreter and provides an interactive
interface through which users can consult, list, compile, load, 
debug and run programs. The command editor facilitates reuse   
old commands. </LI>
<LI>B-Prolog provides a bi-directional interface with C and Java.>
resources in C and Java such as Graphics and sockets, and also 
makes it possible for a Prolog program to be embadded in a C
and Java applications. </LI>
<LI>B-Prolog supports most of the built-ins in ISO Prolog. </LI>
<LI>B-Prolog supports the delaying (co-routining) mechanism,    
which can be used to implement concurrency, test-and-generate
search algorithms, and most importantly constraint propagation 
algorithms. </LI>
<LI>B-Prolog has an efficient constraint compiler for constraints>
over finite-domains and Booleans. </LI>
<LI>B-Prolog supports the tabling mechanism, which has proven 
effective for applications including parsing, problem solving, 
theorem proving, and deductive databases.</LI>
</UL>
 
<P>
<P>
<A NAME="Ciao Prolog"></A> <DT><B>Ciao Prolog</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.clip.dia.fi.upm.es/Software/Ciao/">www.clip.dia.fi.upm.es/Software/Ciao/</A></LI>
</UL>
<P>Ciao is a complete Prolog system subsuming ISO-Prolog with a novel
modular design which allows both restricting and extending the
language. Ciao extensions currently include feature terms (records),
higher-order, functions, constraints, objects, persistent predicates, a
good base for distributed execution (agents), and concurrency.
Libraries also support WWW programming, sockets, and external
interfaces (C, Java, TCL/Tk, relational databases, etc.). An
Emacs-based environment, a stand-alone compiler, and a toplevel shell
are also provided.
<P>
<P>
<P>
<A NAME="DHARMI"></A> <DT><B>DHARMI</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://megazone.bigpanda.com/~wolf/DHARMI/">http://megazone.bigpanda.com/~wolf/DHARMI/</A></LI>
</UL>
<P>DHARMI is a high level spatial, tinker-toy like language who's
components are transparently administered by a background
process called the Habitat. As the name suggests, the language
was designed to make modelling prototypes and handle living
data. Programs can be modified while running. This is accomplished
by blurring the distinction between source code, program,
and data.
<P>
<P>
<P>
<A NAME="ECoLisp"></A> <DT><B>ECoLisp</B><DD><P>
<UL>
<LI>Web site (???): 
<A HREF="http://www.di.unipi.it/~attardi/software.html">www.di.unipi.it/~attardi/software.html</A></LI>
</UL>
<P>
<P>ECoLisp (Embeddable Common Lisp) is an implementation of
Common Lisp designed for being embeddable into C based
applications. ECL uses standard C calling conventions for Lisp
compiled functions, which allows C programs to easily call
Lisp functions and viceversa. No foreign function interface is
required: data can be exchanged between C and Lisp with no
need for conversion. ECL is based on a Common Runtime Support
(CRS) which provides basic facilities for memory managment,
dynamic loading and dumping of binary images, support for
multiple threads of execution. The CRS is built into a library
that can be linked with the code of the application. ECL is
modular: main modules are the program development tools (top
level, debugger, trace, stepper), the compiler, and CLOS. A
native implementation of CLOS is available in ECL: one can
configure ECL with or without CLOS. A runtime version of ECL
can be built with just the modules which are required by the
application. The ECL compiler compiles from Lisp to C, and
then invokes the GCC compiler to produce binaries.
<P>
<P>
<P>
<A NAME="ESTEREL"></A> <DT><B>ESTEREL</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www-sop.inria.fr/meije/esterel/">www-sop.inria.fr/meije/esterel/</A></LI>
</UL>
<P>Esterel is both a programming language, dedicated to programming
reactive systems, and a compiler which translates Esterel programs into
finite-state machines. It is particularly well-suited to programming
reactive systems, including real-time systems and control automata.
<P>Only the binary is available for the language compiler. :P
<P>
<P>
<P>
<A NAME="Godel"></A> <DT><B>G&ouml;del</B><DD><P>
<UL>
<LI>Web page: 
<A HREF="http://www.cs.bris.ac.uk/~bowers/goedel.html">www.cs.bris.ac.uk/~bowers/goedel.html</A></LI>
</UL>
<P>G&ouml;del is a declarative, general-purpose programming language
in the family of logic programming languages.  It is a strongly typed
language, the type system being based on many-sorted logic with
parametric polymorphism.  It has a module system.  G&ouml;del supports
infinite precision integers, infinite precision rationals, and also
floating-point numbers.  It can solve constraints over finite domains
of integers and also linear rational constraints. It supports
processing of finite sets.  It also has a flexible computation rule
and a pruning operator which generalizes the commit of the concurrent
logic programming languages.  Considerable emphasis is placed on
G&ouml;del's meta- logical facilities which provide significant
support for meta-programs that do analysis, transformation,
compilation, verification, debugging, and so on.
<P>
<P>
<P>
<P>
<A NAME="LIFE"></A> <DT><B>LIFE</B><DD><P>
<UL>
<LI>Web page: 
<A HREF="http://www.isg.sfu.ca/life">www.isg.sfu.ca/life</A></LI>
</UL>
<P>LIFE (Logic, Inheritance, Functions, and Equations) is an
experimental programming language proposing to integrate three
orthogonal programming paradigms proven useful for symbolic
computation.  From the programmer's standpoint, it may be perceived as
a language taking after logic programming, functional programming, and
object-oriented programming.  From a formal perspective, it may be
seen as an instance (or rather, a composition of three instances) of a
Constraint Logic Programming scheme due to Hoehfeld and Smolka
refining that of Jaffar and Lassez.
<P>
<P>
<P>
<P>
<A NAME="CLisp"></A> <DT><B>CLisp (Lisp)</B><DD><P>
<UL>
<LI>Web page: 
<A HREF="http://clisp.sourceforge.net/">clisp.sourceforge.net</A></LI>
<LI>FTP site: 
<A HREF="ftp://clisp.cons.org/pub/lisp/clisp/source/">clisp.cons.org/pub/lisp/clisp/source</A></LI>
</UL>
<P>CLISP is a Common Lisp implementation by Bruno Haible and Michael
Stoll.  It mostly supports the Lisp described by 
<A HREF="http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/cltl2.html">Common LISP: The Language (2nd edition)</A>
and the ANSI Common Lisp
standard.  CLISP includes an interpreter, a byte-compiler, a large
subset of CLOS (Object-Oriented Lisp) , a foreign language interface
and, for some machines, a screen editor.
<P>
<P>The user interface language (English, German, French) is chosen at
run time.  Major packages that run in CLISP include CLX &amp; Garnet.
CLISP needs only 2 MB of memory.
<P>
<P>
<A NAME="CMU CL"></A> <DT><B>CMU Common Lisp</B><DD><P>
<UL>
<LI>Web page: 
<A HREF="http://www.cons.org/cmucl/">www.cons.org/cmucl/</A></LI>
<LI>Old Web page: 
<A HREF="http://www.mv.com/users/pw/lisp/index.html">www.mv.com/users/pw/lisp/index.html</A></LI>
<LI>FTP site: 
<A HREF="ftp://ftp2.cons.org/pub/languages/lisp/cmucl/release/">ftp2.cons.org/pub/languages/lisp/cmucl/release/</A></LI>
<LI>Linux Installation: 
<A HREF="http://www.telent.net/lisp/howto.html">www.telent.net/lisp/howto.html</A></LI>
</UL>
<P>
<P>CMU Common Lisp is a public domain "industrial strength" Common
Lisp programming environment. Many of the X3j13 changes have been
incorporated into CMU CL. Wherever possible, this has been done so as
to transparently allow the use of either CLtL1 or proposed ANSI
CL. Probably the new features most interesting to users are SETF
functions, LOOP and the WITH-COMPILATION-UNIT macro.
<P>
<P>
<P>
<A NAME="Gnu-CL"></A> <DT><B>GCL (Lisp)</B><DD><P>
<UL>
<LI>FTP site: 
<A HREF="ftp://ftp.ma.utexas.edu/pub/gcl/">ftp.ma.utexas.edu/pub/gcl/</A></LI>
</UL>
<P>
<P>GNU Common Lisp (GCL) has a compiler and interpreter for Common
Lisp.  It used to be known as Kyoto Common Lisp.  It is very portable
and extremely efficient on a wide class of applications.  It compares
favorably in performance with commercial Lisps on several large
theorem-prover and symbolic algebra systems. It supports the CLtL1
specification but is moving towards the proposed ANSI definition.  GCL
compiles to C and then uses the native optimizing C compilers (e.g.,
GCC).  A function with a fixed number of args and one value turns into
a C function of the same number of args, returning one value, so GCL
is maximally efficient on such calls.  It has a conservative garbage
collector which allows great freedom for the C compiler to put Lisp
values in arbitrary registers.
<P>
<P>It has a source level Lisp debugger for interpreted code, with display
of source code in an Emacs window.  Its profiling tools (based on the
C profiling tools) count function calls and the time spent in each
function.  
<P>
<P>
<A NAME="GNU Prolog"></A> <DT><B>GNU Prolog</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://pauillac.inria.fr/~diaz/gnu-prolog/">pauillac.inria.fr/~diaz/gnu-prolog/</A></LI>
<LI>Web site: 
<A HREF="http://www.gnu.org/software/prolog/prolog.html">www.gnu.org/software/prolog/prolog.html</A></LI>
</UL>
<P>
<P>GNU Prolog is a free Prolog compiler with constraint solving over
finite domains developed by Daniel Diaz.
<P>GNU Prolog accepts Prolog+constraint programs and produces native
binaries (like gcc does from a C source). The obtained executable is
then stand-alone. The size of this executable can be quite small since
GNU Prolog can avoid to link the code of most unused built-in
predicates. The performances of GNU Prolog are very encouraging
(comparable to commercial systems). 
<P>Beside the native-code compilation, GNU Prolog offers a classical
interactive interpreter (top-level) with a debugger.
<P>The Prolog part conforms to the ISO standard for Prolog with many
extensions very useful in practice (global variables, OS interface,
sockets,...). 
<P>GNU Prolog also includes an efficient constraint solver over Finite
Domains (FD). This opens contraint logic pogramming to the user
combining the power of constraint programming to the declarativity of
logic programming.
<P>
<P>
<P>
<A NAME="Mercury"></A> <DT><B>Mercury</B><DD><P>
<UL>
<LI>Web page: 
<A HREF="http://www.cs.mu.oz.au/research/mercury/">www.cs.mu.oz.au/research/mercury/</A></LI>
</UL>
<P>
<P>Mercury is a new, purely declarative logic programming language.
Like Prolog and other existing logic programming languages, it is a
very high-level language that allows programmers to concentrate on the
problem rather than the low-level details such as memory management.
Unlike Prolog, which is oriented towards exploratory programming,
Mercury is designed for the construction of large, reliable, efficient
software systems by teams of programmers. As a consequence,
programming in Mercury has a different flavor than programming in
Prolog.
<P>
<P>
<P>
<P>
<A NAME="Mozart"></A> <DT><B>Mozart</B><DD><P>
<UL>
<LI>Web page: 
<A HREF="http://www.mozart-oz.org/">www.mozart-oz.org/</A></LI>
</UL>
<P>
<P>The Mozart system provides state-of-the-art support in two areas: open
distributed computing and constraint-based inference. Mozart implements
Oz, a concurrent object-oriented language with dataflow synchronization.
Oz combines concurrent and distributed programming with logical
constraint-based inference, making it a unique choice for developing
multi-agent systems. Mozart is an ideal platform for both general-purpose
distributed applications as well as for hard problems requiring
sophisticated optimization and inferencing abilities. We have developed
applications in scheduling and time-tabling, in placement and
configuration, in natural language and knowledge representation,
multi-agent systems and sophisticated collaborative tools.      
<P>
<P>
<P>
<A NAME="SWI Prolog"></A> <DT><B>SWI Prolog</B><DD><P>
<UL>
<LI>Web page: 
<A HREF="http://www.swi.psy.uva.nl/projects/SWI-Prolog/">www.swi.psy.uva.nl/projects/SWI-Prolog/</A></LI>
<LI>FTP site: 
<A HREF="ftp://swi.psy.uva.nl/pub/SWI-Prolog/">swi.psy.uva.nl/pub/SWI-Prolog/</A></LI>
</UL>
<P>
<P>SWI is a free version of prolog in the Edinburgh Prolog family
(thus making it very similar to Quintus and many other versions).
With: a large library of built in predicates, a module system, garbage
collection, a two-way interface with the C language, plus many other
features. It is meant as a educational language, so it's compiled code
isn't the fastest. Although it similarity to Quintus allows for easy
porting.
<P>
<P>XPCE is freely available in binary form for the Linux version of SWI-prolog.
XPCE is an object oriented X-windows GUI development package/environment.
<P>
<P>
<A NAME="Kali Scheme"></A> <DT><B>Kali Scheme</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.neci.nj.nec.com/PLS/Kali.html">www.neci.nj.nec.com/PLS/Kali.html</A></LI>
</UL>
<P>
<P>Kali Scheme is a distributed implementation of Scheme that
permits efficient transmission of higher-order objects such as
closures and continuations. The integration of distributed
communication facilities within a higher-order programming
language engenders a number of new abstractions and paradigms
for distributed computing. Among these are user-specified
load-balancing and migration policies for threads,
incrementally-linked distributed computations, agents, and
parameterized client-server applications. Kali Scheme supports
concurrency and communication using first-class procedures and
continuations. It integrates procedures and continuations into a
message-based distributed framework that allows any Scheme
object (including code vectors) to be sent and received in a
message.
<P>
<P>
<P>
<A NAME="RScheme"></A> <DT><B>RScheme</B><DD><P>
<UL>
<LI>Web site:
<A HREF="http://www.rscheme.org/">www.rscheme.org</A></LI>
<LI>FTP site: 
<A HREF="ftp://ftp.rscheme.org/pub/rscheme/">ftp.rscheme.org/pub/rscheme/</A></LI>
</UL>
<P>
<P>RScheme is an object-oriented, extended version of the Scheme
dialect of Lisp. RScheme is freely redistributable, and offers
reasonable performance despite being extraordinarily portable.
RScheme can be compiled to C, and the C can then compiled with a
normal C compiler to generate machine code. By default, however,
RScheme compiles to bytecodes which are interpreted by a
(runtime) virtual machine. This ensures that compilation is fast
and keeps code size down. In general, we recommend using the
(default) bytecode code generation system, and only compiling
your time-critical code to machine code. This allows a nice
adjustment of space/time tradeoffs.  (see web site for details)
<P>
<P>
<P>
<P>
<A NAME="Scheme 48"></A> <DT><B>Scheme 48</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.neci.nj.nec.com/homepages/kelsey/">www.neci.nj.nec.com/homepages/kelsey/</A></LI>
</UL>
<P>
<P>Scheme 48 is a Scheme implementation based on a virtual machine
architecture. Scheme 48 is designed to be straightforward, flexible,
reliable, and fast. It should be easily portable to 32-bit
byte-addressed machines that have POSIX and ANSI C support.  In
addition to the usual Scheme built-in procedures and a development
environment, library software includes support for hygienic macros (as
described in the Revised^4 Scheme report), multitasking, records,
exception handling, hash tables, arrays, weak pointers, and FORMAT.
Scheme 48 implements and exploits an experimental module system
loosely derived from Standard ML and Scheme Xerox.  The development
environment supports interactive changes to modules and interfaces.
<P>
<P>
<P>
<P>
<A NAME="SCM"></A> <DT><B>SCM (<B>Scheme</B>) </B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www-swiss.ai.mit.edu/~jaffer/SCM.html">www-swiss.ai.mit.edu/~jaffer/SCM.html</A></LI>
<LI>FTP site: 
<A HREF="ftp://swiss-ftp.ai.mit.edu:/archive/scm/">swiss-ftp.ai.mit.edu:/archive/scm/</A></LI>
</UL>
<P>
<P>SCM conforms to the Revised^4 Report on the Algorithmic Language
Scheme and the IEEE P1178 specification. Scm is written in C. It uses
the following utilities (all available at the ftp site).
<UL>
<LI>SLIB (Standard Scheme Library) is a portable Scheme
library which is intended to provide compatibility and utility
functions for all standard Scheme implementations, including
SCM, Chez, Elk, Gambit, MacScheme, MITScheme, scheme->C,
Scheme48, T3.1, and VSCM, and is available as the file
slib2c0.tar.gz. Written by Aubrey Jaffer.  </LI>
<LI>JACAL is a symbolic math system written in Scheme, and is
available as the file jacal1a7.tar.gz.</LI>
<LI>Interfaces to standard libraries including REGEX string 
regular expression matching and the CURSES screen management 
package.</LI>
<LI>Available add-on packages including an interactive debugger, 
database, X-window graphics, BGI graphics, Motif, and 
Open-Windows packages.</LI>
<LI>A compiler (HOBBIT, available separately) and dynamic linking
of compiled modules.</LI>
</UL>
<P>
<P>
<P>
<A NAME="Shift"></A> <DT><B>Shift</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.path.berkeley.edu/shift/">www.path.berkeley.edu/shift/</A></LI>
</UL>
<P>Shift is a programming language for describing dynamic
networks of hybrid automata.  Such systems consist of
components which can be created, interconnected and destroyed
as the system evolves. Components exhibit hybrid behavior,
consisting of continuous-time phases separated by
discrete-event transitions. Components may evolve
independently, or they may interact through their inputs,
outputs and exported events. The interaction network itself
may evolve.
<P>
<P>
<P>
<A NAME="YAP Prolog"></A> <DT><B>YAP Prolog</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.ncc.up.pt/~vsc/Yap/">www.ncc.up.pt/~vsc/Yap/</A></LI>
</UL>
<P>YAP is a high-performance Prolog compiler developed at  
LIACC/Universidade do Porto. Its Prolog engine is based in the WAM
(Warren Abstract Machine), with several optimizations for better
performance. YAP follows the Edinburgh tradition, and is largely
compatible with DEC-10 Prolog, Quintus Prolog, and especially 
with C-Prolog. Work on the more recent version of YAP strives at
several goals:
<P>
<UL>
<LI>Portability: The whole system is now written in C. YAP
compiles in popular 32 bit machines, such as Suns and 
Linux PCs, and in a 64 bit machines, the Alphas running
OSF Unix and Linux. </LI>
<LI>Performance: We have optimised the emulator to obtain
performance comparable to or better than well-known Prolog
systems. In fact, the current version of YAP performs 
better than the original one, written in assembly language.</LI>
<LI>Robustness: We have tested the system with a large array 
of Prolog applications.</LI>
<LI>Extensibility: YAP was designed internally from the
beginning to encapsulate manipulation of terms. These
principles were used, for example, to implement a simple
and powerful C-interface. The new version of YAP extends
these principles to accomodate extensions to the 
unification algorithm, that we believe will be useful to
implement extensions such as constraint programming.</LI>
<LI>Completeness: YAP has for a long time provided most
builtins expected from a Edinburgh Prolog implementation.
These include I/O functionality, data-base operations, 
and modules. Work on YAP aims now at being compatible with
the Prolog standard. </LI>
<LI>Openess: We would like to make new development of YAP
open to the user community. </LI>
<LI>Research: YAP has been a vehicle for research within and
outside our group. Currently research is going on on 
parallelisation and tabulation, and we have started work
to support constraint handling. </LI>
</UL>
<P>
<P>
</DL>
<P>
<P>
<HR>
<IMG SRC="../img/next.gif" ALT="Next">
<A HREF="AI-Alife-HOWTO-6.html"><IMG SRC="../img/prev.gif" ALT="Previous"></A>
<A HREF="AI-Alife-HOWTO.html#toc7"><IMG SRC="../img/toc.gif" ALT="Contents"></A>
<SCRIPT>EndPage();</SCRIPT>  </BODY>
</HTML>
