<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Database-SQL-RDBMS HOW-TO document for Linux (PostgreSQL Object Relational Database System): Appendix A - Syntax of ANSI/ISO SQL 1992 </TITLE>
 <LINK HREF="PostgreSQL-HOWTO-39.html" REL=next>
 <LINK HREF="PostgreSQL-HOWTO-37.html" REL=previous>
 <LINK HREF="PostgreSQL-HOWTO.html#toc38" REL=contents>
<SCRIPT src="../menu.js"> function BeginPage() {} function EndPage() {} </SCRIPT> </HEAD> <BODY bgcolor=#EEEEFF MARGINHEIGHT=0 MARGINWIDTH=0> <SCRIPT>BeginPage(1, 8, 1);</SCRIPT>
<A HREF="PostgreSQL-HOWTO-39.html"><IMG SRC="../img/next.gif" ALT="Next"></A>
<A HREF="PostgreSQL-HOWTO-37.html"><IMG SRC="../img/prev.gif" ALT="Previous"></A>
<A HREF="PostgreSQL-HOWTO.html#toc38"><IMG SRC="../img/toc.gif" ALT="Contents"></A>
<HR>
<H2><A NAME="Appendix A"></A> <A NAME="s38">38. Appendix A - Syntax of ANSI/ISO SQL 1992 </A></H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>
This file contains a depth-first tree traversal of the BNF
for the  language done at about 27-AUG-1992 11:03:41.64.
The specific version of the BNF included here is:  ANSI-only, SQL2-only.


&lt;SQL terminal character> ::=
      &lt;SQL language character>
    | &lt;SQL embedded language character>

&lt;SQL language character> ::=
      &lt;simple Latin letter>
    | &lt;digit>
    | &lt;SQL special character>

&lt;simple Latin letter> ::=
      &lt;simple Latin upper case letter>
    | &lt;simple Latin lower case letter>

&lt;simple Latin upper case letter> ::=
          A | B | C | D | E | F | G | H | I | J | K | L | M | N | O
    | P | Q | R | S | T | U | V | W | X | Y | Z

&lt;simple Latin lower case letter> ::=
          a | b | c | d | e | f | g | h | i | j | k | l | m | n | o
    | p | q | r | s | t | u | v | w | x | y | z

&lt;digit> ::=
    0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

&lt;SQL special character> ::=
      &lt;space>
    | &lt;double quote>
    | &lt;percent>
    | &lt;ampersand>
    | &lt;quote>
    | &lt;left paren>
    | &lt;right paren>
    | &lt;asterisk>
    | &lt;plus sign>
    | &lt;comma>
    | &lt;minus sign>
    | &lt;period>
    | &lt;solidus>
    | &lt;colon>
    | &lt;semicolon>
    | &lt;less than operator>
    | &lt;equals operator>
    | &lt;greater than operator>
    | &lt;question mark>
    | &lt;underscore>
    | &lt;vertical bar>

&lt;space> ::= !! &lt;EMPHASIS>(space character in character set in use)

&lt;double quote> ::= "

&lt;percent> ::= %

&lt;ampersand> ::= &amp;

&lt;quote> ::= '

&lt;left paren> ::= (

&lt;right paren> ::= )

&lt;asterisk> ::= *

&lt;plus sign> ::= +

&lt;comma> ::= ,

&lt;minus sign> ::= -

&lt;period> ::= .

&lt;solidus> ::= /

&lt;colon> ::= :

&lt;semicolon> ::= ;

&lt;less than operator> ::= &lt;

&lt;equals operator> ::= =

&lt;greater than operator> ::= >

&lt;question mark> ::= ?

&lt;underscore> ::= _

&lt;vertical bar> ::= |

&lt;SQL embedded language character> ::=
      &lt;left bracket>
    | &lt;right bracket>

&lt;left bracket> ::= [

&lt;right bracket> ::= ]

&lt;token> ::=
      &lt;nondelimiter token>
    | &lt;delimiter token>

&lt;nondelimiter token> ::=
      &lt;regular identifier>
    | &lt;key word>
    | &lt;unsigned numeric literal>
    | &lt;national character string literal>
    | &lt;bit string literal>
    | &lt;hex string literal>

&lt;regular identifier> ::= &lt;identifier body>

&lt;identifier body> ::=
    &lt;identifier start> [ ( &lt;underscore> | &lt;identifier part> )... ]

&lt;identifier start> ::= &lt;EMPHASIS>(!! See the Syntax Rules)

&lt;identifier part> ::=
      &lt;identifier start>
    | &lt;digit>

&lt;key word> ::=
      &lt;reserved word>
    | &lt;non-reserved word>

&lt;reserved word> ::=
      ABSOLUTE | ACTION | ADD | ALL
    | ALLOCATE | ALTER | AND
    | ANY | ARE
    | AS | ASC
    | ASSERTION | AT
    | AUTHORIZATION | AVG
    | BEGIN | BETWEEN | BIT | BIT_LENGTH
    | BOTH | BY
    | CASCADE | CASCADED | CASE | CAST
    | CATALOG
    | CHAR | CHARACTER | CHAR_LENGTH
    | CHARACTER_LENGTH | CHECK | CLOSE | COALESCE
    | COLLATE | COLLATION
    | COLUMN | COMMIT
    | CONNECT
    | CONNECTION | CONSTRAINT
    | CONSTRAINTS | CONTINUE
    | CONVERT | CORRESPONDING | COUNT | CREATE | CROSS
    | CURRENT
    | CURRENT_DATE | CURRENT_TIME
    | CURRENT_TIMESTAMP | CURRENT_USER | CURSOR
    | DATE | DAY | DEALLOCATE | DEC
    | DECIMAL | DECLARE | DEFAULT | DEFERRABLE
    | DEFERRED | DELETE | DESC | DESCRIBE | DESCRIPTOR
    | DIAGNOSTICS
    | DISCONNECT | DISTINCT | DOMAIN | DOUBLE | DROP
    | ELSE | END | END-EXEC | ESCAPE
    | EXCEPT | EXCEPTION
    | EXEC | EXECUTE | EXISTS
    | EXTERNAL | EXTRACT
    | FALSE | FETCH | FIRST | FLOAT | FOR
    | FOREIGN | FOUND | FROM | FULL
    | GET | GLOBAL | GO | GOTO
    | GRANT | GROUP
    | HAVING | HOUR
    | IDENTITY | IMMEDIATE | IN | INDICATOR
    | INITIALLY | INNER | INPUT
    | INSENSITIVE | INSERT | INT | INTEGER | INTERSECT
    | INTERVAL | INTO | IS
    | ISOLATION
    | JOIN
    | KEY
    | LANGUAGE | LAST | LEADING | LEFT
    | LEVEL | LIKE | LOCAL | LOWER
    | MATCH | MAX | MIN | MINUTE | MODULE
    | MONTH
    | NAMES | NATIONAL | NATURAL | NCHAR | NEXT | NO
    | NOT | NULL
    | NULLIF | NUMERIC
    | OCTET_LENGTH | OF
    | ON | ONLY | OPEN | OPTION | OR
    | ORDER | OUTER
    | OUTPUT | OVERLAPS
    | PAD | PARTIAL | POSITION | PRECISION | PREPARE
    | PRESERVE | PRIMARY
    | PRIOR | PRIVILEGES | PROCEDURE | PUBLIC
    | READ | REAL | REFERENCES | RELATIVE | RESTRICT
    | REVOKE | RIGHT
    | ROLLBACK | ROWS
    | SCHEMA | SCROLL | SECOND | SECTION
    | SELECT
    | SESSION | SESSION_USER | SET
    | SIZE | SMALLINT | SOME | SPACE | SQL | SQLCODE
    | SQLERROR | SQLSTATE
    | SUBSTRING | SUM | SYSTEM_USER
    | TABLE | TEMPORARY
    | THEN | TIME | TIMESTAMP
    | TIMEZONE_HOUR | TIMEZONE_MINUTE
    | TO | TRAILING | TRANSACTION
    | TRANSLATE | TRANSLATION | TRIM | TRUE
    | UNION | UNIQUE | UNKNOWN | UPDATE | UPPER | USAGE
    | USER | USING
    | VALUE | VALUES | VARCHAR | VARYING | VIEW
    | WHEN | WHENEVER | WHERE | WITH | WORK | WRITE
    | YEAR
    | ZONE

&lt;non-reserved word> ::=
    
      ADA
    | C | CATALOG_NAME
    | CHARACTER_SET_CATALOG | CHARACTER_SET_NAME
    | CHARACTER_SET_SCHEMA | CLASS_ORIGIN | COBOL | COLLATION_CATALOG
    | COLLATION_NAME | COLLATION_SCHEMA | COLUMN_NAME | COMMAND_FUNCTION
    | COMMITTED
    | CONDITION_NUMBER | CONNECTION_NAME | CONSTRAINT_CATALOG | CONSTRAINT_NAME
    | CONSTRAINT_SCHEMA | CURSOR_NAME
    | DATA | DATETIME_INTERVAL_CODE
    | DATETIME_INTERVAL_PRECISION | DYNAMIC_FUNCTION
    | FORTRAN
    | LENGTH
    | MESSAGE_LENGTH | MESSAGE_OCTET_LENGTH | MESSAGE_TEXT | MORE | MUMPS
    | NAME | NULLABLE | NUMBER
    | PASCAL | PLI
    | REPEATABLE | RETURNED_LENGTH | RETURNED_OCTET_LENGTH | RETURNED_SQLSTATE
    | ROW_COUNT
    | SCALE | SCHEMA_NAME | SERIALIZABLE | SERVER_NAME | SUBCLASS_ORIGIN
    | TABLE_NAME | TYPE
    | UNCOMMITTED | UNNAMED

&lt;unsigned numeric literal> ::=
      &lt;exact numeric literal>
    | &lt;approximate numeric literal>

&lt;exact numeric literal> ::=
      &lt;unsigned integer> [ &lt;period> [ &lt;unsigned integer> ] ]
    | &lt;period> &lt;unsigned integer>

&lt;unsigned integer> ::= &lt;digit>...

&lt;approximate numeric literal> ::= &lt;mantissa> E &lt;exponent>

&lt;mantissa> ::= &lt;exact numeric literal>

&lt;exponent> ::= &lt;signed integer>

&lt;signed integer> ::= [ &lt;sign> ] &lt;unsigned integer>

&lt;sign> ::= &lt;plus sign> | &lt;minus sign>

&lt;national character string literal> ::=
    N &lt;quote> [ &lt;character representation>... ] &lt;quote>
      [ ( &lt;separator>... &lt;quote> [ &lt;character representation>... ] &lt;quote> )... ]

&lt;character representation> ::=
      &lt;nonquote character>
    | &lt;quote symbol>

&lt;nonquote character> ::= !! &lt;EMPHASIS>(See the Syntax Rules.)

&lt;quote symbol> ::= &lt;quote>&lt;quote>

&lt;separator> ::= ( &lt;comment> | &lt;space> | &lt;newline> )...

&lt;comment> ::=
    &lt;comment introducer> [ &lt;comment character>... ] &lt;newline>

&lt;comment introducer> ::= &lt;minus sign>&lt;minus sign>[&lt;minus sign>...]

&lt;comment character> ::=
      &lt;nonquote character>
    | &lt;quote>

&lt;newline> ::= !! &lt;EMPHASIS>(implementation-defined end-of-line indicator)

&lt;bit string literal> ::=
    B &lt;quote> [ &lt;bit>... ] &lt;quote>
      [ ( &lt;separator>... &lt;quote> [ &lt;bit>... ] &lt;quote> )... ]

&lt;bit> ::= 0 | 1

&lt;hex string literal> ::=
    X &lt;quote> [ &lt;hexit>... ] &lt;quote>
      [ ( &lt;separator>... &lt;quote> [ &lt;hexit>... ] &lt;quote> )... ]

&lt;hexit> ::= &lt;digit> | A | B | C | D | E | F | a | b | c | d | e | f

&lt;delimiter token> ::=
      &lt;character string literal>
    | &lt;date string>
    | &lt;time string>
    | &lt;timestamp string>
    | &lt;interval string>
    | &lt;delimited identifier>
    | &lt;SQL special character>
    | &lt;not equals operator>
    | &lt;greater than or equals operator>
    | &lt;less than or equals operator>
    | &lt;concatenation operator>
    | &lt;double period>
    | &lt;left bracket>
    | &lt;right bracket>

&lt;character string literal> ::=
    [ &lt;introducer>&lt;character set specification> ]
    &lt;quote> [ &lt;character representation>... ] &lt;quote>
      [ ( &lt;separator>... &lt;quote> [ &lt;character representation>... ] &lt;quote> )... ]

&lt;introducer> ::= &lt;underscore>

&lt;character set specification> ::=
      &lt;standard character repertoire name>
    | &lt;implementation-defined character repertoire name>
    | &lt;user-defined character repertoire name>
    | &lt;standard universal character form-of-use name>
    | &lt;implementation-defined universal character form-of-use name>

&lt;standard character repertoire name> ::= &lt;character set name>

&lt;character set name> ::= [ &lt;schema name> &lt;period> ]
      &lt;SQL language identifier>

&lt;schema name> ::=
    [ &lt;catalog name> &lt;period> ] &lt;unqualified schema name>

&lt;catalog name> ::= &lt;identifier>

&lt;identifier> ::=
    [ &lt;introducer>&lt;character set specification> ] &lt;actual identifier>

&lt;actual identifier> ::=
      &lt;regular identifier>
    | &lt;delimited identifier>

&lt;delimited identifier> ::=
    &lt;double quote> &lt;delimited identifier body> &lt;double quote>

&lt;delimited identifier body> ::= &lt;delimited identifier part>...

&lt;delimited identifier part> ::=
      &lt;nondoublequote character>
    | &lt;doublequote symbol>

&lt;nondoublequote character> ::= &lt;EMPHASIS>(!! See the Syntax Rules)

&lt;doublequote symbol> ::= &lt;double quote>&lt;double quote>

&lt;unqualified schema name> ::= &lt;identifier>

&lt;SQL language identifier> ::=
    &lt;SQL language identifier start>
       [ ( &lt;underscore> | &lt;SQL language identifier part> )... ]

&lt;SQL language identifier start> ::= &lt;simple Latin letter>

&lt;SQL language identifier part> ::=
      &lt;simple Latin letter>
    | &lt;digit>

&lt;implementation-defined character repertoire name> ::=
    &lt;character set name>

&lt;user-defined character repertoire name> ::= &lt;character set name>

&lt;standard universal character form-of-use name> ::=
    &lt;character set name>

&lt;implementation-defined universal character form-of-use name> ::=
    &lt;character set name>

&lt;date string> ::=
    &lt;quote> &lt;date value> &lt;quote>

&lt;date value> ::=
    &lt;years value> &lt;minus sign> &lt;months value>
        &lt;minus sign> &lt;days value>

&lt;years value> ::= &lt;datetime value>

&lt;datetime value> ::= &lt;unsigned integer>

&lt;months value> ::= &lt;datetime value>

&lt;days value> ::= &lt;datetime value>

&lt;time string> ::=
    &lt;quote> &lt;time value> [ &lt;time zone interval> ] &lt;quote>

&lt;time value> ::=
    &lt;hours value> &lt;colon> &lt;minutes value> &lt;colon> &lt;seconds value>

&lt;hours value> ::= &lt;datetime value>

&lt;minutes value> ::= &lt;datetime value>

&lt;seconds value> ::=
      &lt;seconds integer value> [ &lt;period> [ &lt;seconds fraction> ] ]

&lt;seconds integer value> ::= &lt;unsigned integer>

&lt;seconds fraction> ::= &lt;unsigned integer>

&lt;time zone interval> ::=
    &lt;sign> &lt;hours value> &lt;colon> &lt;minutes value>

&lt;timestamp string> ::=
    &lt;quote> &lt;date value> &lt;space> &lt;time value>
        [ &lt;time zone interval> ] &lt;quote>

&lt;interval string> ::=
    &lt;quote> ( &lt;year-month literal> | &lt;day-time literal> ) &lt;quote>

&lt;year-month literal> ::=
      &lt;years value>
    | [ &lt;years value> &lt;minus sign> ] &lt;months value>

&lt;day-time literal> ::=
      &lt;day-time interval>
    | &lt;time interval>

&lt;day-time interval> ::=
    &lt;days value>
      [ &lt;space> &lt;hours value> [ &lt;colon> &lt;minutes value>
        [ &lt;colon> &lt;seconds value> ] ] ]

&lt;time interval> ::=
      &lt;hours value> [ &lt;colon> &lt;minutes value> [ &lt;colon> &lt;seconds value> ] ]
    | &lt;minutes value> [ &lt;colon> &lt;seconds value> ]
    | &lt;seconds value>

&lt;not equals operator> ::= &lt;>

&lt;greater than or equals operator> ::= >=

&lt;less than or equals operator> ::= &lt;=

&lt;concatenation operator> ::= ||

&lt;double period> ::= ..

&lt;module> ::=
    &lt;module name clause>
    &lt;language clause>
    &lt;module authorization clause>
    [ &lt;temporary table declaration>... ]
    &lt;module contents>...

&lt;module name clause> ::=
    MODULE [ &lt;module name> ]
      [ &lt;module character set specification> ]

&lt;module name> ::= &lt;identifier>

&lt;module character set specification> ::=
    NAMES ARE &lt;character set specification>

&lt;language clause> ::=
    LANGUAGE &lt;language name>

&lt;language name> ::=
    ADA | C | COBOL | FORTRAN | MUMPS | PASCAL | PLI

&lt;module authorization clause> ::=
      SCHEMA &lt;schema name>
    | AUTHORIZATION &lt;module authorization identifier>
    | SCHEMA &lt;schema name>
          AUTHORIZATION &lt;module authorization identifier>

&lt;module authorization identifier> ::=
    &lt;authorization identifier>

&lt;authorization identifier> ::= &lt;identifier>

&lt;temporary table declaration> ::=
    DECLARE LOCAL TEMPORARY TABLE
        &lt;qualified local table name>
      &lt;table element list>
      [ ON COMMIT ( PRESERVE | DELETE ) ROWS ]

&lt;qualified local table name> ::=
    MODULE &lt;period> &lt;local table name>

&lt;local table name> ::= &lt;qualified identifier>

&lt;qualified identifier> ::= &lt;identifier>

&lt;table element list> ::=
      &lt;left paren> &lt;table element> [ ( &lt;comma> &lt;table element> )... ] &lt;right paren>

&lt;table element> ::=
      &lt;column definition>
    | &lt;table constraint definition>

&lt;column definition> ::=
    &lt;column name> ( &lt;data type> | &lt;domain name> )
    [ &lt;default clause> ]
    [ &lt;column constraint definition>... ]
    [ &lt;collate clause> ]

&lt;column name> ::= &lt;identifier>

&lt;data type> ::=
      &lt;character string type>
           [ CHARACTER SET &lt;character set specification> ]
    | &lt;national character string type>
    | &lt;bit string type>
    | &lt;numeric type>
    | &lt;datetime type>
    | &lt;interval type>

&lt;character string type> ::=
      CHARACTER [ &lt;left paren> &lt;length> &lt;right paren> ]
    | CHAR [ &lt;left paren> &lt;length> &lt;right paren> ]
    | CHARACTER VARYING &lt;left paren> &lt;length> &lt;right paren>
    | CHAR VARYING &lt;left paren> &lt;length> &lt;right paren>
    | VARCHAR &lt;left paren> &lt;length> &lt;right paren>

&lt;length> ::= &lt;unsigned integer>

&lt;national character string type> ::=
      NATIONAL CHARACTER [ &lt;left paren> &lt;length> &lt;right paren> ]
    | NATIONAL CHAR [ &lt;left paren> &lt;length> &lt;right paren> ]
    | NCHAR [ &lt;left paren> &lt;length> &lt;right paren> ]
    | NATIONAL CHARACTER VARYING &lt;left paren> &lt;length> &lt;right paren>
    | NATIONAL CHAR VARYING &lt;left paren> &lt;length> &lt;right paren>
    | NCHAR VARYING &lt;left paren> &lt;length> &lt;right paren>

&lt;bit string type> ::=
      BIT [ &lt;left paren> &lt;length> &lt;right paren> ]
    | BIT VARYING &lt;left paren> &lt;length> &lt;right paren>

&lt;numeric type> ::=
      &lt;exact numeric type>
    | &lt;approximate numeric type>

&lt;exact numeric type> ::=
      NUMERIC [ &lt;left paren> &lt;precision> [ &lt;comma> &lt;scale> ] &lt;right paren> ]
    | DECIMAL [ &lt;left paren> &lt;precision> [ &lt;comma> &lt;scale> ] &lt;right paren> ]
    | DEC [ &lt;left paren> &lt;precision> [ &lt;comma> &lt;scale> ] &lt;right paren> ]
    | INTEGER
    | INT
    | SMALLINT

&lt;precision> ::= &lt;unsigned integer>

&lt;scale> ::= &lt;unsigned integer>

&lt;approximate numeric type> ::=
      FLOAT [ &lt;left paren> &lt;precision> &lt;right paren> ]
    | REAL
    | DOUBLE PRECISION

&lt;datetime type> ::=
      DATE
    | TIME [ &lt;left paren> &lt;time precision> &lt;right paren> ]
          [ WITH TIME ZONE ]
    | TIMESTAMP [ &lt;left paren> &lt;timestamp precision> &lt;right paren> ]
          [ WITH TIME ZONE ]

&lt;time precision> ::= &lt;time fractional seconds precision>

&lt;time fractional seconds precision> ::= &lt;unsigned integer>

&lt;timestamp precision> ::= &lt;time fractional seconds precision>

&lt;interval type> ::= INTERVAL &lt;interval qualifier>

&lt;interval qualifier> ::=
      &lt;start field> TO &lt;end field>
    | &lt;single datetime field>

&lt;start field> ::=
    &lt;non-second datetime field>
        [ &lt;left paren> &lt;interval leading field precision> &lt;right paren> ]

&lt;non-second datetime field> ::= YEAR | MONTH | DAY | HOUR
    | MINUTE

&lt;interval leading field precision> ::= &lt;unsigned integer>

&lt;end field> ::=
      &lt;non-second datetime field>
    | SECOND [ &lt;left paren> &lt;interval fractional seconds precision> &lt;right paren> ]

&lt;interval fractional seconds precision> ::= &lt;unsigned integer>

&lt;single datetime field> ::=
      &lt;non-second datetime field>
          [ &lt;left paren> &lt;interval leading field precision> &lt;right paren> ]
    | SECOND [ &lt;left paren> &lt;interval leading field precision>
          [ &lt;comma> &lt;interval fractional seconds precision> ] &lt;right paren> ]

&lt;domain name> ::= &lt;qualified name>

&lt;qualified name> ::=
    [ &lt;schema name> &lt;period> ] &lt;qualified identifier>

&lt;default clause> ::=
      DEFAULT &lt;default option>

&lt;default option> ::=
      &lt;literal>
    | &lt;datetime value function>
    | USER
    | CURRENT_USER
    | SESSION_USER
    | SYSTEM_USER
    | NULL

&lt;literal> ::=
      &lt;signed numeric literal>
    | &lt;general literal>

&lt;signed numeric literal> ::=
    [ &lt;sign> ] &lt;unsigned numeric literal>

&lt;general literal> ::=
      &lt;character string literal>
    | &lt;national character string literal>
    | &lt;bit string literal>
    | &lt;hex string literal>
    | &lt;datetime literal>
    | &lt;interval literal>

&lt;datetime literal> ::=
      &lt;date literal>
    | &lt;time literal>
    | &lt;timestamp literal>

&lt;date literal> ::=
    DATE &lt;date string>

&lt;time literal> ::=
    TIME &lt;time string>

&lt;timestamp literal> ::=
    TIMESTAMP &lt;timestamp string>

&lt;interval literal> ::=
    INTERVAL [ &lt;sign> ] &lt;interval string> &lt;interval qualifier>

&lt;datetime value function> ::=
      &lt;current date value function>
    | &lt;current time value function>
    | &lt;current timestamp value function>

&lt;current date value function> ::= CURRENT_DATE

&lt;current time value function> ::=
      CURRENT_TIME [ &lt;left paren> &lt;time precision> &lt;right paren> ]

&lt;current timestamp value function> ::=
      CURRENT_TIMESTAMP [ &lt;left paren> &lt;timestamp precision> &lt;right paren> ]

&lt;column constraint definition> ::=
    [ &lt;constraint name definition> ]
    &lt;column constraint>
      [ &lt;constraint attributes> ]

&lt;constraint name definition> ::= CONSTRAINT &lt;constraint name>

&lt;constraint name> ::= &lt;qualified name>

&lt;column constraint> ::=
      NOT NULL
    | &lt;unique specification>
    | &lt;references specification>
    | &lt;check constraint definition>

&lt;unique specification> ::=
    UNIQUE | PRIMARY KEY

&lt;references specification> ::=
    REFERENCES &lt;referenced table and columns>
      [ MATCH &lt;match type> ]
      [ &lt;referential triggered action> ]

&lt;referenced table and columns> ::=
     &lt;table name> [ &lt;left paren> &lt;reference column list> &lt;right paren> ]

&lt;table name> ::=
      &lt;qualified name>
    | &lt;qualified local table name>

&lt;reference column list> ::= &lt;column name list>

&lt;column name list> ::=
    &lt;column name> [ ( &lt;comma> &lt;column name> )... ]

&lt;match type> ::=
      FULL
    | PARTIAL

&lt;referential triggered action> ::=
      &lt;update rule> [ &lt;delete rule> ]
    | &lt;delete rule> [ &lt;update rule> ]

&lt;update rule> ::= ON UPDATE &lt;referential action>

&lt;referential action> ::=
      CASCADE
    | SET NULL
    | SET DEFAULT
    | NO ACTION

&lt;delete rule> ::= ON DELETE &lt;referential action>

&lt;check constraint definition> ::=
    CHECK
        &lt;left paren> &lt;search condition> &lt;right paren>

&lt;search condition> ::=
      &lt;boolean term>
    | &lt;search condition> OR &lt;boolean term>

&lt;boolean term> ::=
      &lt;boolean factor>
    | &lt;boolean term> AND &lt;boolean factor>

&lt;boolean factor> ::=
    [ NOT ] &lt;boolean test>

&lt;boolean test> ::=
    &lt;boolean primary> [ IS [ NOT ]
          &lt;truth value> ]

&lt;boolean primary> ::=
      &lt;predicate>
    | &lt;left paren> &lt;search condition> &lt;right paren>

&lt;predicate> ::=
      &lt;comparison predicate>
    | &lt;between predicate>
    | &lt;in predicate>
    | &lt;like predicate>
    | &lt;null predicate>
    | &lt;quantified comparison predicate>
    | &lt;exists predicate>
    | &lt;unique predicate>
    | &lt;match predicate>
    | &lt;overlaps predicate>

&lt;comparison predicate> ::=
    &lt;row value constructor> &lt;comp op>
        &lt;row value constructor>

&lt;row value constructor> ::=
       &lt;row value constructor element>
    | &lt;left paren> &lt;row value constructor list> &lt;right paren>
    | &lt;row subquery>

&lt;row value constructor element> ::=
      &lt;value expression>
    | &lt;null specification>
    | &lt;default specification>

&lt;value expression> ::=
      &lt;numeric value expression>
    | &lt;string value expression>
    | &lt;datetime value expression>
    | &lt;interval value expression>

&lt;numeric value expression> ::=
      &lt;term>
    | &lt;numeric value expression> &lt;plus sign> &lt;term>
    | &lt;numeric value expression> &lt;minus sign> &lt;term>

&lt;term> ::=
      &lt;factor>
    | &lt;term> &lt;asterisk> &lt;factor>
    | &lt;term> &lt;solidus> &lt;factor>

&lt;factor> ::=
    [ &lt;sign> ] &lt;numeric primary>

&lt;numeric primary> ::=
      &lt;value expression primary>
    | &lt;numeric value function>

&lt;value expression primary> ::=
      &lt;unsigned value specification>
    | &lt;column reference>
    | &lt;set function specification>
    | &lt;scalar subquery>
    | &lt;case expression>
    | &lt;left paren> &lt;value expression> &lt;right paren>
    | &lt;cast specification>

&lt;unsigned value specification> ::=
      &lt;unsigned literal>
    | &lt;general value specification>

&lt;unsigned literal> ::=
      &lt;unsigned numeric literal>
    | &lt;general literal>

&lt;general value specification> ::=
      &lt;parameter specification>
    | &lt;dynamic parameter specification>
    | &lt;variable specification>
    | USER
    | CURRENT_USER
    | SESSION_USER
    | SYSTEM_USER
    | VALUE

&lt;parameter specification> ::=
    &lt;parameter name> [ &lt;indicator parameter> ]

&lt;parameter name> ::= &lt;colon> &lt;identifier>

&lt;indicator parameter> ::=
    [ INDICATOR ] &lt;parameter name>

&lt;dynamic parameter specification> ::= &lt;question mark>

&lt;variable specification> ::=
    &lt;embedded variable name> [ &lt;indicator variable> ]

&lt;embedded variable name> ::=
    &lt;colon>&lt;host identifier>

&lt;host identifier> ::=
      &lt;Ada host identifier>
    | &lt;C host identifier>
    | &lt;COBOL host identifier>
    | &lt;Fortran host identifier>
    | &lt;MUMPS host identifier>
    | &lt;Pascal host identifier>
    | &lt;PL/I host identifier>

&lt;Ada host identifier> ::= !! &lt;EMPHASIS>(See the Syntax Rules.)

&lt;C host identifier> ::=
    !! &lt;EMPHASIS>(See the Syntax Rules.)

&lt;COBOL host identifier> ::= !! &lt;EMPHASIS>(See the Syntax Rules.)

&lt;Fortran host identifier> ::= !! &lt;EMPHASIS>(See the Syntax Rules.)

&lt;MUMPS host identifier> ::= !! &lt;EMPHASIS>(See the Syntax Rules.)

&lt;Pascal host identifier> ::= !! &lt;EMPHASIS>(See the Syntax Rules.)

&lt;PL/I host identifier> ::= !! &lt;EMPHASIS>(See the Syntax Rules.)

&lt;indicator variable> ::=
    [ INDICATOR ] &lt;embedded variable name>

&lt;column reference> ::= [ &lt;qualifier> &lt;period> ] &lt;column name>

&lt;qualifier> ::=
      &lt;table name>
    | &lt;correlation name>

&lt;correlation name> ::= &lt;identifier>

&lt;set function specification> ::=
      COUNT &lt;left paren> &lt;asterisk> &lt;right paren>
    | &lt;general set function>

&lt;general set function> ::=
      &lt;set function type>
          &lt;left paren> [ &lt;set quantifier> ] &lt;value expression> &lt;right paren>

&lt;set function type> ::=
    AVG | MAX | MIN | SUM | COUNT

&lt;set quantifier> ::= DISTINCT | ALL

&lt;scalar subquery> ::= &lt;subquery>

&lt;subquery> ::= &lt;left paren> &lt;query expression> &lt;right paren>

&lt;query expression> ::=
      &lt;non-join query expression>
    | &lt;joined table>

&lt;non-join query expression> ::=
      &lt;non-join query term>
    | &lt;query expression> UNION  [ ALL ]
          [ &lt;corresponding spec> ] &lt;query term>
    | &lt;query expression> EXCEPT [ ALL ]
          [ &lt;corresponding spec> ] &lt;query term>

&lt;non-join query term> ::=
      &lt;non-join query primary>
    | &lt;query term> INTERSECT [ ALL ]
          [ &lt;corresponding spec> ] &lt;query primary>

&lt;non-join query primary> ::=
      &lt;simple table>
    | &lt;left paren> &lt;non-join query expression> &lt;right paren>

&lt;simple table> ::=
      &lt;query specification>
    | &lt;table value constructor>
    | &lt;explicit table>

&lt;query specification> ::=
    SELECT [ &lt;set quantifier> ] &lt;select list> &lt;table expression>

&lt;select list> ::=
      &lt;asterisk>
    | &lt;select sublist> [ ( &lt;comma> &lt;select sublist> )... ]

&lt;select sublist> ::=
      &lt;derived column>
    | &lt;qualifier> &lt;period> &lt;asterisk>

&lt;derived column> ::= &lt;value expression> [ &lt;as clause> ]

&lt;as clause> ::= [ AS ] &lt;column name>

&lt;table expression> ::=
    &lt;from clause>
    [ &lt;where clause> ]
    [ &lt;group by clause> ]
    [ &lt;having clause> ]

&lt;from clause> ::= FROM &lt;table reference>
    [ ( &lt;comma> &lt;table reference> )... ]

&lt;table reference> ::=
      &lt;table name> [ [ AS ] &lt;correlation name>
          [ &lt;left paren> &lt;derived column list> &lt;right paren> ] ]
    | &lt;derived table> [ AS ] &lt;correlation name>
          [ &lt;left paren> &lt;derived column list> &lt;right paren> ]
    | &lt;joined table>

&lt;derived column list> ::= &lt;column name list>

&lt;derived table> ::= &lt;table subquery>

&lt;table subquery> ::= &lt;subquery>

&lt;joined table> ::=
      &lt;cross join>
    | &lt;qualified join>
    | &lt;left paren> &lt;joined table> &lt;right paren>

&lt;cross join> ::=
    &lt;table reference> CROSS JOIN &lt;table reference>

&lt;qualified join> ::=
    &lt;table reference> [ NATURAL ] [ &lt;join type> ] JOIN
      &lt;table reference> [ &lt;join specification> ]

&lt;join type> ::=
      INNER
    | &lt;outer join type> [ OUTER ]
    | UNION

&lt;outer join type> ::=
      LEFT
    | RIGHT
    | FULL

&lt;join specification> ::=
      &lt;join condition>
    | &lt;named columns join>

&lt;join condition> ::= ON &lt;search condition>

&lt;named columns join> ::=
    USING &lt;left paren> &lt;join column list> &lt;right paren>

&lt;join column list> ::= &lt;column name list>

&lt;where clause> ::= WHERE &lt;search condition>

&lt;group by clause> ::=
    GROUP BY &lt;grouping column reference list>

&lt;grouping column reference list> ::=
    &lt;grouping column reference>
        [ ( &lt;comma> &lt;grouping column reference> )... ]

&lt;grouping column reference> ::=
    &lt;column reference> [ &lt;collate clause> ]

&lt;collate clause> ::= COLLATE &lt;collation name>

&lt;collation name> ::= &lt;qualified name>

&lt;having clause> ::= HAVING &lt;search condition>

&lt;table value constructor> ::=
    VALUES &lt;table value constructor list>

&lt;table value constructor list> ::=
    &lt;row value constructor> [ ( &lt;comma> &lt;row value constructor> )... ]

&lt;explicit table> ::= TABLE &lt;table name>

&lt;query term> ::=
      &lt;non-join query term>
    | &lt;joined table>

&lt;corresponding spec> ::=
    CORRESPONDING [ BY &lt;left paren> &lt;corresponding column list> &lt;right paren> ]

&lt;corresponding column list> ::= &lt;column name list>

&lt;query primary> ::=
      &lt;non-join query primary>
    | &lt;joined table>

&lt;case expression> ::=
      &lt;case abbreviation>
    | &lt;case specification>

&lt;case abbreviation> ::=
      NULLIF &lt;left paren> &lt;value expression> &lt;comma>
            &lt;value expression> &lt;right paren>
    | COALESCE &lt;left paren> &lt;value expression>
            ( &lt;comma> &lt;value expression> )... &lt;right paren>

&lt;case specification> ::=
      &lt;simple case>
    | &lt;searched case>

&lt;simple case> ::=
    CASE &lt;case operand>
      &lt;simple when clause>...
      [ &lt;else clause> ]
    END

&lt;case operand> ::= &lt;value expression>

&lt;simple when clause> ::= WHEN &lt;when operand> THEN &lt;result>

&lt;when operand> ::= &lt;value expression>

&lt;result> ::= &lt;result expression> | NULL

&lt;result expression> ::= &lt;value expression>

&lt;else clause> ::= ELSE &lt;result>

&lt;searched case> ::=
    CASE
      &lt;searched when clause>...
      [ &lt;else clause> ]
    END

&lt;searched when clause> ::= WHEN &lt;search condition> THEN &lt;result>

&lt;cast specification> ::=
    CAST &lt;left paren> &lt;cast operand> AS
        &lt;cast target> &lt;right paren>

&lt;cast operand> ::=
      &lt;value expression>
    | NULL

&lt;cast target> ::=
      &lt;domain name>
    | &lt;data type>

&lt;numeric value function> ::=
      &lt;position expression>
    | &lt;extract expression>
    | &lt;length expression>

&lt;position expression> ::=
    POSITION &lt;left paren> &lt;character value expression>
        IN &lt;character value expression> &lt;right paren>

&lt;character value expression> ::=
      &lt;concatenation>
    | &lt;character factor>

&lt;concatenation> ::=
    &lt;character value expression> &lt;concatenation operator>
        &lt;character factor>

&lt;character factor> ::=
    &lt;character primary> [ &lt;collate clause> ]

&lt;character primary> ::=
      &lt;value expression primary>
    | &lt;string value function>

&lt;string value function> ::=
      &lt;character value function>
    | &lt;bit value function>

&lt;character value function> ::=
      &lt;character substring function>
    | &lt;fold>
    | &lt;form-of-use conversion>
    | &lt;character translation>
    | &lt;trim function>

&lt;character substring function> ::=
    SUBSTRING &lt;left paren> &lt;character value expression> FROM &lt;start position>
                [ FOR &lt;string length> ] &lt;right paren>

&lt;start position> ::= &lt;numeric value expression>

&lt;string length> ::= &lt;numeric value expression>

&lt;fold> ::= ( UPPER | LOWER )
     &lt;left paren> &lt;character value expression> &lt;right paren>

&lt;form-of-use conversion> ::=
    CONVERT &lt;left paren> &lt;character value expression>
        USING &lt;form-of-use conversion name> &lt;right paren>

&lt;form-of-use conversion name> ::= &lt;qualified name>

&lt;character translation> ::=
    TRANSLATE &lt;left paren> &lt;character value expression>
        USING &lt;translation name> &lt;right paren>

&lt;translation name> ::= &lt;qualified name>

&lt;trim function> ::=
    TRIM &lt;left paren> &lt;trim operands> &lt;right paren>

&lt;trim operands> ::=
    [ [ &lt;trim specification> ] [ &lt;trim character> ] FROM ] &lt;trim source>

&lt;trim specification> ::=
      LEADING
    | TRAILING
    | BOTH

&lt;trim character> ::= &lt;character value expression>

&lt;trim source> ::= &lt;character value expression>

&lt;bit value function> ::=
    &lt;bit substring function>

&lt;bit substring function> ::=
    SUBSTRING &lt;left paren> &lt;bit value expression> FROM &lt;start position>
        [ FOR &lt;string length> ] &lt;right paren>

&lt;bit value expression> ::=
      &lt;bit concatenation>
    | &lt;bit factor>

&lt;bit concatenation> ::=
    &lt;bit value expression> &lt;concatenation operator> &lt;bit factor>

&lt;bit factor> ::= &lt;bit primary>

&lt;bit primary> ::=
      &lt;value expression primary>
    | &lt;string value function>

&lt;extract expression> ::=
    EXTRACT &lt;left paren> &lt;extract field>
        FROM &lt;extract source> &lt;right paren>

&lt;extract field> ::=
      &lt;datetime field>
    | &lt;time zone field>

&lt;datetime field> ::=
      &lt;non-second datetime field>
    | SECOND

&lt;time zone field> ::=
      TIMEZONE_HOUR
    | TIMEZONE_MINUTE

&lt;extract source> ::=
      &lt;datetime value expression>
    | &lt;interval value expression>

&lt;datetime value expression> ::=
      &lt;datetime term>
    | &lt;interval value expression> &lt;plus sign> &lt;datetime term>
    | &lt;datetime value expression> &lt;plus sign> &lt;interval term>
    | &lt;datetime value expression> &lt;minus sign> &lt;interval term>

&lt;interval term> ::=
      &lt;interval factor>
    | &lt;interval term 2> &lt;asterisk> &lt;factor>
    | &lt;interval term 2> &lt;solidus> &lt;factor>
    | &lt;term> &lt;asterisk> &lt;interval factor>

&lt;interval factor> ::=
    [ &lt;sign> ] &lt;interval primary>

&lt;interval primary> ::=
      &lt;value expression primary> [ &lt;interval qualifier> ]

&lt;interval term 2> ::= &lt;interval term>

&lt;interval value expression> ::=
      &lt;interval term>
    | &lt;interval value expression 1> &lt;plus sign> &lt;interval term 1>
    | &lt;interval value expression 1> &lt;minus sign> &lt;interval term 1>
    | &lt;left paren> &lt;datetime value expression> &lt;minus sign>
          &lt;datetime term> &lt;right paren> &lt;interval qualifier>

&lt;interval value expression 1> ::= &lt;interval value expression>

&lt;interval term 1> ::= &lt;interval term>

&lt;datetime term> ::=
      &lt;datetime factor>

&lt;datetime factor> ::=
      &lt;datetime primary> [ &lt;time zone> ]

&lt;datetime primary> ::=
      &lt;value expression primary>
    | &lt;datetime value function>

&lt;time zone> ::=
    AT &lt;time zone specifier>

&lt;time zone specifier> ::=
      LOCAL
    | TIME ZONE &lt;interval value expression>

&lt;length expression> ::=
      &lt;char length expression>
    | &lt;octet length expression>
    | &lt;bit length expression>

&lt;char length expression> ::=
    ( CHAR_LENGTH | CHARACTER_LENGTH )
        &lt;left paren> &lt;string value expression> &lt;right paren>

&lt;string value expression> ::=
      &lt;character value expression>
    | &lt;bit value expression>

&lt;octet length expression> ::=
    OCTET_LENGTH &lt;left paren> &lt;string value expression> &lt;right paren>

&lt;bit length expression> ::=
    BIT_LENGTH &lt;left paren> &lt;string value expression> &lt;right paren>

&lt;null specification> ::=
    NULL

&lt;default specification> ::=
    DEFAULT

&lt;row value constructor list> ::=
    &lt;row value constructor element>
        [ ( &lt;comma> &lt;row value constructor element> )... ]

&lt;row subquery> ::= &lt;subquery>

&lt;comp op> ::=
      &lt;equals operator>
    | &lt;not equals operator>
    | &lt;less than operator>
    | &lt;greater than operator>
    | &lt;less than or equals operator>
    | &lt;greater than or equals operator>

&lt;between predicate> ::=
    &lt;row value constructor> [ NOT ] BETWEEN
      &lt;row value constructor> AND &lt;row value constructor>

&lt;in predicate> ::=
    &lt;row value constructor>
      [ NOT ] IN &lt;in predicate value>

&lt;in predicate value> ::=
      &lt;table subquery>
    | &lt;left paren> &lt;in value list> &lt;right paren>

&lt;in value list> ::=
    &lt;value expression> ( &lt;comma> &lt;value expression> )...

&lt;like predicate> ::=
    &lt;match value> [ NOT ] LIKE &lt;pattern>
      [ ESCAPE &lt;escape character> ]

&lt;match value> ::= &lt;character value expression>

&lt;pattern> ::= &lt;character value expression>

&lt;escape character> ::= &lt;character value expression>

&lt;null predicate> ::= &lt;row value constructor>
    IS [ NOT ] NULL

&lt;quantified comparison predicate> ::=
    &lt;row value constructor> &lt;comp op> &lt;quantifier> &lt;table subquery>

&lt;quantifier> ::= &lt;all> | &lt;some>

&lt;all> ::= ALL

&lt;some> ::= SOME | ANY

&lt;exists predicate> ::= EXISTS &lt;table subquery>

&lt;unique predicate> ::= UNIQUE &lt;table subquery>

&lt;match predicate> ::=
    &lt;row value constructor> MATCH [ UNIQUE ]
        [ PARTIAL | FULL ] &lt;table subquery>

&lt;overlaps predicate> ::=
    &lt;row value constructor 1> OVERLAPS &lt;row value constructor 2>

&lt;row value constructor 1> ::= &lt;row value constructor>

&lt;row value constructor 2> ::= &lt;row value constructor>

&lt;truth value> ::=
      TRUE
    | FALSE
    | UNKNOWN

&lt;constraint attributes> ::=
      &lt;constraint check time> [ [ NOT ] DEFERRABLE ]
    | [ NOT ] DEFERRABLE [ &lt;constraint check time> ]

&lt;constraint check time> ::=
      INITIALLY DEFERRED
    | INITIALLY IMMEDIATE

&lt;table constraint definition> ::=
    [ &lt;constraint name definition> ]
    &lt;table constraint> [ &lt;constraint attributes> ]

&lt;table constraint> ::=
      &lt;unique constraint definition>
    | &lt;referential constraint definition>
    | &lt;check constraint definition>

&lt;unique constraint definition> ::=
            &lt;unique specification> even in SQL3)
    &lt;unique specification>
      &lt;left paren> &lt;unique column list> &lt;right paren>

&lt;unique column list> ::= &lt;column name list>

&lt;referential constraint definition> ::=
    FOREIGN KEY
        &lt;left paren> &lt;referencing columns> &lt;right paren>
      &lt;references specification>

&lt;referencing columns> ::=
    &lt;reference column list>

&lt;module contents> ::=
      &lt;declare cursor>
    | &lt;dynamic declare cursor>
    | &lt;procedure>

&lt;declare cursor> ::=
    DECLARE &lt;cursor name> [ INSENSITIVE ] [ SCROLL ] CURSOR
      FOR &lt;cursor specification>

&lt;cursor name> ::= &lt;identifier>

&lt;cursor specification> ::=
    &lt;query expression> [ &lt;order by clause> ]
      [ &lt;updatability clause> ]

&lt;order by clause> ::=
    ORDER BY &lt;sort specification list>

&lt;sort specification list> ::=
    &lt;sort specification> [ ( &lt;comma> &lt;sort specification> )... ]

&lt;sort specification> ::=
    &lt;sort key> [ &lt;collate clause> ] [ &lt;ordering specification> ]

&lt;sort key> ::=
      &lt;column name>
    | &lt;unsigned integer>

&lt;ordering specification> ::= ASC | DESC

&lt;updatability clause> ::=
    FOR
        ( READ ONLY |
          UPDATE [ OF &lt;column name list> ] )

&lt;dynamic declare cursor> ::=
    DECLARE &lt;cursor name> [ INSENSITIVE ] [ SCROLL ] CURSOR
        FOR &lt;statement name>

&lt;statement name> ::= &lt;identifier>

&lt;procedure> ::=
    PROCEDURE &lt;procedure name>
        &lt;parameter declaration list> &lt;semicolon>
      &lt;SQL procedure statement> &lt;semicolon>

&lt;procedure name> ::= &lt;identifier>

&lt;parameter declaration list> ::=
      &lt;left paren> &lt;parameter declaration>
          [ ( &lt;comma> &lt;parameter declaration> )... ] &lt;right paren>
    | &lt;parameter declaration>...

&lt;parameter declaration> ::=
      &lt;parameter name> &lt;data type>
    | &lt;status parameter>

&lt;status parameter> ::=
    SQLCODE | SQLSTATE

&lt;SQL procedure statement> ::=
      &lt;SQL schema statement>
    | &lt;SQL data statement>
    | &lt;SQL transaction statement>
    | &lt;SQL connection statement>
    | &lt;SQL session statement>
    | &lt;SQL dynamic statement>
    | &lt;SQL diagnostics statement>

&lt;SQL schema statement> ::=
      &lt;SQL schema definition statement>
    | &lt;SQL schema manipulation statement>

&lt;SQL schema definition statement> ::=
      &lt;schema definition>
    | &lt;table definition>
    | &lt;view definition>
    | &lt;grant statement>
    | &lt;domain definition>
    | &lt;character set definition>
    | &lt;collation definition>
    | &lt;translation definition>
    | &lt;assertion definition>

&lt;schema definition> ::=
    CREATE SCHEMA &lt;schema name clause>
      [ &lt;schema character set specification> ]
      [ &lt;schema element>... ]

&lt;schema name clause> ::=
      &lt;schema name>
    | AUTHORIZATION &lt;schema authorization identifier>
    | &lt;schema name> AUTHORIZATION
          &lt;schema authorization identifier>

&lt;schema authorization identifier> ::=
    &lt;authorization identifier>

&lt;schema character set specification> ::=
    DEFAULT CHARACTER
        SET &lt;character set specification>

&lt;schema element> ::=
      &lt;domain definition>
    | &lt;table definition>
    | &lt;view definition>
    | &lt;grant statement>
    | &lt;assertion definition>
    | &lt;character set definition>
    | &lt;collation definition>
    | &lt;translation definition>

&lt;domain definition> ::=
    CREATE DOMAIN &lt;domain name>
        [ AS ] &lt;data type>
      [ &lt;default clause> ]
      [ &lt;domain constraint>... ]
      [ &lt;collate clause> ]

&lt;domain constraint> ::=
    [ &lt;constraint name definition> ]
    &lt;check constraint definition> [ &lt;constraint attributes> ]

&lt;table definition> ::=
    CREATE [ ( GLOBAL | LOCAL ) TEMPORARY ] TABLE
        &lt;table name>
      &lt;table element list>
      [ ON COMMIT ( DELETE | PRESERVE ) ROWS ]

&lt;view definition> ::=
    CREATE VIEW &lt;table name> [ &lt;left paren> &lt;view column list>
                                  &lt;right paren> ]
      AS &lt;query expression>
      [ WITH [ &lt;levels clause> ] CHECK OPTION ]

&lt;view column list> ::= &lt;column name list>

&lt;levels clause> ::=
    CASCADED | LOCAL

&lt;grant statement> ::=
   GRANT &lt;privileges> ON &lt;object name>
     TO &lt;grantee> [ ( &lt;comma> &lt;grantee> )... ]
       [ WITH GRANT OPTION ]

&lt;privileges> ::=
      ALL PRIVILEGES
    | &lt;action list>

&lt;action list> ::= &lt;action> [ ( &lt;comma> &lt;action> )... ]

&lt;action> ::=
      SELECT
    | DELETE
    | INSERT [ &lt;left paren> &lt;privilege column list> &lt;right paren> ]
    | UPDATE [ &lt;left paren> &lt;privilege column list> &lt;right paren> ]
    | REFERENCES [ &lt;left paren> &lt;privilege column list> &lt;right paren> ]
    | USAGE

&lt;privilege column list> ::= &lt;column name list>

&lt;object name> ::=
      [ TABLE ] &lt;table name>
    | DOMAIN &lt;domain name>
    | COLLATION &lt;collation name>
    | CHARACTER SET &lt;character set name>
    | TRANSLATION &lt;translation name>

&lt;grantee> ::=
      PUBLIC
    | &lt;authorization identifier>

&lt;assertion definition> ::=
    CREATE ASSERTION &lt;constraint name> &lt;assertion check>
      [ &lt;constraint attributes> ]

&lt;assertion check> ::=
    CHECK
        &lt;left paren> &lt;search condition> &lt;right paren>

&lt;character set definition> ::=
    CREATE CHARACTER SET &lt;character set name>
        [ AS ]
      &lt;character set source>
      [ &lt;collate clause> | &lt;limited collation definition> ]

&lt;character set source> ::=
      GET &lt;existing character set name>

&lt;existing character set name> ::=
      &lt;standard character repertoire name>
    | &lt;implementation-defined character repertoire name>
    | &lt;schema character set name>

&lt;schema character set name> ::= &lt;character set name>

&lt;limited collation definition> ::=
    COLLATION FROM &lt;collation source>

&lt;collation source> ::=
      &lt;collating sequence definition>
    | &lt;translation collation>

&lt;collating sequence definition> ::=
      &lt;external collation>
    | &lt;schema collation name>
    | DESC &lt;left paren> &lt;collation name> &lt;right paren>
    | DEFAULT

&lt;external collation> ::=
    EXTERNAL &lt;left paren> &lt;quote> &lt;external collation name> &lt;quote> &lt;right paren>

&lt;external collation name> ::=
      &lt;standard collation name>
    | &lt;implementation-defined collation name>

&lt;standard collation name> ::= &lt;collation name>

&lt;implementation-defined collation name> ::= &lt;collation name>

&lt;schema collation name> ::= &lt;collation name>

&lt;translation collation> ::=
    TRANSLATION &lt;translation name>
        [ THEN COLLATION &lt;collation name> ]

&lt;collation definition> ::=
    CREATE COLLATION &lt;collation name> FOR
        &lt;character set specification>
      FROM &lt;collation source>
        [ &lt;pad attribute> ]

&lt;pad attribute> ::=
      NO PAD
    | PAD SPACE

&lt;translation definition> ::=
    CREATE TRANSLATION &lt;translation name>
      FOR &lt;source character set specification>
        TO &lt;target character set specification>
      FROM &lt;translation source>

&lt;source character set specification> ::= &lt;character set specification>

&lt;target character set specification> ::= &lt;character set specification>

&lt;translation source> ::=
      &lt;translation specification>

&lt;translation specification> ::=
      &lt;external translation>
    | IDENTITY
    | &lt;schema translation name>

&lt;external translation> ::=
    EXTERNAL &lt;left paren> &lt;quote> &lt;external translation name> &lt;quote> &lt;right paren>

&lt;external translation name> ::=
      &lt;standard translation name>
    | &lt;implementation-defined translation name>

&lt;standard translation name> ::= &lt;translation name>

&lt;implementation-defined translation name> ::= &lt;translation name>

&lt;schema translation name> ::= &lt;translation name>

&lt;SQL schema manipulation statement> ::=
      &lt;drop schema statement>
    | &lt;alter table statement>
    | &lt;drop table statement>
    | &lt;drop view statement>
    | &lt;revoke statement>
    | &lt;alter domain statement>
    | &lt;drop domain statement>
    | &lt;drop character set statement>
    | &lt;drop collation statement>
    | &lt;drop translation statement>
    | &lt;drop assertion statement>

&lt;drop schema statement> ::=
    DROP SCHEMA &lt;schema name> &lt;drop behavior>

&lt;drop behavior> ::= CASCADE | RESTRICT

&lt;alter table statement> ::=
    ALTER TABLE &lt;table name> &lt;alter table action>

&lt;alter table action> ::=
      &lt;add column definition>
    | &lt;alter column definition>
    | &lt;drop column definition>
    | &lt;add table constraint definition>
    | &lt;drop table constraint definition>

&lt;add column definition> ::=
    ADD [ COLUMN ] &lt;column definition>

&lt;alter column definition> ::=
    ALTER [ COLUMN ] &lt;column name> &lt;alter column action>

&lt;alter column action> ::=
      &lt;set column default clause>
    | &lt;drop column default clause>

&lt;set column default clause> ::=
    SET &lt;default clause>

&lt;drop column default clause> ::=
    DROP DEFAULT

&lt;drop column definition> ::=
    DROP [ COLUMN ] &lt;column name> &lt;drop behavior>

&lt;add table constraint definition> ::=
    ADD &lt;table constraint definition>

&lt;drop table constraint definition> ::=
    DROP CONSTRAINT &lt;constraint name> &lt;drop behavior>

&lt;drop table statement> ::=
    DROP TABLE &lt;table name> &lt;drop behavior>

&lt;drop view statement> ::=
    DROP VIEW &lt;table name> &lt;drop behavior>

&lt;revoke statement> ::=
    REVOKE [ GRANT OPTION FOR ]
        &lt;privileges>
        ON &lt;object name>
      FROM &lt;grantee> [ ( &lt;comma> &lt;grantee> )... ] &lt;drop behavior>

&lt;alter domain statement> ::=
    ALTER DOMAIN &lt;domain name> &lt;alter domain action>

&lt;alter domain action> ::=
      &lt;set domain default clause>
    | &lt;drop domain default clause>
    | &lt;add domain constraint definition>
    | &lt;drop domain constraint definition>

&lt;set domain default clause> ::= SET &lt;default clause>

&lt;drop domain default clause> ::= DROP DEFAULT

&lt;add domain constraint definition> ::=
    ADD &lt;domain constraint>

&lt;drop domain constraint definition> ::=
    DROP CONSTRAINT &lt;constraint name>

&lt;drop domain statement> ::=
    DROP DOMAIN &lt;domain name> &lt;drop behavior>

&lt;drop character set statement> ::=
    DROP CHARACTER SET &lt;character set name>

&lt;drop collation statement> ::=
    DROP COLLATION &lt;collation name>

&lt;drop translation statement> ::=
    DROP TRANSLATION &lt;translation name>

&lt;drop assertion statement> ::=
    DROP ASSERTION &lt;constraint name>

&lt;SQL data statement> ::=
      &lt;open statement>
    | &lt;fetch statement>
    | &lt;close statement>
    | &lt;select statement: single row>
    | &lt;SQL data change statement>

&lt;open statement> ::=
    OPEN &lt;cursor name>

&lt;fetch statement> ::=
    FETCH [ [ &lt;fetch orientation> ] FROM ]
      &lt;cursor name> INTO &lt;fetch target list>

&lt;fetch orientation> ::=
      NEXT
    | PRIOR
    | FIRST
    | LAST
    | ( ABSOLUTE | RELATIVE ) &lt;simple value specification>

&lt;simple value specification> ::=
      &lt;parameter name>
    | &lt;embedded variable name>
    | &lt;literal>

&lt;fetch target list> ::=
    &lt;target specification> [ ( &lt;comma> &lt;target specification> )... ]

&lt;target specification> ::=
      &lt;parameter specification>
    | &lt;variable specification>

&lt;close statement> ::=
    CLOSE &lt;cursor name>

&lt;select statement: single row> ::=
    SELECT [ &lt;set quantifier> ] &lt;select list>
      INTO &lt;select target list>
        &lt;table expression>

&lt;select target list> ::=
    &lt;target specification> [ ( &lt;comma> &lt;target specification> )... ]

&lt;SQL data change statement> ::=
      &lt;delete statement: positioned>
    | &lt;delete statement: searched>
    | &lt;insert statement>
    | &lt;update statement: positioned>
    | &lt;update statement: searched>

&lt;delete statement: positioned> ::=
    DELETE FROM &lt;table name>
      WHERE CURRENT OF &lt;cursor name>

&lt;delete statement: searched> ::=
    DELETE FROM &lt;table name>
      [ WHERE &lt;search condition> ]

&lt;insert statement> ::=
    INSERT INTO &lt;table name>
      &lt;insert columns and source>

&lt;insert columns and source> ::=
      [ &lt;left paren> &lt;insert column list> &lt;right paren> ]
            &lt;query expression>
    | DEFAULT VALUES

&lt;insert column list> ::= &lt;column name list>

&lt;update statement: positioned> ::=
    UPDATE &lt;table name>
      SET &lt;set clause list>
        WHERE CURRENT OF &lt;cursor name>

&lt;set clause list> ::=
    &lt;set clause> [ ( &lt;comma> &lt;set clause> )... ]

&lt;set clause> ::=
    &lt;object column> &lt;equals operator> &lt;update source>

&lt;object column> ::= &lt;column name>

&lt;update source> ::=
      &lt;value expression>
    | &lt;null specification>
    | DEFAULT

&lt;update statement: searched> ::=
    UPDATE &lt;table name>
      SET &lt;set clause list>
      [ WHERE &lt;search condition> ]

&lt;SQL transaction statement> ::=
      &lt;set transaction statement>
    | &lt;set constraints mode statement>
    | &lt;commit statement>
    | &lt;rollback statement>

&lt;set transaction statement> ::=
    SET TRANSACTION &lt;transaction mode>
        [ ( &lt;comma> &lt;transaction mode> )... ]

&lt;transaction mode> ::=
      &lt;isolation level>
    | &lt;transaction access mode>
    | &lt;diagnostics size>

&lt;isolation level> ::=
    ISOLATION LEVEL &lt;level of isolation>

&lt;level of isolation> ::=
      READ UNCOMMITTED
    | READ COMMITTED
    | REPEATABLE READ
    | SERIALIZABLE

&lt;transaction access mode> ::=
      READ ONLY
    | READ WRITE

&lt;diagnostics size> ::=
    DIAGNOSTICS SIZE &lt;number of conditions>

&lt;number of conditions> ::= &lt;simple value specification>

&lt;set constraints mode statement> ::=
    SET CONSTRAINTS &lt;constraint name list>
        ( DEFERRED | IMMEDIATE )

&lt;constraint name list> ::=
      ALL
    | &lt;constraint name> [ ( &lt;comma> &lt;constraint name> )... ]

&lt;commit statement> ::=
    COMMIT [ WORK ]

&lt;rollback statement> ::=
    ROLLBACK [ WORK ]

&lt;SQL connection statement> ::=
      &lt;connect statement>
    | &lt;set connection statement>
    | &lt;disconnect statement>

&lt;connect statement> ::=
    CONNECT TO &lt;connection target>

&lt;connection target> ::=
      &lt;SQL-server name>
        [ AS &lt;connection name> ]
          correspondence with Tony Gordon)
        [ USER &lt;user name> ]
    | DEFAULT

&lt;SQL-server name> ::= &lt;simple value specification>

&lt;connection name> ::= &lt;simple value specification>

&lt;user name> ::= &lt;simple value specification>

&lt;set connection statement> ::=
    SET CONNECTION &lt;connection object>

&lt;connection object> ::=
      DEFAULT
    | &lt;connection name>

&lt;disconnect statement> ::=
    DISCONNECT &lt;disconnect object>

&lt;disconnect object> ::=
      &lt;connection object>
    | ALL
    | CURRENT

&lt;SQL session statement> ::=
      &lt;set catalog statement>
    | &lt;set schema statement>
    | &lt;set names statement>
    | &lt;set session authorization identifier statement>
    | &lt;set local time zone statement>

&lt;set catalog statement> ::=
    SET CATALOG &lt;value specification>

&lt;value specification> ::=
      &lt;literal>
    | &lt;general value specification>

&lt;set schema statement> ::=
    SET SCHEMA &lt;value specification>

&lt;set names statement> ::=
    SET NAMES &lt;value specification>

&lt;set session authorization identifier statement> ::=
    SET SESSION AUTHORIZATION
        &lt;value specification>

&lt;set local time zone statement> ::=
    SET TIME ZONE
        &lt;set time zone value>

&lt;set time zone value> ::=
      &lt;interval value expression>
    | LOCAL

&lt;SQL dynamic statement> ::=
      &lt;system descriptor statement>
    | &lt;prepare statement>
    | &lt;deallocate prepared statement>
    | &lt;describe statement>
    | &lt;execute statement>
    | &lt;execute immediate statement>
    | &lt;SQL dynamic data statement>

&lt;system descriptor statement> ::=
      &lt;allocate descriptor statement>
    | &lt;deallocate descriptor statement>
    | &lt;set descriptor statement>
    | &lt;get descriptor statement>

&lt;allocate descriptor statement> ::=
    ALLOCATE DESCRIPTOR &lt;descriptor name>
       [ WITH MAX &lt;occurrences> ]

&lt;descriptor name> ::=
    [ &lt;scope option> ] &lt;simple value specification>

&lt;scope option> ::=
      GLOBAL
    | LOCAL

&lt;occurrences> ::= &lt;simple value specification>

&lt;deallocate descriptor statement> ::=
    DEALLOCATE DESCRIPTOR &lt;descriptor name>

&lt;set descriptor statement> ::=
    SET DESCRIPTOR &lt;descriptor name>
        &lt;set descriptor information>

&lt;set descriptor information> ::=
      &lt;set count>
    | VALUE &lt;item number>
        &lt;set item information> [ ( &lt;comma> &lt;set item information> )... ]

&lt;set count> ::=
    COUNT &lt;equals operator> &lt;simple value specification 1>

&lt;simple value specification 1> ::= &lt;simple value specification>

&lt;item number> ::= &lt;simple value specification>

&lt;set item information> ::=
    &lt;descriptor item name> &lt;equals operator> &lt;simple value specification 2>

&lt;descriptor item name> ::=
      TYPE
    | LENGTH
    | OCTET_LENGTH
    | RETURNED_LENGTH
    | RETURNED_OCTET_LENGTH
    | PRECISION
    | SCALE
    | DATETIME_INTERVAL_CODE
    | DATETIME_INTERVAL_PRECISION
    | NULLABLE
    | INDICATOR
    | DATA
    | NAME
    | UNNAMED
    | COLLATION_CATALOG
    | COLLATION_SCHEMA
    | COLLATION_NAME
    | CHARACTER_SET_CATALOG
    | CHARACTER_SET_SCHEMA
    | CHARACTER_SET_NAME

&lt;simple value specification 2> ::= &lt;simple value specification>

&lt;item number> ::= &lt;simple value specification>

&lt;get descriptor statement> ::=
    GET DESCRIPTOR &lt;descriptor name> &lt;get descriptor information>

&lt;get descriptor information> ::=
      &lt;get count>
    | VALUE &lt;item number>
        &lt;get item information> [ ( &lt;comma> &lt;get item information> )... ]

&lt;get count> ::=
    &lt;simple target specification 1> &lt;equals operator>
         COUNT

&lt;simple target specification 1> ::= &lt;simple target specification>

&lt;simple target specification> ::=
      &lt;parameter name>
    | &lt;embedded variable name>

&lt;get item information> ::=
    &lt;simple target specification 2> &lt;equals operator> &lt;descriptor item name>>

&lt;simple target specification 2> ::= &lt;simple target specification>

&lt;prepare statement> ::=
    PREPARE &lt;SQL statement name> FROM &lt;SQL statement variable>

&lt;SQL statement name> ::=
      &lt;statement name>
    | &lt;extended statement name>

&lt;extended statement name> ::=
    [ &lt;scope option> ] &lt;simple value specification>

&lt;SQL statement variable> ::= &lt;simple value specification>

&lt;deallocate prepared statement> ::=
    DEALLOCATE PREPARE &lt;SQL statement name>

&lt;describe statement> ::=
      &lt;describe input statement>
    | &lt;describe output statement>

&lt;describe input statement> ::=
    DESCRIBE INPUT &lt;SQL statement name> &lt;using descriptor>

&lt;using descriptor> ::=
    ( USING | INTO ) SQL DESCRIPTOR &lt;descriptor name>

&lt;describe output statement> ::=
    DESCRIBE [ OUTPUT ] &lt;SQL statement name> &lt;using descriptor>

&lt;execute statement> ::=
    EXECUTE &lt;SQL statement name>
      [ &lt;result using clause> ]
      [ &lt;parameter using clause> ]

&lt;result using clause> ::= &lt;using clause>

&lt;using clause> ::=
      &lt;using arguments>
    | &lt;using descriptor>

&lt;using arguments> ::=
    ( USING | INTO ) &lt;argument> [ ( &lt;comma> &lt;argument> )... ]

&lt;argument> ::= &lt;target specification>

&lt;parameter using clause> ::= &lt;using clause>

&lt;execute immediate statement> ::=
    EXECUTE IMMEDIATE &lt;SQL statement variable>

&lt;SQL dynamic data statement> ::=
      &lt;allocate cursor statement>
    | &lt;dynamic open statement>
    | &lt;dynamic fetch statement>
    | &lt;dynamic close statement>
    | &lt;dynamic delete statement: positioned>
    | &lt;dynamic update statement: positioned>

&lt;allocate cursor statement> ::=
    ALLOCATE &lt;extended cursor name> [ INSENSITIVE ]
        [ SCROLL ] CURSOR
      FOR &lt;extended statement name>

&lt;extended cursor name> ::=
    [ &lt;scope option> ] &lt;simple value specification>

&lt;dynamic open statement> ::=
    OPEN &lt;dynamic cursor name> [ &lt;using clause> ]

&lt;dynamic cursor name> ::=
      &lt;cursor name>
    | &lt;extended cursor name>

&lt;dynamic fetch statement> ::=
    FETCH [ [ &lt;fetch orientation> ] FROM ] &lt;dynamic cursor name>
        &lt;using clause>

&lt;dynamic close statement> ::=
    CLOSE &lt;dynamic cursor name>

&lt;dynamic delete statement: positioned> ::=
    DELETE FROM &lt;table name>
      WHERE CURRENT OF
          &lt;dynamic cursor name>

&lt;dynamic update statement: positioned> ::=
    UPDATE &lt;table name>
      SET &lt;set clause>
          [ ( &lt;comma> &lt;set clause> )... ]
        WHERE CURRENT OF
            &lt;dynamic cursor name>

&lt;SQL diagnostics statement> ::=
    &lt;get diagnostics statement>

&lt;get diagnostics statement> ::=
    GET DIAGNOSTICS &lt;sql diagnostics information>

&lt;sql diagnostics information> ::=
      &lt;statement information>
    | &lt;condition information>

&lt;statement information> ::=
    &lt;statement information item> [ ( &lt;comma> &lt;statement information item> )... ]

&lt;statement information item> ::=
    &lt;simple target specification> &lt;equals operator> &lt;statement information item name>

&lt;statement information item name> ::=
      NUMBER
    | MORE
    | COMMAND_FUNCTION
    | DYNAMIC_FUNCTION
    | ROW_COUNT

&lt;condition information> ::=
    EXCEPTION &lt;condition number>
      &lt;condition information item> [ ( &lt;comma> &lt;condition information item> )... ]

&lt;condition number> ::= &lt;simple value specification>

&lt;condition information item> ::=
    &lt;simple target specification> &lt;equals operator> &lt;condition information item name>

&lt;condition information item name> ::=
      CONDITION_NUMBER
    | RETURNED_SQLSTATE
    | CLASS_ORIGIN
    | SUBCLASS_ORIGIN
    | SERVER_NAME
    | CONNECTION_NAME
    | CONSTRAINT_CATALOG
    | CONSTRAINT_SCHEMA
    | CONSTRAINT_NAME
    | CATALOG_NAME
    | SCHEMA_NAME
    | TABLE_NAME
    | COLUMN_NAME
    | CURSOR_NAME
    | MESSAGE_TEXT
    | MESSAGE_LENGTH
    | MESSAGE_OCTET_LENGTH

&lt;embedded SQL host program> ::=
      &lt;embedded SQL Ada program>
    | &lt;embedded SQL C program>
    | &lt;embedded SQL COBOL program>
    | &lt;embedded SQL Fortran program>
    | &lt;embedded SQL MUMPS program>
    | &lt;embedded SQL Pascal program>
    | &lt;embedded SQL PL/I program>

&lt;embedded SQL Ada program> ::= !! &lt;EMPHASIS>(See the Syntax Rules.)

&lt;embedded SQL C program> ::=
      !! &lt;EMPHASIS>(See the Syntax Rules.)

&lt;embedded SQL COBOL program> ::= !! &lt;EMPHASIS>(See the Syntax Rules.)

&lt;embedded SQL Fortran program> ::=
    !! &lt;EMPHASIS>(See the Syntax Rules.)

&lt;embedded SQL MUMPS program> ::= !! &lt;EMPHASIS>(See the Syntax Rules.)

&lt;embedded SQL Pascal program> ::=
    !! &lt;EMPHASIS>(See the Syntax Rules.)

&lt;embedded SQL PL/I program> ::= !! &lt;EMPHASIS>(See the Syntax Rules.)

&lt;embedded SQL declare section> ::=
      &lt;embedded SQL begin declare>
        [ &lt;embedded character set declaration> ]
        [ &lt;host variable definition>... ]
      &lt;embedded SQL end declare>
    | &lt;embedded SQL MUMPS declare>

&lt;embedded SQL begin declare> ::=
    &lt;SQL prefix> BEGIN DECLARE SECTION
        [ &lt;SQL terminator> ]

&lt;SQL prefix> ::=
      EXEC SQL
    | &lt;ampersand>SQL&lt;left paren>

&lt;SQL terminator> ::=
      END-EXEC
    | &lt;semicolon>
    | &lt;right paren>

&lt;embedded character set declaration> ::=
    SQL NAMES ARE &lt;character set specification>

&lt;host variable definition> ::=
      &lt;Ada variable definition>
    | &lt;C variable definition>
    | &lt;COBOL variable definition>
    | &lt;Fortran variable definition>
    | &lt;MUMPS variable definition>
    | &lt;Pascal variable definition>
    | &lt;PL/I variable definition>

&lt;Ada variable definition> ::=
    &lt;Ada host identifier> [ ( &lt;comma> &lt;Ada host identifier> )... ] :
    &lt;Ada type specification> [ &lt;Ada initial value> ]

&lt;Ada type specification> ::=
      &lt;Ada qualified type specification>
    | &lt;Ada unqualified type specification>

&lt;Ada qualified type specification> ::=
      SQL_STANDARD.CHAR [ CHARACTER SET
         [ IS ] &lt;character set specification> ]
          &lt;left paren> 1 &lt;double period> &lt;length> &lt;right paren>
    | SQL_STANDARD.BIT
          &lt;left paren> 1 &lt;double period> &lt;length> &lt;right paren>
    | SQL_STANDARD.SMALLINT
    | SQL_STANDARD.INT
    | SQL_STANDARD.REAL
    | SQL_STANDARD.DOUBLE_PRECISION
    | SQL_STANDARD.SQLCODE_TYPE
    | SQL_STANDARD.SQLSTATE_TYPE
    | SQL_STANDARD.INDICATOR_TYPE

&lt;Ada unqualified type specification> ::=
      CHAR
          &lt;left paren> 1 &lt;double period> &lt;length> &lt;right paren>
    | BIT
          &lt;left paren> 1 &lt;double period> &lt;length> &lt;right paren>
    | SMALLINT
    | INT
    | REAL
    | DOUBLE_PRECISION
    | SQLCODE_TYPE
    | SQLSTATE_TYPE
    | INDICATOR_TYPE

&lt;Ada initial value> ::=
    &lt;Ada assignment operator> &lt;character representation>...

&lt;Ada assignment operator> ::= &lt;colon>&lt;equals operator>

&lt;C variable definition> ::=
      [ &lt;C storage class> ]
      [ &lt;C class modifier> ]
      &lt;C variable specification>
    &lt;semicolon>

&lt;C storage class> ::=
      auto
    | extern
    | static

&lt;C class modifier> ::= const | volatile

&lt;C variable specification> ::=
      &lt;C numeric variable>
    | &lt;C character variable>
    | &lt;C derived variable>

&lt;C numeric variable> ::=
    ( long | short | float | double )
      &lt;C host identifier> [ &lt;C initial value> ]
            [ ( &lt;comma> &lt;C host identifier> [ &lt;C initial value> ] )... ]

&lt;C initial value> ::=
    &lt;equals operator> &lt;character representation>...

&lt;C character variable> ::=
    char [ CHARACTER SET
             [ IS ] &lt;character set specification> ]
      &lt;C host identifier>
        &lt;C array specification> [ &lt;C initial value> ]
        [ ( &lt;comma> &lt;C host identifier>
          &lt;C array specification>
                 [ &lt;C initial value> ] )... ]

&lt;C array specification> ::=
    &lt;left bracket> &lt;length> &lt;right bracket>

&lt;C derived variable> ::=
      &lt;C VARCHAR variable>
    | &lt;C bit variable>

&lt;C VARCHAR variable> ::=
    VARCHAR [ CHARACTER SET [ IS ]
        &lt;character set specification> ]
        &lt;C host identifier>
            &lt;C array specification> [ &lt;C initial value> ]
          [ ( &lt;comma> &lt;C host identifier>
              &lt;C array specification>
                      [ &lt;C initial value> ] )... ]

&lt;C bit variable> ::=
    BIT &lt;C host identifier>
        &lt;C array specification> [ &lt;C initial value> ]
      [ ( &lt;comma> &lt;C host identifier>
        &lt;C array specification>
                   [ &lt;C initial value> ] )... ]

&lt;COBOL variable definition> ::=
    (01|77) &lt;COBOL host identifier> &lt;COBOL type specification>
      [ &lt;character representation>... ] &lt;period>

&lt;COBOL type specification> ::=
      &lt;COBOL character type>
    | &lt;COBOL bit type>
    | &lt;COBOL numeric type>
    | &lt;COBOL integer type>

&lt;COBOL character type> ::=
    [ CHARACTER SET [ IS ]
          &lt;character set specification> ]
    ( PIC | PICTURE ) [ IS ] ( X [ &lt;left paren> &lt;length> &lt;right paren> ] )...

&lt;COBOL bit type> ::=
    ( PIC | PICTURE ) [ IS ]
        ( B [ &lt;left paren> &lt;length> &lt;right paren> ] )...

&lt;COBOL numeric type> ::=
    ( PIC | PICTURE ) [ IS ]
      S &lt;COBOL nines specification>
    [ USAGE [ IS ] ] DISPLAY SIGN LEADING SEPARATE

&lt;COBOL nines specification> ::=
      &lt;COBOL nines> [ V [ &lt;COBOL nines> ] ]
    | V &lt;COBOL nines>

&lt;COBOL nines> ::= ( 9 [ &lt;left paren> &lt;length> &lt;right paren> ] )...

&lt;COBOL integer type> ::=
      &lt;COBOL computational integer>
    | &lt;COBOL binary integer>

&lt;COBOL computational integer> ::=
    ( PIC | PICTURE ) [ IS ] S&lt;COBOL nines>
      [ USAGE [ IS ] ] ( COMP | COMPUTATIONAL )

&lt;COBOL binary integer> ::=
    ( PIC | PICTURE ) [ IS ] S&lt;COBOL nines>
      [ USAGE [ IS ] ] BINARY

&lt;Fortran variable definition> ::=
    &lt;Fortran type specification>
    &lt;Fortran host identifier>
        [ ( &lt;comma> &lt;Fortran host identifier> )... ]

&lt;Fortran type specification> ::=
      CHARACTER [ &lt;asterisk> &lt;length> ]
          [ CHARACTER SET [ IS ]
                &lt;character set specification> ]
    | BIT [ &lt;asterisk> &lt;length> ]
    | INTEGER
    | REAL
    | DOUBLE PRECISION

&lt;MUMPS variable definition> ::=
    ( &lt;MUMPS numeric variable> | &lt;MUMPS character variable> )
        &lt;semicolon>

&lt;MUMPS numeric variable> ::=
    &lt;MUMPS type specification>
      &lt;MUMPS host identifier> [ ( &lt;comma> &lt;MUMPS host identifier> )... ]

&lt;MUMPS type specification> ::=
      INT
    | DEC
          [ &lt;left paren> &lt;precision> [ &lt;comma> &lt;scale> ] &lt;right paren> ]
    | REAL

&lt;MUMPS character variable> ::=
    VARCHAR &lt;MUMPS host identifier> &lt;MUMPS length specification>
      [ ( &lt;comma> &lt;MUMPS host identifier> &lt;MUMPS length specification> )... ]

&lt;MUMPS length specification> ::=
    &lt;left paren> &lt;length> &lt;right paren>

&lt;Pascal variable definition> ::=
    &lt;Pascal host identifier> [ ( &lt;comma> &lt;Pascal host identifier> )... ] &lt;colon>
      &lt;Pascal type specification> &lt;semicolon>

&lt;Pascal type specification> ::=
      PACKED ARRAY
          &lt;left bracket> 1 &lt;double period> &lt;length> &lt;right bracket>
        OF CHAR
          [ CHARACTER SET [ IS ]
                &lt;character set specification> ]
    | PACKED ARRAY
          &lt;left bracket> 1 &lt;double period> &lt;length> &lt;right bracket>
        OF BIT
    | INTEGER
    | REAL
    | CHAR [ CHARACTER SET
                                [ IS ] &lt;character set specification> ]
    | BIT

&lt;PL/I variable definition> ::=
    (DCL | DECLARE)
        (   &lt;PL/I host identifier>
          | &lt;left paren> &lt;PL/I host identifier>
                [ ( &lt;comma> &lt;PL/I host identifier> )... ] &lt;right paren> )
    &lt;PL/I type specification>
    [ &lt;character representation>... ] &lt;semicolon>

&lt;PL/I type specification> ::=
      ( CHAR | CHARACTER ) [ VARYING ]
          &lt;left paren>&lt;length>&lt;right paren>
          [ CHARACTER SET
                [ IS ] &lt;character set specification> ]
    | BIT [ VARYING ] &lt;left paren>&lt;length>&lt;right paren>
    | &lt;PL/I type fixed decimal> &lt;left paren> &lt;precision>
          [ &lt;comma> &lt;scale> ] &lt;right paren>
    | &lt;PL/I type fixed binary> [ &lt;left paren> &lt;precision> &lt;right paren> ]
    | &lt;PL/I type float binary> &lt;left paren> &lt;precision> &lt;right paren>

&lt;PL/I type fixed decimal> ::=
      ( DEC | DECIMAL ) FIXED
    | FIXED ( DEC | DECIMAL )

&lt;PL/I type fixed binary> ::=
      ( BIN | BINARY ) FIXED
    | FIXED ( BIN | BINARY )

&lt;PL/I type float binary> ::=
      ( BIN | BINARY ) FLOAT
    | FLOAT ( BIN | BINARY )

&lt;embedded SQL end declare> ::=
    &lt;SQL prefix> END DECLARE SECTION
        [ &lt;SQL terminator> ]

&lt;embedded SQL MUMPS declare> ::=
    &lt;SQL prefix>
      BEGIN DECLARE SECTION
        [ &lt;embedded character set declaration> ]
        [ &lt;host variable definition>... ]
      END DECLARE SECTION
    &lt;SQL terminator>

&lt;embedded SQL statement> ::=
    &lt;SQL prefix>
      &lt;statement or declaration>
    [ &lt;SQL terminator> ]

&lt;statement or declaration> ::=
      &lt;declare cursor>
    | &lt;dynamic declare cursor>
    | &lt;temporary table declaration>
    | &lt;embedded exception declaration>
    | &lt;SQL procedure statement>

&lt;embedded exception declaration> ::=
    WHENEVER &lt;condition> &lt;condition action>

&lt;condition> ::=
    SQLERROR | NOT FOUND

&lt;condition action> ::=
    CONTINUE | &lt;go to>

&lt;go to> ::=
    ( GOTO | GO TO ) &lt;goto target>

&lt;goto target> ::=
      &lt;host label identifier>
    | &lt;unsigned integer>
    | &lt;host PL/I label variable>

&lt;host label identifier> ::= !!&lt;EMPHASIS>(See the Syntax Rules.)

&lt;host PL/I label variable> ::= !!&lt;EMPHASIS>(See the Syntax Rules.)

&lt;preparable statement> ::=
      &lt;preparable SQL data statement>
    | &lt;preparable SQL schema statement>
    | &lt;preparable SQL transaction statement>
    | &lt;preparable SQL session statement>
    | &lt;preparable implementation-defined statement>

&lt;preparable SQL data statement> ::=
      &lt;delete statement: searched>
    | &lt;dynamic single row select statement>
    | &lt;insert statement>
    | &lt;dynamic select statement>
    | &lt;update statement: searched>
    | &lt;preparable dynamic delete statement: positioned>
    | &lt;preparable dynamic update statement: positioned>

&lt;dynamic single row select statement> ::= &lt;query specification>

&lt;dynamic select statement> ::= &lt;cursor specification>

&lt;preparable dynamic delete statement: positioned> ::=
   DELETE [ FROM &lt;table name> ]
      WHERE CURRENT OF &lt;cursor name>

&lt;preparable dynamic update statement: positioned> ::=
   UPDATE [ &lt;table name> ]
      SET &lt;set clause list>
      WHERE CURRENT OF &lt;cursor name>

&lt;preparable SQL schema statement> ::=
      &lt;SQL schema statement>

&lt;preparable SQL transaction statement> ::=
      &lt;SQL transaction statement>

&lt;preparable SQL session statement> ::=
      &lt;SQL session statement>

&lt;preparable implementation-defined statement> ::=
    !! &lt;EMPHASIS>(See the Syntax Rules.)

&lt;direct SQL statement> ::=
    &lt;directly executable statement> &lt;semicolon>

&lt;directly executable statement> ::=
      &lt;direct SQL data statement>
    | &lt;SQL schema statement>
    | &lt;SQL transaction statement>
    | &lt;SQL connection statement>
    | &lt;SQL session statement>
    | &lt;direct implementation-defined statement>

&lt;direct SQL data statement> ::=
      &lt;delete statement: searched>
    | &lt;direct select statement: multiple rows>
    | &lt;insert statement>
    | &lt;update statement: searched>
    | &lt;temporary table declaration>

&lt;direct select statement: multiple rows> ::=
    &lt;query expression> [ &lt;order by clause> ]

&lt;direct implementation-defined statement> ::=
    !!&lt;EMPHASIS>(See the Syntax Rules)

&lt;SQL object identifier> ::=
    &lt;SQL provenance> &lt;SQL variant>

&lt;SQL provenance> ::= &lt;arc1> &lt;arc2> &lt;arc3>

&lt;arc1> ::= iso | 1 | iso &lt;left paren> 1 &lt;right paren>

&lt;arc2> ::= standard | 0 | standard &lt;left paren> 0 &lt;right paren>

&lt;arc3> ::= 9075

&lt;SQL variant> ::= &lt;SQL edition> &lt;SQL conformance>

&lt;SQL edition> ::= &lt;1987> | &lt;1989> | &lt;1992>

&lt;1987> ::= 0 | edition1987 &lt;left paren> 0 &lt;right paren>

&lt;1989> ::= &lt;1989 base> &lt;1989 package>

&lt;1989 base> ::= 1 | edition1989 &lt;left paren> 1 &lt;right paren>

&lt;1989 package> ::= &lt;integrity no> | &lt;integrity yes>

&lt;integrity no> ::= 0 | IntegrityNo &lt;left paren> 0 &lt;right paren>

&lt;integrity yes> ::= 1 | IntegrityYes &lt;left paren> 1 &lt;right paren>

&lt;1992> ::= 2 | edition1992 &lt;left paren> 2 &lt;right paren>

&lt;SQL conformance> ::= &lt;low> | &lt;intermediate> | &lt;high>

&lt;low> ::= 0 | Low &lt;left paren> 0 &lt;right paren>

&lt;intermediate> ::= 1 | Intermediate &lt;left paren> 1 &lt;right paren>

&lt;high> ::= 2 | High &lt;left paren> 2 &lt;right paren>
</PRE>
</CODE></BLOCKQUOTE>
<HR>
<A HREF="PostgreSQL-HOWTO-39.html"><IMG SRC="../img/next.gif" ALT="Next"></A>
<A HREF="PostgreSQL-HOWTO-37.html"><IMG SRC="../img/prev.gif" ALT="Previous"></A>
<A HREF="PostgreSQL-HOWTO.html#toc38"><IMG SRC="../img/toc.gif" ALT="Contents"></A>
<SCRIPT>EndPage();</SCRIPT>  </BODY>
</HTML>
