<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Linux AX25-HOWTO, Amateur Radio.: AX.25, NetRom, Rose network programming.</TITLE>
 <LINK HREF="AX25-HOWTO-21.html" REL=next>
 <LINK HREF="AX25-HOWTO-19.html" REL=previous>
 <LINK HREF="AX25-HOWTO.html#toc20" REL=contents>
<SCRIPT src="../menu.js"> function BeginPage() {} function EndPage() {} </SCRIPT> </HEAD> <BODY bgcolor=#EEEEFF MARGINHEIGHT=0 MARGINWIDTH=0> <SCRIPT>BeginPage(1, 8, 1);</SCRIPT>
<A HREF="AX25-HOWTO-21.html"><IMG SRC="../img/next.gif" ALT="Next"></A>
<A HREF="AX25-HOWTO-19.html"><IMG SRC="../img/prev.gif" ALT="Previous"></A>
<A HREF="AX25-HOWTO.html#toc20"><IMG SRC="../img/toc.gif" ALT="Contents"></A>
<HR>
<H2><A NAME="s20">20. AX.25, NetRom, Rose network programming.</A></H2>

<P>Probably the biggest advantage of using the kernel based implementations of
the amateur packet radio protocols is the ease with which you can develop
applications and programs to use them.
<P>While the subject of Unix Network Programming is outside the scope of this
document I will describe the elementary details of how you can make use of
the AX.25, NetRom and Rose protocols within your software.
<P>
<H2><A NAME="ss20.1">20.1 The address families.</A>
</H2>

<P>Network programming for AX.25, NetRom and Rose is quite similar to programming
for TCP/IP under Linux. The major differences being the address families used,
and the address structures that need to be mangled into place.
<P>The address family names for AX.25, NetRom and Rose are <CODE>AF_AX25</CODE>,
<CODE>AF_NETROM</CODE> and <CODE>AF_ROSE</CODE> respectively.
<P>
<H2><A NAME="ss20.2">20.2 The header files.</A>
</H2>

<P>You must always include the `<CODE>ax25.h</CODE>' header file, and also the
`<CODE>netrom.h</CODE>' or `<CODE>rose.h</CODE>' header files if you are dealing with those
protocols. Simple top level skeletons would look something like the following:
<P>For AX.25:
<BLOCKQUOTE><CODE>
<PRE>
#include &lt;ax25.h>
int s, addrlen = sizeof(struct full_sockaddr_ax25);
struct full_sockaddr_ax25 sockaddr;
sockaddr.fsa_ax25.sax25_family = AF_AX25
</PRE>
</CODE></BLOCKQUOTE>
<P>For NetRom:
<BLOCKQUOTE><CODE>
<PRE>
#include &lt;ax25.h>
#include &lt;netrom.h>
int s, addrlen = sizeof(struct full_sockaddr_ax25);
struct full_sockaddr_ax25 sockaddr;
sockaddr.fsa_ax25.sax25_family = AF_NETROM;
</PRE>
</CODE></BLOCKQUOTE>
<P>For Rose:
<BLOCKQUOTE><CODE>
<PRE>
#include &lt;ax25.h>
#include &lt;rose.h>
int s, addrlen = sizeof(struct sockaddr_rose);
struct sockaddr_rose sockaddr;
sockaddr.srose_family = AF_ROSE;
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss20.3">20.3 Callsign mangling and examples.</A>
</H2>

<P>There are routines within the <CODE>lib/ax25.a</CODE> library built in the
AX25 utilities package that manage the callsign conversions for you. You can
write your own of course if you wish. 
<P>The <EM>user_call</EM> utilities are excellent examples from which to
work. The source code for them is included in the AX25 utilities package.
If you spend a little time working with those you will soon see that
ninety percent of the work is involved in just getting ready to open the
socket. Actually making the connection is easy, the preparation takes time.
<P>The example are simple enough to not be very confusing. If you have any
questions, you should feel to direct them to the <CODE>linux-hams</CODE> mailing
list and someone there will be sure to help you.
<P>
<HR>
<A HREF="AX25-HOWTO-21.html"><IMG SRC="../img/next.gif" ALT="Next"></A>
<A HREF="AX25-HOWTO-19.html"><IMG SRC="../img/prev.gif" ALT="Previous"></A>
<A HREF="AX25-HOWTO.html#toc20"><IMG SRC="../img/toc.gif" ALT="Contents"></A>
<SCRIPT>EndPage();</SCRIPT>  </BODY>
</HTML>
