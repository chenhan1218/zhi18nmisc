<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Framebuffer HOWTO: What advantages does framebuffer devices have? </TITLE>
 <LINK HREF="Framebuffer-HOWTO-5.html" REL=next>
 <LINK HREF="Framebuffer-HOWTO-3.html" REL=previous>
 <LINK HREF="Framebuffer-HOWTO.html#toc4" REL=contents>
<SCRIPT src="../menu.js"> function BeginPage() {} function EndPage() {} </SCRIPT> </HEAD> <BODY bgcolor=#EEEEFF MARGINHEIGHT=0 MARGINWIDTH=0> <SCRIPT>BeginPage(1, 8, 1);</SCRIPT>
<A HREF="Framebuffer-HOWTO-5.html"><IMG SRC="../img/next.gif" ALT="Next"></A>
<A HREF="Framebuffer-HOWTO-3.html"><IMG SRC="../img/prev.gif" ALT="Previous"></A>
<A HREF="Framebuffer-HOWTO.html#toc4"><IMG SRC="../img/toc.gif" ALT="Contents"></A>
<HR>
<H2><A NAME="s4">4. What advantages does framebuffer devices have? </A></H2>

<P> 
<P>Penguin logo. :o) Seriously, the major advantage of the framebuffer drives
is that it presents a generic interface across all platforms. It was the
case until late in the 2.1.x kernel development process that the Intel
platform had console drivers completely different from the other console
drivers for other platforms. With the introduction of 2.1.109 all this
has changed for the better, and introduced more uniform handling of the
console under the Intel platforms and also introduced true bitmapped
graphical consoles bearing the Penguin logo on Intel for the first time,
and allowed code to be shared across different platforms. Note that 2.0.x
kernels do not support framebuffer devices, but it is possible someday
someone will backport the code from the 2.1.x kernels to 2.0.x kernels.
There is an exception to that rule in that the v0.9.x kernel port for m68k
platforms does have the framebuffer device support included.
<P><EM>With the release of the 2.2.x kernel, framebuffer device support is very solid
and stable. You should use the framebuffer device if your graphic card supports
it, if you are using 2.2.x kernels. Older 2.0.x kernels does not support framebuffer
devices, at least on the Intel platform.</EM> 
<P>
<UL>
<LI>0.9.x (m68k) - introduced m68k framebuffer devices. Note that m68k 0.9.x
is functionally equivalent to Intel 1.0.9 (plus 1.2.x enhancements)</LI>
<LI>2.1.107 - introduced Intel framebuffer/new console devices and
added generic support, without scrollback buffer support.</LI>
<LI>2.1.113 - scrollback buffer support added to vgacon.</LI>
<LI>2.1.116 - scrollback buffer support added to vesafb.</LI>
<LI>2.2.x - includes matroxfb(Matrox) and atyfb(ATI).</LI>
</UL>
<P>There are some cool features of the framebuffer devices, in that you can
give generic options to the kernel at bootup-time, including options
specific to a particular framebuffer device. These are:
<P>
<UL>
<LI><CODE>video=xxx:off</CODE> - disable probing for a particular framebuffer
device</LI>
<LI><CODE>video=map:octal-number</CODE> - maps the virtual consoles (VCs) to
framebuffer (FB) devices
<UL>
<LI><CODE>video=map:01</CODE> will map VC0 to FB0, VC1 to FB1, VC2 to FB0, VC3
to FB1..</LI>
<LI><CODE>video=map:0132</CODE> will map VC0 to FB0, VC1 to FB1, VC2 to FB3, VC4
to FB2, VC5 to FB0..</LI>
</UL>
</LI>
</UL>
<P>Normally framebuffer devices are probed for in the order specified in the
kernel, but by specifying the <CODE>video=xxx</CODE> option, you can add the
specific framebuffer device you want probed before the others specified in
the kernel.
<P>
<HR>
<A HREF="Framebuffer-HOWTO-5.html"><IMG SRC="../img/next.gif" ALT="Next"></A>
<A HREF="Framebuffer-HOWTO-3.html"><IMG SRC="../img/prev.gif" ALT="Previous"></A>
<A HREF="Framebuffer-HOWTO.html#toc4"><IMG SRC="../img/toc.gif" ALT="Contents"></A>
<SCRIPT>EndPage();</SCRIPT>  </BODY>
</HTML>
