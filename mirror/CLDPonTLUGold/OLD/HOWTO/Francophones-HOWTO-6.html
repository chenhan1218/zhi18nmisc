<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Le Francophones-HOWTO : Linux &amp; la langue fran&ccedil;aise: Réglage du clavier pour les applications en mode texte</TITLE>
 <LINK HREF="Francophones-HOWTO-7.html" REL=next>
 <LINK HREF="Francophones-HOWTO-5.html" REL=previous>
 <LINK HREF="Francophones-HOWTO.html#toc6" REL=contents>
<SCRIPT src="../menu.js"> function BeginPage() {} function EndPage() {} </SCRIPT> </HEAD> <BODY bgcolor=#EEEEFF MARGINHEIGHT=0 MARGINWIDTH=0> <SCRIPT>BeginPage(1, 8, 1);</SCRIPT>
<A HREF="Francophones-HOWTO-7.html"><IMG SRC="../img/next.gif" ALT="Next"></A>
<A HREF="Francophones-HOWTO-5.html"><IMG SRC="../img/prev.gif" ALT="Previous"></A>
<A HREF="Francophones-HOWTO.html#toc6"><IMG SRC="../img/toc.gif" ALT="Contents"></A>
<HR>
<H2><A NAME="s6">6. Réglage du clavier pour les applications en mode texte</A></H2>

<P>
<P>
<H2><A NAME="ss6.1">6.1 Tout d'abord</A>
</H2>

<P>
<P>Le huitième bit doit survivre à l'entrée du noyau,
assurez-vous-en donc avec :
<P>
<BLOCKQUOTE><CODE>
<PRE>
        stty cs8 -istrip -parenb
</PRE>
</CODE></BLOCKQUOTE>
<P>Ensuite, il convient de s'assurer que l'application est apte à supporter
les caractères 8 bits : par exemple, ispell n'est pas compilé
pour des caractères 8 bits par défaut : il faut le recompiler
sans l'option :
<P>
<BLOCKQUOTE><CODE>
<PRE>
        -NO8BIT
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss6.2">6.2 Une police, des polices...</A>
</H2>

<P>
<P>Avant d'aborder cette section, je vous conseille de lire l'introduction
sur les polices pour appréhender un peu mieux le vocabulaire de base et
les différentes normes de polices.
<P>
<H3>a) Historique des polices</H3>

<P>
<P>De l'ASCII à l'Unicode, en passant par l'ISO 8859, le latin et le cp, on
peut résumer l'histoire des polices en grandes étapes :
<P>Au début était l'ASCII, qui codait ses caractères sur 7 bits.
<P>Prévu pour des états-uniens, il était impossible d'incorporer des
caractères accentués à la norme déjà présente de 127 caractères.
<P>Ainsi vint le 8 bits qui étendit le nombre de caractères à 255 et les
normes ISO 8859, latin et cp, pour les plus connues, qui vinrent pallier
à cette déficience du fait des 128 positions supplémentaires disponibles
en encodant les caractères sur 8 bits.
<P>Mais plusieurs de ces normes étaient nécessaire du fait de
l'impossibilité de faire tenir les caractères de toutes les langues du
monde sur 8 bits.
<P>La norme ISO 8859-1 latin 1, la plus utilisée, se destine par exemple au
langues d'Europe de l'ouest, du nord, d'Amérique, la norme ISO 8859-2
latin 2 est prévue pour l'Europe de l'est...
<P>L'Unicode est l'un de ces standard, destiné à terme à remplacer les
différentes évolutions de l'ASCII ; comme le passage du 7 bits au 8 bits
il correspond à une extension de la place disponible, tout en reprenant
l'ancienne partie comme ASCII et ISO 8859-1 latin 1 pour rester
compatible avec la majorité du parc installé.
<P>L'Unicode offre l'avantage de proposer les caractères nécessaires à
toutes les langues du monde, mais reste encore peu utilisé ou
implémenté.
<P>En effet, il est impossible de l'utiliser en pratique sous
linux-console, la mémoire exigüe de la carte vidéo ne permettant pas de
stocker tous les caractères de l'Unicode, et sous X la gestion actuelle
des polices rendrait son utilisation trop inconfortable.
<P>Attendons un peu que les polices « True Type » se répandent sous X, grâce
à des outils comme freetype, xfstt (...) et le très attendu XFree 4 qui
devrait les supporter en natif.
<P>Actuellement, la nouvelle norme européenne ISO 8859-15 latin 9 est
censée permettre la transition vers l'Unicode en apportant à l'ancien
ISO 8859-1 latin 1 les caractères qu'il manquait actuellement.
<P>Toutefois elle est partiellement incompatible avec l'Unicode puisque
l'ISO 8859-1 latin 1 avait été choisi comme base pour l'Unicode, mais
que cette police veut compléter les failles de l'ISO 8859-1 latin 1 en y
rajoutant des caractères déjà présents dans l'Unicode...
<P>Quelle complexité pour de simple lettres !
<P>
<H3>b) ISO 8859-15 latin 9</H3>

<P>
<P>De nous jours, il vaut mieux installer par défaut la nouvelle norme ISO
8859-15 latin 9, destinée à remplacer l'ensemble des polices européennes
par une seule.
<P>Son but est voisin de l'Unicode, mais elle a l'avantage d'être plus légère que
celui-ci et d'être applicable tout de suite.
<P>Elle apporte notamment des caractères qui manquaient beaucoup pour les
Français et les Finlandais :
<P>
<UL>
<LI> « e dans l'o » en majuscule et minuscule pour les Français, par
exemple pour les mots oeuf, coeur, boeuf, oeil ...</LI>
<LI> « s chapeau inversé » en majuscule et minuscule pour les Finlandais</LI>
<LI> « z chapeau inversé » en majuscule et minuscule pour les Finlandais</LI>
<LI> « l'EURO » pour tous les pays européens</LI>
</UL>
<P>Cette nouvelle norme, ISO 8859-15 latin 9 aussi connue sous le nom générique
latin0, reste cependant encore très peu répandue par rapport à la norme
actuelle ISO 8859-1 latin 1.
<P>
<H3>c) Utiliser les polices ISO 8859-15 latin 9</H3>

<P>
<P>Vous n'avez besoin que d'une seule police !
<P>Or il en existe plusieurs types répondant différemment à la même norme
iso-8859-15 latin9 « latin0 » sous linux :
<UL>
<LI> par tradition l'opposition latN/latNu selon l'inclusion ou non d'une
table de correspondance Unicode.</LI>
<LI> en réalité les différences vont bien plus loin, de l'ordre dans
lequel sont les caractères de la police, ce qui joue sur l'aspect des
applications semi graphique, les correspondances avec des caractères
latin1 ± latin9 ± Unicode ce qui a un rôle dans la compatibilité croisée
ou exclusive, par exemple purement Unicode...</LI>
</UL>
<P>J'ai donc complété par 2 types de ma création pour répondre au mieux aux
différents besoins.
<P>
<BLOCKQUOTE><CODE>
<PRE>
      | Encodage dans | Inclusion d'une | Compatibilité | Compatibilité
      |  l'ordre iso  |  table Unicode  |   exclusive   |    croisée
--------------------------------------------------------------------------
lat9  |     oui       |      non        |     non       |   lat1 + lat9
--------------------------------------------------------------------------
lat9u |     non       |      oui        |     non       |   lat1 + lat9
--------------------------------------------------------------------------
lat9v |     oui       |      oui        |   Unicode     |       non
--------------------------------------------------------------------------
lat9w |     oui       |      oui        |     non       |lat1+lat9+Unicode
--------------------------------------------------------------------------
</PRE>
</CODE></BLOCKQUOTE>
<P>Voici plus d'explications :
<P>
<UL>
<LI> les lat9 tout court ne contiennent pas de table de correspondance
Unicode, ce qui fait que tous les symboles monétaires internationaux
apparaîtront comme des euro, ce qui peut poser des problèmes pour les
fichiers issus d'un ordinateur sous windows ; le cp1252 ou le latin1 sont
« incompatibles » avec le latin9, mais ce dernier a l'avantage de fonctionner
tout de suite sous linux.

Dans les versions récentes du noyau, selon le 
<A HREF="http://www.multimania.com/ydirson/en/lct/lct/lct-6.html">site de Yann Dirson</A>, il
semble donc que toutes les polices devraient contenir une table de
correspondance Unicode...
</LI>
<LI> des lat9u encodées dans un ordre non standard, mais identique à
celui des polices latXu de kbd, par rapport aux polices précédentes, en
amenant les mêmes problèmes avec le cp1252 et le latin1 mais en incluant
une table de correspondance Unicode, ce qui permet d'avoir de jolis
caractères semi graphiques sous Yast, mc, ou d'autres programmes basés
sur ncurses ou dialog.
</LI>
<LI> des lat9v encodées dans l'ordre officiel iso comme les
lat9 mais avec une table Unicode complète : là aucun symbole monétaire
international ne sera remplacé par l'euro !
Ces polices sont utiles pour éviter les problèmes d'export, grâce à
l'Unicode *pur*, avec une table de clavier Unicode adaptée : tous les
caractères latin9 sont remplacés par des caractères Unicodes et affichés
ainsi, ce qui a le mérite d'être compatible avec le latin9, l'Unicode,
d'être élégant techniquement mais inutilisable « normalement » sous
linux-console. Presque aucun système n'est entièrement prêt pour
l'Unicode !</LI>
</UL>
<P>Donc n'utilisez les polices lat9, lat9u ou lat9v que si vous savez ce
que vous faites, je vous recommande pour ma part le meilleur compromis :
les polices lat9w qui permettent de passer au latin9 immédiatement, en
posant quelques problèmes pour les caractères latin1 qui seront
remplacés par leurs équivalents latin9, mais sans rendre l'Unicode
obligatoire comme les lat9U, sans emmêler les caractères graphiques
comme les lat9, et en permettant aussi d'afficher les caractères
spécifiques au latin9 en Unicode *pur*, à l'exception des caractères
spécifiques au latin1 donc...
<P>Je vous rassure, vous n'êtes pas obligés de comprendre tout ce qui suit
pour « passer à l'euro », si effectivement vous ne savez toujours pas de
quelle police vous avez besoin, un conseil : utiliser les lat9w.
<P>Pour utiliser la police lat9-16.psf ou un autre lat9 .psf, vous devez
pallier l'absence d'une table Unicode en en chargeant une.
<P>
<BLOCKQUOTE><CODE>
<PRE>
                loadunimap fonts/linux-console/lat9.uni
                setfont fonts/linux-console/lat9-16.psf
</PRE>
</CODE></BLOCKQUOTE>
<P>Pour utiliser la police lat9w-16.psf ou une autre lat9u, lat9v ou
lat9w :
<P>
<BLOCKQUOTE><CODE>
<PRE>
                setfont /fonts/linux-console/lat9w-16.psf
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H3>d) Unicode</H3>

<P>
<P>Une alternative est l'Unicode, mais les programmes l'utilisant sont encore trop
peu nombreux pour qu'elle soit valable.
<P>Citons quand même yuedit et le projet « 9 » (9term, 9wm... rien à voir
avec l'opérateur télécom français du même nom) qui utilisent l'Unicode
sous X, avec plus ou moins de succès.
<P>En revanche, sous linux-console, tout programme peut utiliser l'Unicode.
<P>Mais, hélas!, aussi grande que soit la mémoire des cartes vidéos actuelles,
elle ne peut charger l'intégralité des caractères d'une police Unicode.
<P>Il existe donc des « jeux de caractères » limités mais bien utiles pour les
langues baltiques, asiatiques, est-africaines...
<P>
<H3>e) Utiliser les possibilités Unicode</H3>

<P>
<P>Essayez par exemple ce fichier <CODE>unicode-lance</CODE> pour passer en mode Unicode:
<P>
<BLOCKQUOTE><CODE>
<PRE>
#!/bin/sh
echo -e '\033%8'
kbd_mode -u
loadkeys fr-unicode.map
setfont lat9u-16.psf
</PRE>
</CODE></BLOCKQUOTE>
<P>et ce fichier <CODE>latin-retourne</CODE> pour revenir en mode latin normal:
<P>
<BLOCKQUOTE><CODE>
<PRE>
#!/bin/sh
echo -e '\033%@'
kbd_mode -a
loadkeys fr-latin9.map
setfont lat9w-16.psf
</PRE>
</CODE></BLOCKQUOTE>
<P>Essayez par exemple de lire le fichier <CODE>unicode.txt</CODE>, encodé en
Unicode, une fois <CODE>unicode-lance</CODE> activé.
<P>Vous ne verrez sinon qu'un texte mal encodé, sans caractères 8 bits,
comme cet exemple :
<P>
<BLOCKQUOTE><CODE>
<PRE>
Ceci est un essai de texte en UNICODE !

On constate que les bÃ©tas (Ã~_) et autres lettres 8 bits ne sortent pas bien
si l'on regarde ce fichier en mode latin !
Les accents Ã©Ã¨Ã| Ã¹ non plus d'ailleurs...
Enfin, heureusement que l'on ne marche pas sur des Å~RUFS, enfin, Å~Sufs !
Ã~Ga marche moyennement disons !
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss6.3">6.3 Les locales, messages en Français</A>
</H2>

<P>
<P>Linux en 'version française' existe... mais ne semble pas facile
à obtenir.
<P>La librairie locale(7) [cf aussi perllocale, setlocale, getlocale]
utilisée par la librairie C se sert de variables d'environnement pour
définir les préférences linguistiques et nationales.
<P>Pablo Saratxaga répondait ainsi à Pascal Rigaux en prenant l'exemple de sort :
<P>
<BLOCKQUOTE><CODE>
<PRE>
 PR> J'ai découvert aujourd'hui la variable d'environnement LANG. C'est assez
 PR> surprenant de se retrouver avec de l'aide en français (même si elle n'est pas
 PR> toujours aussi précise que la version anglaise) quand on fait ls --help.

C'est agréable n'est-ce pas ?

 PR> Par contre je ne comprend pas pourquoi un programme comme sort(1) n'utilise pas
 PR> cette information pour obtenir un tri acceptable pour les accents (du genre ne
 PR> pas mettre « être » après « zen »). Il devrait au moins proposer une option de
 PR> ce genre.

Il faudrait regarder les sources de sort...
La fonction à utiliser est strcoll() :

                                  ****

STRCOLL(3)         Manuel du programmeur Linux         STRCOLL(3)


NOM
       strcoll - Comparaison de deux chaînes suivant la localisa-
       tion en cours.

SYNOPSIS
       #include &lt;string.h&gt;

       int strcoll (const char *s1, const char *s2);

DESCRIPTION
       La fonction strcoll() compare les deux chaînes s1  et  s2.
       Elle renvoie un entier inférieur, égal ou supérieur a zéro
       si  s1 est respectivement inférieure, égale, ou supérieure
       a  s2.   La  comparaison est effectuée en se basant sur la
       localisation en cours pour la catégorie LC_COLLATE.  (Voir
       setlocale(3)).

                                  ****

qui est donc l'équivalent de strcmp() mais qui tiens compte des locales.
Il faudra s'écrire un strcasecoll() aussi pour bien faire, en utilisant
toupper()/tolower() qui d'après la page de manuel supporte les locales.

Qui s'y colle ? Ça devrait être assez simple à réaliser sur un système GNU
en tout cas.
</PRE>
</CODE></BLOCKQUOTE>
<P>Il existe différente variables à exporter, avec chacune une fonction
spécifique ; le format standardisé est:
<P>
<BLOCKQUOTE><CODE>
<PRE>
        langue[_PAYS[.CHARSET]][@variante]
</PRE>
</CODE></BLOCKQUOTE>
<P>Les crochets dénotent l'optionalité, par exemple: 'fr', 'fr_BE',
'fr_CH.ISO-8859-15', no@bokmaal, no@nynorsk,...
<P>Les fonctions de la libc, celle de GNU en tout cas, iront chercher dans
« l'ordre décroissant » si on peut dire; par exemple si on spécifie
'fr_CH.ISO-8859-15' elles chercheront d'abord avec cette valeur, puis
avec 'fr_CH' puis avec 'fr'.
<P>
<UL>
<LI> LC_COLLATE  définit les équivalences de caractères pour les comparaisons
(&aelig; peut être équivalent à ae), pour les ligatures et pour les césures.</LI>
<LI> LC_CTYPE    définit les caractères affichables</LI>
<LI> LC_MONETARY définit le format et le symbole de la monnaie utilisée</LI>
<LI> LC_NUMERIC  définit le format numérique : regroupement, marqueur
décimal...</LI>
<LI> LC_MESSAGES définit la langue des messages</LI>
<LI> LC_TIME     définit le format de la date, les noms des jours et
des mois</LI>
<LI> LC_ALL      valeur par défaut des variables précédentes : si une
LC_ n'est pas définie, LC_ALL est prise en compte, sinon la libc se
rabat sur LANG.</LI>
<LI> LANG        différent des variables précédentes, contient
le code langue au format iso : fr,en,de...</LI>
<LI> LANGUAGE    liste des locales par ordre de préférence séparées
par deux points (fr:es:dk:en), c'est une particularité GNU, fort
utile si un document n'existe que dans une langue comme certaines pages
de manuel</LI>
</UL>
<P>Les valeurs utilisables pour les francophones sont:
<P>
<UL>
<LI> fr français générique</LI>
<LI> fr_FR français de France</LI>
<LI> fr_BE français de Belgique</LI>
<LI> fr_CH français de Suisse</LI>
<LI> fr_LU français du Luxembourg</LI>
<LI> fr_CA français du Canada</LI>
</UL>
<P>Par exemple, si vous être un Français de France, il suffit d'indiquer
sous bash :
<P>
<BLOCKQUOTE><CODE>
<PRE>
        export LANGUAGE=fr_FR
</PRE>
</CODE></BLOCKQUOTE>
<P>Exemple :
<P>
<BLOCKQUOTE><CODE>
<PRE>
        bash# export LANGUAGE=es_ES
        bash# ls fichier_n_existant_pas
        ls: fichier_n_existant_pas: No existe el fichero o el directorio
        bash# export LANGUAGE=de_DE
        bash# ls fichier_n_existant_pas
        ls: fichier_n_existant_pas: Datei oder Verzeichnis nicht gefunden
        bash# export LANGUAGE=en_US
        bash# ls fichier_n_existant_pas
        ls: fichier_n_existant_pas: No such file or directory
        bash# export LANGUAGE=fr_FR
        bash# ls fichier_n_existant_pas
        ls: fichier_n_existant_pas: Aucun fichier ou répertoire de ce type
</PRE>
</CODE></BLOCKQUOTE>
<P>Toutefois, avec le passage à l'euro, ces locales ne sont plus adaptées.
<P>Je vous conseille donc d'utiliser dans les pays de l'union passant à
l'euro le suffixe « @euro » :
<P>
<BLOCKQUOTE><CODE>
<PRE>
   export LC_ALL="fr_FR@euro"
</PRE>
</CODE></BLOCKQUOTE>
<P>Pour cela, installer les nouveaux fichiers sources de locales dans
<CODE>/usr/share/i18n/</CODE> en lançant :
<P>
<BLOCKQUOTE><CODE>
<PRE>
   cp charmaps/ISO-8859-15 /usr/share/i18n/charmaps/ISO-8859-15
   cp locales/* /usr/share/i18n/locales/
</PRE>
</CODE></BLOCKQUOTE>
<P>Alors, régénérer les locales « binaires » de <CODE>/usr/share/locales</CODE>, par exemple :
<P>
<BLOCKQUOTE><CODE>
<PRE>
   localedef -i fr_FR@euro -f ISO-8859-15 fr_FR@euro
</PRE>
</CODE></BLOCKQUOTE>
<P>fr_FR@euro inclus les caractères latin 9, c'est utile pour l'utilisation
de LC_COLLATE et LC_CTYPE en fait, et la nouvelle monnaie unique.
<P>Pour le moment, le Franc Français (FRF) est toujours la monnaie
officielle en France par exemple, mais lorsque ce sera l'euro, il
suffira de remplacer la locale fr_FR par fr_FR@euro.
<P>
<BLOCKQUOTE><CODE>
<PRE>
   cd /usr/lib/locales
   rm -fr fr_FR
   mv fr_FR@euro fr_FR
</PRE>
</CODE></BLOCKQUOTE>
<P>La solution « @euro » est supportée par les autres UNIX comme Solaris.
<P>Pour les shell scripts, il peut être utile de rajouter « LC_TIME=C » pour
empêcher la date d'être localisé, embêtant pour les grep et autres qui
cherchent « Mon » « Tue »... et non « Lun », « Mar »...
<P>Les données correspondantes aux préférences se trouvent généralement
dans <CODE>/usr/share/locale</CODE>. S'ils manquent, vous pouvez récupérer
leur 
<A HREF="ftp://dkuug.dk/i18n/WG15-collection">source</A><P>Concernant les autres fichiers abordés dans cet article, vous les
trouverez avec les autres fichiers de cet HOWTO sur
<A HREF="http://metalab.unc.edu/guylhem/francophones-howto.tgz">ma page</A>.
<P>
<H2><A NAME="ss6.4">6.4 Son linux en français</A>
</H2>

<P>
<P>Pour se faire <CODE>SON</CODE> linux en français il faut en pratique disposer des
sources de la libc et d'un minimum de compétences en langage C ; ces
manipulations sont inutiles pour l'utilisateur standard de Linux qui
se contentera d'utiliser les locales de la section précédente.
<P>Mais voici donc, pour la bonne bouche, quelques renseignements collectés...
<P>Laurent Chemla nous pilote :
<P>
<BLOCKQUOTE><CODE>
<PRE>
Si j'ai suivi, il y a deux trucs qui font la même chose, d'où embrouille, les
locales et un truc appelé nls.

Les locales, sous Linux, ça va par défaut dans /usr/lib/locale,
et ça contient de quoi préciser entre autres le format des
nombres (LC_NUMERIC), les retours des fonctions ctype (isalpha etc) (LC_CTYPE),
le format des sommes d'argent (LC_MONETARY), le format des dates (LC_TIME) et
encore d'autres détails. Sur certains Unix, il y a aussi LC_MESSAGES,
qui contient les messages de l'OS dans la langue choisie par la variable
d'environnement LC_MESSAGES. Pas sous Linux.  Sous Linux, c'est nls qui fait
ça, et de fait, nls gère un fichier qui est dans /etc/locale/.
(NDG : De nos jours, ils se trouvent plutôt dans /usr/lib/locale)
D'où l'embrouille. Ils auraient mis ça dans /usr/lib/nls, comme
tout le monde, ça aurait évite la confusion. Mais bon.

Donc, si l'on veut se tenir à jour d'nls, il suffit d'aller dans les
sources de libc/nls, faire « make french » et copier libc.dat dans
/etc/locale/C/libc.dat et toc, tous les messages sont en français. Y compris
ceux des programmes qui n'utilisent pas setlocale(): c'est perror() qui fait le
boulot (du moins je suppose).

Si l'on veut en plus que les programmes qui utilisent setlocale() utilisent nos
règles françaises, là il faut aller dans les sources de
libc/locale et dans chacun des sous-répertoires jeter un oeil sur le
fichier exemple, le modifier pour le français (c'est des tout petits
fichiers), et faire « make », avant de copier le résultat dans
/usr/lib/local/fr/ et de faire un « export LC_ALL=fr ».
</PRE>
</CODE></BLOCKQUOTE>
<P>Autre astuce pour ménager les vieux logiciels :
<P>
<BLOCKQUOTE><CODE>
<PRE>
cd /usr/lib
ln -sf /usr/share/locale .
</PRE>
</CODE></BLOCKQUOTE>
<P>Ne pas oublier de télécharger sur le 
<A HREF="ftp://ftp.lip6.fr">site du lip6</A> :
<P>
<UL>
<LI> Les pages de manuel en français, archive man-fr-*, adaptées par C.
Blaess. Il suffit d'extraire le contenu de l'archive dans le répertoire
/usr/man/fr.
</LI>
<LI> Une intéressante documentation technique : locale.fr, par P. D'Cruze,
adaptée par É. Dumas</LI>
</UL>
<P>Pour en apprendre davantage lire la page de manuel de « locale » : bibliothèque
de pages de manuel 5 ou 7 :
<P>
<BLOCKQUOTE><CODE>
<PRE>
        bash# man 5 locale
        bash# man 7 locale
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss6.5">6.5 Les variables</A>
</H2>

<P>
<P>Ces variables doivent être exportées à chaque login :
mettez les donc dans <CODE>.bashrc</CODE> et <CODE>.bash_login</CODE>, <CODE>.tcshrc</CODE> ou
/etc/profile :
<P>
<BLOCKQUOTE><CODE>
<PRE>
# pour tcsh, utiliser setenv au lieu de export, par exemple «setenv LANG fr»

# Les locales
LC_CTYPE=ISO-8859-1
LANGUAGE=fr
LC_MESSAGES=fr
LC_ALL=fr
LANG=fr
LESSCHARSET=latin1
export LC_CTYPE LANGUAGE LC_MESSAGES LC_ALL LANG LESSCHARSET

# Les raccourcis : sans ll ou d, impossible de voir les fichiers comprenant des
# caractères 8 bits ...
alias q="cd .."
alias ll="ls --color=auto -a -N -l"
alias d="ls --color=auto -a -N"
alias indent="indent -kr"
alias netscape="export LC_ALL=en_EN ; netscape $* ; LC_ALL=fr_FR"

# Au cas où Del/BackSpace ne fonctionne pas, essayez l'un des deux :
#stty erase ^?
#stty erase ^H
</PRE>
</CODE></BLOCKQUOTE>
<P>N'oubliez pas : tous les fichiers ici cités dont le nom commence par
« . » doivent se trouver dans votre répertoire maison &nbsp;/
<P>
<H2><A NAME="ss6.6">6.6 Les caractères 8 bits dans les programmes utilisant readline tels bash ou ncftp...</A>
</H2>

<P>
<P>Readline est une librairie de saisie de caractères avec historique et
complétion ; elle est utilisée par de nombreux programmes comme bash, ncftp,
gnuplot...
<P>Par défaut, le 8e bit sert à coder la touche Meta.
<P>Elle est utilisée pour coder certaines commandes mais la touche « Escape »
ou « Échap » peut la remplacer.
<P>Si vous souhaitez voir et saisir des accents avec les applications
compilées avec readline, comme bash pour les versions supérieures à
1.13, ajoutez ceci dans votre fichier $INPUTRC, par défaut
<CODE>~/.inputrc</CODE>) :
<P>
<BLOCKQUOTE><CODE>
<PRE>
# Permettre de rentrer &amp; recevoir des caractères accentués
set meta-flag on
set convert-meta off
set input-meta on
set output-meta on

# Pas de bip audible mais visible
# set bell-style visible

# Pour faire marcher Home, End, Delete, Esc + Delete &amp; Esc + BackSpace
"\e[1~":beginning-of-line
"\e[3~":delete-char
"\e[4~":end-of-line
"\e\C-h": backward-kill-word
"\e\e[3~": kill-word
</PRE>
</CODE></BLOCKQUOTE>
<P>Cela vous permettra d'effacer des caractères vers l'avant avec
« Delete » et vers l'arrière avec « BackSpace », ceci n'étant pas
prévu sur les tables de clavier par défaut « mimant » le
comportement d'un clavier de console VT100 .
<P>Les deux dernières options vous permettront d'utiliser « Home » et « End »
pour aller au début et à la fin de la ligne en cours
d'édition.
<P>Pour pouvoir employer une touche il suffit d'obtenir son code et
l'associer à une fonction grâce à ce fichier ; pour obtenir le code
d'une touche invoquer cat puis appuyer sur la touche : son code
apparaît.
<P>Le code physique :
<P>
<BLOCKQUOTE><CODE>
<PRE>
        ^[
</PRE>
</CODE></BLOCKQUOTE>
<P>correspond à la séquence d'échappement.
<P>Par exemple, si le code de « Home » est « ^[[7&nbsp; » il suffit d'ajouter
une ligne :
<P>
<BLOCKQUOTE><CODE>
<PRE>
        "\e[7~": beginning-of-line
</PRE>
</CODE></BLOCKQUOTE>
<P>au <CODE>.inputrc</CODE>.
<P>Plus de documentation est disponible sur la page de manuel de bash, section
<CODE>READLINE</CODE>.
<P>On peut aussi, grâce à la variable d'environnement <CODE>INPUTRC</CODE>, utiliser un
fichier commun à tous les utilisateurs.
<P>Enfin, je vous recommande d'utiliser ce fichier <CODE>.bashrc</CODE> à placer
dans votre répertoire maison :
<P>
<BLOCKQUOTE><CODE>
<PRE>
# ~/.bashrc : exécuté par bash(1) pour les shells lancés après le login.

# Le path
PATH="/usr/sbin:/usr/bin:/sbin:/bin:/usr/X11R6/bin:/usr/local/bin"

# Le prompt
PS1="(\u@\h:\W)$ "

# L'utilisateur
ENV=$HOME/.bashrc
USERNAME="votre nom"

# Les locales
_CTYPE=ISO-8859-1
LANGUAGE=fr
LC_MESSAGES=fr
LC_ALL=fr
LANG=fr
LESSCHARSET=latin1
export LC_CTYPE LANGUAGE LC_MESSAGES LC_ALL LANG LESSCHARSET

# Les raccourcis
alias q="cd .."
alias ll="ls --color=auto -a -N -l"
alias d="ls --color=auto -a -N"
alias indent="indent -kr"
alias elm-box="elm -f ~/Mail/Inbox"
alias netscape="export LC_ALL=en_EN ; netscape $* ; LC_ALL=fr_FR"

# Au cas où Del/BackSpace ne fonctionne pas, essayez l'un des deux :
#stty erase 
#stty erase ^H

# Refuser le talk &amp; le write
#mesg n

# Permettre les coredumps
#ulimit -c nombre_max_de_Ko

#Fixer le masque de création de fichiers
#umask 022
</PRE>
</CODE></BLOCKQUOTE>
<P>Le fichier .bash_profile ou .bash_login, exécuté par bash(1) lors des
logins, y est strictement identique mais peut, si vous le voulez,
présenter des différences pour afficher par exemple une citation en
laçant le programme « fortune ».
<P>
<H2><A NAME="ss6.7">6.7 zsh</A>
</H2>

<P>Celui-ci devrait se contenter d'un <CODE>stty pass8</CODE>.
<P>Si cela ne suffisait pas, rajouter dans le <CODE>.zshrc</CODE> ou dans
<CODE>/etc/zshrc</CODE>:
<P>
<BLOCKQUOTE><CODE>
<PRE>
        bindkey "\e[2~"  yank
        bindkey "\e[3~"  delete-char
        bindkey "\e[1~"  beginning-of-line
        bindkey "\e[4~"  end-of-line
        bindkey "\e[5~"  up-line-or-history
        bindkey "\e[6~"  down-line-or-history
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>
<H2><A NAME="ss6.8">6.8 tcsh</A>
</H2>

<P>
<P>Pour tcsh, placer, dans le fichier <CODE>/etc/csh.login</CODE> ou dans les
fichiers <CODE>.tcshrc</CODE> des utilisateurs concernés, les variables
indiquées plus haut en remplaçant export par setenv:
<P>
<BLOCKQUOTE><CODE>
<PRE>
        setenv LC_CTYPE=ISO-8859-1
        setenv LANGUAGE=fr
        setenv LC_MESSAGES=fr
        setenv LC_ALL=fr
        setenv LANG=fr
        setenv LESSCHARSET=latin1
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss6.9">6.9 Pour tous les shells</A>
</H2>

<P>
<P>Remplacer 'iso_8859_1' par 'iso-8859-1' si cela ne fonctionne pas, voire
french.iso88591.fr_FR ou fr_BR, fr_CA, fr_CH, fr_LU...
<P>&Agrave; propos de LANG, il vaut mieux éviter fr_FR et lui préférer fr
car certains programmes ne passent pas vraiment par la resolution de
locales mais lisent LANG directement...
<P>Si nls est installé, les routines correspondantes sont utilisées, sinon
tcsh agit en iso_8859_1, quelle que soit les valeurs données à LANG et
LC_CTYPE : cf. la section NATIVE LANGUAGE SYSTEM de tcsh(1).
<P>Selon le Danish-HOWTO, utiliser :
<P>
<BLOCKQUOTE><CODE>
<PRE>
        (guylhem@victis:tcsh)# setenv LC_CTYPE ISO-8859-1
        (guylhem@victis:tcsh)# stty pass8
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss6.10">6.10 L'heure</A>
</H2>

<P>
<P>Rien n'est plus facile que de laisser à Linux le soin de passer de
l'heure d'été à l'heure d'hiver et
réciproquement...
<P>a) D'abord, quelle heure est-il :-) ?
<P>Après avoir regardé sur la pendule la plus proche de vous, tapez :
<P><CODE>clock</CODE>
<P>puis
<P><CODE>date</CODE>
<P>La première heure est celle du bios, la seconde celle calculée
par Linux à partir de <CODE>/etc/zoneconfig</CODE>.
<P>Pour peu que vous ayez installé timezone, votre machine peut jongler
aisément entre les différents fuseaux horaires... ce que les DOS
ou Windows ne permettent pas !
<P>b) L'heure du choix !
<P>De là, deux possibilitées : soit vous décidez de laisser
l'heure système à l'heure locale, peu pratique, excepté si
vous hébergez aussi sur votre disque dur ces systèmes
d'exploitation peu évolué, ne sachant même pas exploiter
les fuseaux horaires, soit vous passez à l'heure de Greenwich, Linux se
chargeant de l'adapter à votre fuseau horaire.
<P>Dans ce cas, les grands voyages à l'étranger avec un portable
tout neuf équipé de Linux se feront en toute simplicité :
le dernier paragraphe vous expliquera comment changer de fuseau horaire
facilement...
<P>c) Le réglage
<P>Pour procéder, regardez d'abord si l'heure système
retournée par clock est l'heure locale ou l'heure de Greenwich.
<P>Vous avez bien regardé une pendule comme je vous le conseille plus haut,
n'est-ce pas ?
<P>Si clock vous retourne l'heure locale, il va falloir jongler un peu avec les
fuseaux horaires, sinon passez directement à l'étape
« réglage du fuseau ».
<P>
<UL>
<LI> Pour les français, belges wallons et suisses romands :</LI>
</UL>
<P>Vous êtes normalement dans une zone horaire MET (Medium European Time,
soit GMT+1).
<P>La zone « MET DST » correspond elle à l'heure d'été active
(GMT + 2).
<P>Selon les décisions futures de la cour européenne, l'heure
d'été « daylight savings » risque d'être abandonné...
ce qui compliquera cette explication !
<P>
<UL>
<LI> Pour les canadiens français :</LI>
</UL>
<P>Vous êtes dans une zone horaire GMT-4 si vous habitez autour de
Montréal .
<P>Pour les autres provinces, consulter un dictionnaire !
<P>Premièrement, effacez le fichier /etc/localtime ou
/usr/lib/zoneinfo/localtime (l'emplacement varie selon les distributions ; si
vous avez les deux fichiers, effacez /etc/localtime : l'autre fichier doit
certainement être un lien vers /etc/localtime).
<P>Dès lors, clock et date doivent vous retourner la même heure...
<P>
<UL>
<LI> Pour les canadiens français : utilisez GMT+4</LI>
</UL>
<P>
<UL>
<LI> Pour les français, belges wallons et suisses romands :</LI>
</UL>
<P>Si vous lisez ce document en été, le décalage de l'heure
locale par rapport à l'heure de Greenwich est de deux heures, on va donc
mettre temporairement le fuseau en GMT-2, soit vous lisez ce document en hiver
et il convient de remplacer tous les « 2 » par des « 1 » dans les exemples
suivants...
<P>GMT-2 ?!!? Alors que le fuseau est GMT+2 ?
<P>Ceci va vous retourner l'heure de Greenwich dont on a besoin pour régler
le système : tapez :
<P><CODE>ln -sf /usr/lib/zoneinfo/Etc/GMT-2 /etc/zoneconfig</CODE>
<P><CODE>clock</CODE>
<P><CODE>date</CODE>
<P>L'heure calculée correspond donc à l'heure de Greenwich, l'heure
système à l'heure locale... soit l'inverse de ce que l'on veut.
<P>Un simple :
<CODE>clock -w</CODE>
<P>Va alors mettre l'heure du système en heure de Greenwich, utilisant pour
cela l'heure locale inversée volontairement avec l'heure
système.
<P>d) Régler le fuseau horaire :
<P>Tapez alors :
<CODE>ln -sf /usr/lib/zoneinfo/Europe/Votre-ville /etc/zoneconfig</CODE>
<P>Et voilà ! Le système est à l'heure de Greenwich, la
conversion vers le fuseau horaire local et l'heure d'été se
faisant automatiquement.
<P>Si vous habitez hors Europe, procédez de même en remplaçant
les « -2 » par « X », X représentant l'opposé de votre
décalage horaire (par exemple -4 au Québec, donc X=+4...)
<P>e) Modifier le fuseau horaire :
<P>Si vous partez à l'étranger, il est alors simple de modifier
l'heure locale de votre portable : par exemple si vous partez pour Moscou :
<P><CODE>ln -sf /usr/lib/zoneinfo/Europe/Moscow /etc/zoneconfig</CODE>
<P>Très simple et très utile : plus besoin de se souvenir du
décalage horaire (plus ou moins X heures) puisque Linux se charge
désormais de tout !
<P>
<H2><A NAME="ss6.11">6.11 vi</A>
</H2>

<P>
<P>Normalement, aucune modification n'est nécessaire à part l'utilisation de
loadkeys (détaillée plus haut).
<P>Ce fichier <CODE>.vimrc</CODE> pourrait toutefois vous être utile si vous utilisez
<CODE>vim</CODE> au lieu d'<CODE>elvis</CODE> :
<P>
<BLOCKQUOTE><CODE>
<PRE>
" Les guillemets anglais « " » signifient « mis en commentaire »

" Éviter un avertissement « version incorrecte » :
version 4.0

" Utiliser les défauts de vim, bien mieux
set nocompatible

" Autoriser le « BackSpace » sur tout :
set bs=2

" Police à utiliser sous X11 :
"set guifont=-misc-fixed-medium-r-normal--14-130-75-75-c-70-iso8859-1

" Fixer la césure automatique de la ligne à N caractères :
set tw=72

" Faire apparaître les tabulations et les espaces
set list

" Changer les défauts pour voir les espaces inutiles et les tabulations
set listchars=tab:»·,trail:·
hi nontext ctermfg=red
hi nontext ctermbg=blue

" Indentation (pour les programmeurs) :
" set cindent

" Réglages souris :
"set mouse=a

" Ligne
set nowrapscan

" Montrer les correspondances :
set showmatch

" Montrer le mode
set showmode

" Indentation intelligente (pour les programmeurs) :
" set uc=0

" Faire fonctionner BackSpace :
set t_kD=^?

" Doit se trouver après
map ^H X

" Faire fonctionner Delete  :
map \e[3~ x

" Cacher la souris lorsqu'on tape :
set mousehide

" Faire voir les correspondances lors de recherches :
" set hlsearch

" Colorer à l'intérieur des commentaires en C :
let c_comment_strings=1

" Couleur pour xiterm, rxvt, nxterm, color-xterm :
if has("terminfo")
    set t_Co=8
    set t_Sf=\e[3%p1%dm
    set t_Sb=\e[4%p1%dm
 else
    set t_Co=8
    set t_Sf=\e[3%dm
    set t_Sb=\e[4%dm
endif

" Coloration syntaxique :
if ett_Co > 1
   syntax on
endif

" Autoriser l'édition de fichiers gzippés

augroup gzip
  " Supprimer toutes les autocommandes
  au!
  autocmd BufReadPre,FileReadPre        *.gz set bin
  autocmd BufReadPost,FileReadPost      *.gz '[,']!gunzip
  autocmd BufReadPost,FileReadPost      *.gz set nobin
  autocmd BufReadPost,FileReadPost      *.gz execute ":doautocmd BufReadPost " .  expand("%:r")

  autocmd BufWritePost,FileWritePost    *.gz !mv &lt;afile> &lt;afile>:r
  autocmd BufWritePost,FileWritePost    *.gz !gzip &lt;afile>:r

  autocmd FileAppendPre                 *.gz !gunzip &lt;afile>
  autocmd FileAppendPre                 *.gz !mv &lt;afile>:r &lt;afile>
  autocmd FileAppendPost                *.gz !mv &lt;afile> &lt;afile>:r
  autocmd FileAppendPost                *.gz !gzip &lt;afile>:r
augroup END

augroup bzip
  au!
  autocmd BufReadPre,FileReadPre        *.bz2 set bin
  autocmd BufReadPost,FileReadPost      *.bz2 '[,']!bunzip2
  autocmd BufReadPost,FileReadPost      *.bz2 set nobin
  autocmd BufReadPost,FileReadPost      *.bz2 execute ":doautocmd BufReadPost " .  expand("%:r") 
  autocmd BufWritePost,FileWritePost    *.bz2 !mv &lt;afile> &lt;afile>:r
  autocmd BufWritePost,FileWritePost    *.bz2 !bzip2 &lt;afile>:r

  autocmd FileAppendPre                 *.bz2 !bunzip2 &lt;afile>
  autocmd FileAppendPre                 *.bz2 !mv &lt;afile>:r &lt;afile>
  autocmd FileAppendPost                *.bz2 !mv &lt;afile> &lt;afile>:r
  autocmd FileAppendPost                *.bz2 !bzip2 &lt;afile>:r
augroup END

augroup cprog
  au!
  autocmd BufRead *       set formatoptions=tcql nocindent comments&amp;
  autocmd BufRead *.c,*.h set formatoptions=croql cindent comments=sr:/*,mb:*,el:*/,://
augroup END
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss6.12">6.12 Emacs</A>
</H2>

<P>
<P>Voici un fichier de configuration de base pour employer les accents.
<P>
<BLOCKQUOTE><CODE>
<PRE>
  ;;
  ;; Fichier .emacs: initialisation d'emacs
  ;; Tiré du Guide du Rootard
  ;;

  (display-time)                     ;; Pour avoir l'heure dans la barre d'état
  (setq display-time-24hr-format t)  ;; Format 24 heures

  ;; Nouveaux modes
  (autoload 'c++-mode   "cplus-md" "C++ Editing Mode" t)
  (autoload 'perl-mode   "perl-mode" "Perl Editing Mode" t)
  (autoload 'c-mode "c-mode" "C Editing Mode" t)
  ; mieux vaudrait utiliser le "cc-mode"

  (autoload 'jargon-mode "jargon" "Jargon Mode" t)

  ;; Auto-Mode Settings : positionne le mode selon l'extension
  (setq auto-mode-alist
  (append '(("\.c$"  . c-mode)    ;; utilise le mode C++ même pour C
  ("\.h$"  . c-mode)
  ("\.C$"  . c++-mode)
  ("\.H$"  . c++-mode)
  ("\.cc$" . c++-mode)
  ("\.C$"  . c++-mode)
  ("\.pl$" . perl-mode)           ;; Perl
  ("/tmp/snd\.[0-9]*" . text-mode);; Text (pour le courriel)
  ("[Rr][Ee][0-9]*" . text-mode)
  ("\.ada$"  . ada-mode)          ;; Ada
  ("\.spec$"  . ada-mode)
  ("\.body$"  . ada-mode)
  ("makefile$" . makefile-mode)  ;; Makefile
  ("Makefile$" . makefile-mode)
  ("Imakefile$" . makefile-mode))
  auto-mode-alist))

  ; Remappages variés à mettre ici
  (global-set-key "\eg" 'goto-line)       ;; ESC G = Aller à une ligne

  (put 'eval-expression 'disabled nil)

  ;; Accents...
  (standard-display-european 1)
  (load-library "iso-syntax")
  (set-input-mode (car (current-input-mode))
                (nth 1 (current-input-mode))
                0)

  ;; Sous X-Window, texte en couleurs (C/C++/Shell/Makefile,etc)
  (cond (window-system
  (setq hilit-mode-enable-list  '(not text-mode)
  hilit-background-mode   'light
  hilit-inhibit-hooks     nil
  hilit-inhibit-rebinding nil)
  (require 'hilit19)
  ))
  (if (not (equal window-system ""))
  (global-set-key "\C-?" 'delete-char))
  ))
</PRE>
</CODE></BLOCKQUOTE>
<P>Le Keyboard-HOWTO conseille quand à lui :
<P>
<BLOCKQUOTE><CODE>
<PRE>
          (standard-display-european t)
          (set-input-mode nil nil 1)
          (require 'iso-syntax)
          (load-library "iso-insert.el")
          (define-key global-map [?\C-.] 8859-1-map)
</PRE>
</CODE></BLOCKQUOTE>
<P>Utilisez une version au moins égale à 19.27, modifiez le fichier global
(commun à tous les utilisateurs)
<CODE>/usr/lib/emacs/site-lisp/site-start.el</CODE> ou le <CODE>./emacs</CODE>
de chaque utilisateur concerné pour y ajouter :
<P>
<BLOCKQUOTE><CODE>
<PRE>
        (standard-display-european t)
        (set-input-mode (car (current-input-mode))
          (nth 1 (current-input-mode))
          0)
        (global-set-key [delete]   'delete-char)
        (global-set-key [home]     'beginning-of-line)
        (global-set-key [end]      'end-of-line)
        (global-set-key [prior]    'scroll-down)
        (global-set-key [next]     'scroll-up)
        (global-set-key [C-right]  'forward-word)
        (global-set-key [C-left]   'backward-word)
        (global-set-key [C-prior]  'beginning-of-buffer)
        (global-set-key [C-next]   'end-of-buffer)
        (global-set-key "\033[A"  'previous-line)
        (global-set-key "\033[B"  'next-line)
        (global-set-key "\033[C"  'forward-char)
        (global-set-key "\033[D"  'backward-char)
        (global-set-key "\033[H"  'beginning-of-line)
        (global-set-key "\033[Y"  'end-of-line)
        (global-set-key "\033[1~" 'beginning-of-line)
        (global-set-key "\033[2~" 'overwrite-mode)
        ;; le delete-char peut correspondre à \004 ou à \033[3~
        (global-set-key "\033[3~" 'delete-char)
        (global-set-key "\033[4~" 'end-of-line)
        (global-set-key "\033[5~" 'scroll-down)
        (global-set-key "\033[6~" 'scroll-up)
</PRE>
</CODE></BLOCKQUOTE>
<P>Pour les autres versions :
<P>
<UL>
<LI> 19.19 :

<BLOCKQUOTE><CODE>
<PRE>
        (standard-display-european 1)
        (set-input-mode (car (current-input-mode))
          (nth 1 (current-input-mode))
          0)
</PRE>
</CODE></BLOCKQUOTE>


Lire à ce propos le fichier emacs.info.
</LI>
<LI> 19.22 :

<BLOCKQUOTE><CODE>
<PRE>
        (load-library "iso-transl")
        (standard-display-european t)
</PRE>
</CODE></BLOCKQUOTE>

</LI>
<LI> Autres :

<BLOCKQUOTE><CODE>
<PRE>
        (standard-display-european 1)
        (load-library "iso-transl")
</PRE>
</CODE></BLOCKQUOTE>
</LI>
</UL>
<P>XEmacs les accepte lui par défaut sans broncher mais peut des fois
rencontrer des problèmes avec les BackSpaces dans le mini-buffer en
console.
<P>Ajouter dans le <CODE>.emacs</CODE> :
<BLOCKQUOTE><CODE>
<PRE>
(if (eq window-system 'x)
    (global-set-key (read-kbd-macro "DEL") 'delete-char)
  (or (global-set-key "^[[3~" 'delete-char))
)
</PRE>
</CODE></BLOCKQUOTE>
<P>Le mode ispell d'emacs a un certain nombre de dictionnaires prédéfinis
qui ne sont pas forcement ceux qui sont en place sur le système.
<P>Si vous constatez des problèmes, vous devez redéfinir la liste
ispell-dictionary-alist des dictionnaires.
<P>Cette liste contient :
<UL>
<LI> le nom du dictionnaire</LI>
<LI> la liste des caractères composant un mot</LI>
<LI> la lise opposée des caractères ne composant pas un mot</LI>
<LI> les caractères de liaison à l'intérieur des mots ("-", "'"...)</LI>
<LI> vrai ou faux si ces caractères peuvent être présents en plusieurs
exemplaire dans le mot</LI>
<LI> une liste d'arguments pour ispell</LI>
<LI> le mode d'ispell (tex, nroff..)</LI>
</UL>
<P>Par exemple, dans le fichier <CODE>.emacs</CODE> :
<P>
<BLOCKQUOTE><CODE>
<PRE>
(setq ispell-dictionary-alist
 '((nil  ; francais.aff
  "[A-Za-zÀÂÇ-ËÎÏÔÙÛÜàâç-ëîïôùûü]" "[^A-Za-zÀÂÇ-ËÎÏÔÙÛÜàâç-ëîïôùûü]"
  "[---']" nil ("-n") "~nroff")
 ("english"  ; rosbif
  "[A-Za-z]" "[^A-Za-z]" "[---']" nil ("-B") nil)
 ("american" ; yankee
  "[A-Za-z]" "[^A-Za-z]" "[---']" nil nil nil)
 ("francais" ; français
  "[A-Za-zÀÂÇ-ËÎÏÔÙÛÜàâç-ëîïôùûü]" "[^A-Za-zÀÂÇ-ËÎÏÔÙÛÜàâç-ëîïôùûü]"
  "[---']" nil ("-n") "~nroff")
 ("francais-TeX" ; français
  "[A-Za-zÀÂÇ-ËÎÏÔÙÛÜàâç-ëîïôùûü\\]" "[^A-Za-zÀÂÇ-ËÎÏÔÙÛÜàâç-ëîïôùûü\\]"
  "[---'^`\"]" t nil "~tex")
 ("espanol" ; espa~nol.aff
  "[A-Za-záéíóúüñÁÉÍÓÚÜÑ]" "[^A-Za-záéíóúüñÁÉÍÓÚÜÑ]"
  "[---'^`\"]" t nil "~nroff")
 ("dansk" ; danois et norvégien
  "[A-Za-zåÅøØæÆéÉèÈ]" "[^A-Za-zåÅøØæÆéÉèÈ]"
  "[---'^`\"]" t nil "~nroff")
 ))
</PRE>
</CODE></BLOCKQUOTE>
<P>Le dictionnaire "francais-TeX" est un lien symbolique sur "francais"
qui permet d'ajouter une entrée pour les accents à la TeX (ex: \'e).
<P>Si vous utilisez X11, vous voudrez peut-être reconstruire les menus et
il vous faudra recharger une partie de lisp/loaddefs.el dans votre
<CODE>.emacs</CODE> :
<P>
<BLOCKQUOTE><CODE>
<PRE>
(setq ispell-menu-map nil)

  (if ispell-menu-map-needed
  (let ((dicts (reverse (cons (cons "default" nil) ispell-dictionary-alist)))
    name)
    ;; Can put in defvar when external defines are removed.
    (setq ispell-menu-map (make-sparse-keymap "Spell"))
    (while dicts
  (setq name (car (car dicts))
    dicts (cdr dicts))
  (if (stringp name)
  (define-key ispell-menu-map (vector (intern name))
    (cons (concat "Select " (capitalize name))
  (list 'lambda () '(interactive)
    (list 'ispell-change-dictionary name))))))))

  (if ispell-menu-map-needed
  (progn
    ;; Define commands in opposite order you want them to appear in menu.
    (define-key ispell-menu-map [ispell-change-dictionary]
  '("Change Dictionary" . ispell-change-dictionary))
    (define-key ispell-menu-map [ispell-kill-ispell]
  '("Kill Process" . ispell-kill-ispell))
    (define-key ispell-menu-map [ispell-pdict-save]
  '("Save Dictionary" . (lambda () (interactive) (ispell-pdict-save t))))
    (define-key ispell-menu-map [ispell-complete-word]
  '("Complete Word" . ispell-complete-word))
    (define-key ispell-menu-map [ispell-complete-word-interior-frag]
  '("Complete Word Frag" . ispell-complete-word-interior-frag))
    (define-key ispell-menu-map [ispell-continue]
  '("Continue Check" . ispell-continue))
    (define-key ispell-menu-map [ispell-region]
  '("Check Region" . ispell-region))
    (define-key ispell-menu-map [ispell-word]
  '("Check Word" . ispell-word))
    (define-key ispell-menu-map [ispell-buffer]
  '("Check Buffer" . ispell-buffer))
    (define-key ispell-menu-map [ispell-message]
  '("Check Message" . ispell-message))
    (define-key ispell-menu-map [ispell-help]
  '("Help" . (lambda () (interactive) (describe-function 'ispell-help))))
    (put 'ispell-region 'menu-enable 'mark-active)))

  (fset 'ispell-menu-map (symbol-value 'ispell-menu-map))
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss6.13">6.13 less</A>
</H2>

<P>
<P><CODE>/etc/profile</CODE> ou les fichiers de démarrage du shell (comme
<CODE>.bashrc</CODE> et <CODE>.bash_profile</CODE> dans votre répertoire maison)
doivent contenir :
<P>
<BLOCKQUOTE><CODE>
<PRE>
export LESSCHARSET=latin1
</PRE>
</CODE></BLOCKQUOTE>
<P>Comme fichier <CODE>.lessrc</CODE> je vous recommande :
<P>
<BLOCKQUOTE><CODE>
<PRE>
\e[B    forw-line
\e[A    back-line
\e[6~   forw-scroll
\e[5~   back-scroll
\e[1~   goto-line
\e[4~   goto-end
\e[C    next-file
\e[D    prev-file
\eOA    back-line
\eOB    forw-line
</PRE>
</CODE></BLOCKQUOTE>
<P>Pour rentrer un Esc (parfois nommé Échap) taper « \e » ou, sous
vi, mettez vous en mode insertion avec i puis tapez « ctrl+v » et enfin « Esc ».
<P>Ce fichier permet d'utiliser les touches « Home », « End », « Page_Up » &amp; « Page_Down ».
<P>Pour s'en servir, taper :
<P>
<BLOCKQUOTE><CODE>
<PRE>
lesskey -o .less .lessrc
</PRE>
</CODE></BLOCKQUOTE>
<P>N'oubliez pas de mettre le fichier .less dans votre répertoire maison :
il permet d'employer les touches fléchées, « Page_Up », « Page_Down »,
« Home » et « End ».
<P>Ne pas négliger la page de manuel de less car il peut être intéressant de
changer la valeur de sa variable d'environnement de configuration ("LESS").
<P>J'utilise : '-C -M -i -x2'
<P>
<H2><A NAME="ss6.14">6.14 ls</A>
</H2>

<P>
<P>Utilisez les options :
<P>
<BLOCKQUOTE><CODE>
<PRE>
-N --color=auto
</PRE>
</CODE></BLOCKQUOTE>
<P>ou, plus simplement, définissez dans les fichiers de démarrage de
votre shell les alias suivants permettant de voir les fichiers dont le nom
comprend des caractères 8 bits :
<P>
<BLOCKQUOTE><CODE>
<PRE>
alias ll="ls --color=auto -N -l -a"
alias d="ls --color=auto -N"
</PRE>
</CODE></BLOCKQUOTE>
<P>Un simple <CODE>d</CODE> remplacera le classique <CODE>ls</CODE>, en y ajoutant la
couleur, alors que <CODE>ll</CODE> vous offrira une liste complète de tous
les fichiers présents dans le répertoire, avec leurs attributs,
leurs tailles...
<P>--color=auto est préférable car --color=yes fera avoir des codes escape
lorsqu'on redirige vers un fichier ou un programme où si le terminal ne
supporte pas la couleur.
<P>
<H2><A NAME="ss6.15">6.15 flex</A>
</H2>

<P>
<P>Donnez l'option :
<P>
<BLOCKQUOTE><CODE>
<PRE>
-8
</PRE>
</CODE></BLOCKQUOTE>
<P>si l'analyseur généré doit accepter les entrées 8-bits
(bien sûr qu'il doit le faire !).
<P>
<H2><A NAME="ss6.16">6.16 elm</A>
</H2>

<P>
<P>Rajoutez ces trois lignes dans votre <CODE>.elm/elmrc</CODE> :
<P>
<BLOCKQUOTE><CODE>
<PRE>
  charset = iso-8859-1
  displaycharset = iso-8859-1
  textencoding = 8bit 
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss6.17">6.17 col</A>
</H2>

<P>
<P>Assurez-vous :
<P>1) qu'il a été corrigé et fasse un
<P>
<BLOCKQUOTE><CODE>
<PRE>
setlocale(LC_CTYPE,"");
</PRE>
</CODE></BLOCKQUOTE>
<P>2) de définir
<P>
<BLOCKQUOTE><CODE>
<PRE>
LC_CTYPE=ISO-8859-1
</PRE>
</CODE></BLOCKQUOTE>
<P>dans l'environment.
<P>
<H2><A NAME="ss6.18">6.18 rlogin</A>
</H2>

<P>
<P>Utilisez l'option :
<P>
<BLOCKQUOTE><CODE>
<PRE>
-8
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss6.19">6.19 joe</A>
</H2>

<P>
<P>Utiliser 
<A HREF="ftp://metalab.unc.edu:/pub/Linux/apps/editors/joe-2.8.tar.gz">joe 2.8</A> ou
plus récent qui devraient fonctionner après édition du fichier de
configuration : placer l'option -asis dans <CODE>/usr/lib/joerc</CODE> en
première colonne.
<P>
<H2><A NAME="ss6.20">6.20 TeX et LaTeX</A>
</H2>

<P>
<P>Le plus simple consiste à employer GuTemberg, une distribution de LaTeX
avec tous les défauts réglés pour des francophones par des
francophones !
<P>Mais si vous préférez une version <CODE>standard</CODE> non modifiée, il suffit
d'ajouter au début de chaque fichier :
<P>
<UL>
<LI>Pour LaTeX:

<BLOCKQUOTE><CODE>
<PRE>
\documentstyle[isolatin]{article}
</PRE>
</CODE></BLOCKQUOTE>

</LI>
<LI>Pour LaTeX2e:

<BLOCKQUOTE><CODE>
<PRE>
\documentclass[12pt,a4paper]{letter}
\usepackage{isolatin1}
\usepackage[french]{babel}
\usepackage{t1enc}
</PRE>
</CODE></BLOCKQUOTE>


ou alors :

<BLOCKQUOTE><CODE>
<PRE>
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
</PRE>
</CODE></BLOCKQUOTE>
</LI>
</UL>
<P>Au cas où votre distribution soit trop vieille pour l'inclure,
<CODE>isolatin.sty</CODE> est disponible 
<A HREF="ftp://ftp.vlsivie.tuwien.ac.at/pub/8bit">séparément</A><P>Pour gs et xdvi, il faut utiliser des options spéciales (sur ma machine,
ce sont des alias). En effet, ils sont souvent configurés pour un papier
états-unien dit « légal », de taille proche, mais non exactement égale,
à celle du standard « A4 ».
<P>Ces options sont les suivantes :
<P><CODE>gs -sPAPERSIZE=a4
xdvi -paper a4
ghostview -a4</CODE>
<P>Pour que dvips convertisse les documents dans un format papier a4, il faut
spécifier dans le fichier config.ps (le chemin varie en  fonction des versions
de LaTeX) : /usr/lib/texmf/dvips/config.ps ou <CODE>.dvipsrc</CODE>
<P><CODE>@ a4 210mm 297mm
@+ ! %%DocumentPaperSizes: a4
@+ %%PaperSize: a4
@+ %%BeginPaperSize: a4
@+ a4</CODE>
<P>Sinon ajoutez à votre <CODE>.Xresources</CODE> :
<P>
<BLOCKQUOTE><CODE>
<PRE>
XDvi.paper:             a4
Ghostview.pageMedia:    A4
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss6.21">6.21 Manuel</A>
</H2>

<P>
<P>Tout d'abord, il faut vous procurer les pages de manuel Linux traduites en
<A HREF="ftp://ftp.lip6.fr/pub/linux">français</A><P>Si vous utilisez une distribution RedHat ou Debian, celles-ci sont
présentes sur le cédérom : il suffit de les
sélectionner lors de l'installation.
<P>De là, deux possibilités :
<P>
<UL>
<LI> soit vous ne voulez que des manuels en Français, auquel cas il
faut faire un :

<BLOCKQUOTE><CODE>
<PRE>
export MANPATH=/usr/man/fr_FR
</PRE>
</CODE></BLOCKQUOTE>


NB: fr_FR se remplace par fr_BE, fr_CA, fr_CH ou fr_LU selon le pays concerné.
</LI>
<LI> soit vous préférez par défaut des manuels en
Français et si la page n'existe pas, vous vous rabattez vers l'Anglais,
il suffira alors de taper :

<BLOCKQUOTE><CODE>
<PRE>
export LANG=fr
</PRE>
</CODE></BLOCKQUOTE>
</LI>
</UL>
<P><CODE>man</CODE> ira chercher dans le « MANPATH » des pages en « LANG » par
défaut et se rabattra sinon sur des pages en anglais.
<P>Si vous désirez installer la page de manuel expliquant la norme ISO
8859-15 latin 9, il faut installer le fichier iso_8859_15.7.gz :
<P>
<BLOCKQUOTE><CODE>
<PRE>
cp standard/iso_8859_15.7.gz /usr/local/man/man7/
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss6.22">6.22 Correcteur orthographique ispell</A>
</H2>

<P>
<P>Vous pouvez vous le procurer sur le 
<A HREF="ftp://ftp.ireq-robot.hydro.qc.ca:/pub/ispell/francais-IREQ-1.3.tar.gz">site original d'Hydro Québec</A>
ou sur le 
<A HREF="ftp://ftp.lip6.fr/pub/ispell/francais">mirroir du lip6</A><P>Un fichier LISEZMOI explique pas à pas et en Français
l'installation.
<P>
<H2><A NAME="ss6.23">6.23 Les claviers 105 touches</A>
</H2>

<P>
<P>Aussi appelés « claviers Microsoft (tm) », ils ont trois touches de plus
que les claviers normaux.
<P>Comment s'en servir ?
<P>En mode console, éditer <CODE>french.map</CODE> et décommenter les lignes
en parlant !
<P>De même pour <CODE>french</CODE> (pour Xwindow).
<P>
<H2><A NAME="ss6.24">6.24 PGP</A>
</H2>

<P> 
<P>Attention, dans certains pays totalitaires, l'utilisation de logiciels
de cryptographie est considérée comme usage d'armes de guerre, ce qui
est punissable par la loi !
<P>Sautez donc ce paragraphe si votre législation locale ne permet pas
d'utiliser des logiciels de cryptographie.
<P>Premièrement, il faut se procurer pgp-international (à cause de
problèmes de patentes et de législation sur l'export d'armes de
guerre, il existe pgp-us et pgp-international, ce dernire étant
doté d'un algorithme encore plus puissant) sur le
<A HREF="ftp://ftp.ifi.uio.no/pub/pgp/">site norvégien de PGP</A><P>Ensuite, mettre dans votre répertoire maison, dans un sous
répertoire .pgp les fichiers :
<P>
<BLOCKQUOTE><CODE>
<PRE>
config.txt
language.idx
pgpdoc1.txt
pgpdoc2.txt
language.txt
fr.hlp
en.hlp
pgp.hlp 
</PRE>
</CODE></BLOCKQUOTE>
<P>Enfin, éditer le fichier <CODE>.pgp/config.txt</CODE> pour y rajouter :
<P>
<BLOCKQUOTE><CODE>
<PRE>
Language = fr
CharSet = latin1
</PRE>
</CODE></BLOCKQUOTE>
<P>Lisez ensuite <CODE>.pgp/fr.hlp</CODE> pour apprendre à vous servir de pgp !
<P>
<H2><A NAME="ss6.25">6.25 Impression en mode ascii</A>
</H2>

<P>
<P>Pour l'impression de texte simple, beaucoup d'imprimantes attendent des lettres
en codage IBM (cp850) comme sous MS DOS.
<P>Si le fichier est codé en latin1, on doit utiliser « recode latin1:ibmpc »
(à placer dans les filtres lpr de /etc/ par exemple), sous peine de voir
imprimer des « alpha » à la place de « à », et autres choses du même genre.
<P>Il existe d'autres utilisation au programme <CODE>recode</CODE> : « ibmpc:lat1 » ou
« lat1:ibmpc » (de ou vers MS-DOS) ou « applemac » pour Macintosh (tm).
<P>
<H2><A NAME="ss6.26">6.26 Unicode/latin/cp... je n'ai pas compris ce dernier paragraphe !</A>
</H2>

<P>
<P>Voici donc plus d'explications grâce à Pablo Sartxaga (srtxg à
chanae.alphanet.ch) dans un message explicant la différence Unicode/latin/cp :
<P>
<BLOCKQUOTE><CODE>
<PRE>
 DB>   quand on lance « setfont » sans argument
 DB>   il semble qu'on obtienne le même effet que setfont -u none

Normal et logique.

 DB>   --> en un mot la table de conversion « Unicode » est désactivée
 DB>       ce qui transforme le « e accent aigü (dec 130) » en « théta (dec 233) »

Non. Il ne transforme rien du tout, il affiche tout simplement sans 
*aucune* transformation au contraire, à toi de t'assurer que la police
que tu charges possèdes les glyphes à la bonne place par rapport au codage
de caractères que tu utilises (iso-8859-1).

Autrement dit si ta police n'est pas iso-8859-1 tu dois dire à setfont de
faire des mappings; en particulier s ic'est une police qui utilise l'encodage
DOS cp437 tu fais « setfont -u cp437 nomdelapolice ». Moi par exemple j'aime
beaucoup la police « t.fnt » de la Slackware, et j'ai donc quelque part
dans /etc/rc.d/* une ligne « setfont -u cp437 t.fnt »

Ou alors tu modifies la police (il y a un logiciel qui fait cela avec
interface svgalib, et un autre nommé « chedit » qui permet de créer des
images an ascii-art, un fichier par caractère (256 fichiers donc), il te
suffit alors de jongler avec les fichiers pour les changer de place et
régénerer la police).  Note cependant que le codage cp437 n'inclut pas
tous les caractères de iso-8859-1, notamment manquent quasi toutes les
majuscules accentuées, et les lettres ãõ nécessaires en portugais. Tu
peux toujours modifier la police pour créer ces caractères manquants.

 DB>   sur ma Slackware 3.2, à aucun moment setfont n'apparaît dans les scripts
 DB>   de démarrage ni dans les ~/profiles et autres ~/.bashrc

Donc c'est la police dans la ROM de la carte video qui est utilisée.

 DB>   et pourtant cette
 DB>   conversion est effectuée correctement puisque j'ai les accents à l'écran.

Je suppose que le kernel présuppose (à juste titre) que la police en ROM vidéo
est au codage cp437.

 DB>        une fois que je lance « setfont -u none » je perds donc les accents.

Normal, car dès lors que tu charges une police tu est supposé savoir ce que
tu veux (au contraire de la police en ROM où tu n'as pas le choix).

Autrefois (du temps des 1.2.* et avant) le défaut de setfont était cp437
(et il n'utilisait pas encore des tables Unicode, mais on pouvait
changer par \e(B et \e(K entre codage cp437 et iso (on peut toujours 
d'ailleurs)), mais maintenant le défaut est « straight to font », pas de
conversion.

 DB>            j'en conclue que Linux utilise la police résidente par défaut de
 DB>            la carte EGA/VGA

 DB>        [Q] --> comment retrouver cette police ?

Il y a un programme nommé « restoretextmode » qui est assez populaire
auprès des possesseurs de certaines cartes graphiques chez qui le
passage X11 -> console bousille les polices; il permet de faire un dump
sur un fichier; il faudrait donc que tu le lances avant de modifier la
police avec setfont. Le paquetage s'appelle quelque chose comme
SVGATextMode ou quelque chose d'approchant.

 DB>     [Q] --> quelle table appeler pour la remapper et ravoir les accents ?

setfont -u cp437 policedos

Ou sinon, si tu ne veux pas lancer setfont et tu veux donc garder la
police de la carte graphique; essaye un « echo -e \033(B » (l'ennuyant
c'est que tu dois le faire dans chaque console)

 DB>                 (en général setfont -u def.uni (par exemple) renvoie une
 DB>                  erreur : PIO_UNIMAPCLR: Invalid argument et je reste
 DB>                  en caracteres « graphiques »)

Ah ? Chez moi ça marche; quels kernel et kbd as-tu ?

Sinon je te conseille « cp437 » plutôt que « def », ils font _presque_ la même
chose, mais « cp437 » est visuellement plus agréable car il remplace les
caractères non présents dans la police par les lettres non accentuées si c'est
des lettres, C pour © et R pour ® et par un carré blanc pour le reste, ce qui
permet de garder le formatage et la lecture agréables; « def » lui ne mets
totu simplement rien pour les caractères manquants, si bien que tu te
trouves avec des trous, ce qui est l'horreur si tu édites un texte par
exemple avec vi, puisque le curseur est affiché plusieurs caractères
à gauche à cause des caractères de largeur nulle :) 

Essaye aussi la police « t.fnt », elle est assez jolie, toute en rondeurs, je la
trouve réposante, et quand je dois utiliser un PC avec les polices style 
courier par défaut je trouve ça très agressif je me demande comment ils
peuvent travailler avec :)
</PRE>
</CODE></BLOCKQUOTE>
<P>Lire aussi les articles de news : « FAQ - les accents français et Usenet»  de F.
Yergeau dans les groupes fr.usenet.reponses et fr.usenet.8bits » ISO
8859-1 National Character Set FAQ» de mike (à) vlsivie.tuwien.ac.at dans
comp.answers .
<P>
<H2><A NAME="ss6.27">6.27 ncurses</A>
</H2>

<P>
<P>Rappelons que ncurses est un librairie C qui permet de manipuler facilement
l'affichage en mode console texte : fenêtrage, lignes de saisie, édition de
formulaires, couleurs, caractères « ALT » ascii semi-graphique ibm, comme sous
dos...
<P>
<H3>Introduction</H3>

<P>
<P>La version standard de curses utilise le huitième bit pour la vidéo
inversée (voir le flag _STANDOUT défini dans /usr/include/curses.h).
Cependant, ncurses semble fonctionner en 8-bits et affiche le
iso-latin-8859-1 correctement.
<P>
<H3>Les accents</H3>

<P>
<P>Remarque: les distributions de Linux sont livrées en général avec la
version 1.9.9e de ncurses, or il se trouve que la librairie form de
cette version est BUGGÉE (problèmes de rafraîchissement des fenêtres).
<P>Ne pas utiliser la 1.9.9e donc si on veut travailler avec « form » : ce bug est
d'ailleurs clairement énoncé sur le site de ncurses, et je m'étonne que
ce soit justement cette version qui soit encore livrée sur la plupart
des distributions (RedHat 4.2, 5.0, 5.1, Slackware 3.2, Debian 1.9) en
tout cas.
<P>Symptôme : la fonction  wgetch() de ncurses renvoie les codes suivants :
<P>
<UL>
<LI> je tape 'é' et wgetch retourne  « meta-i »    code 233 (decimal)</LI>
<LI>  "  "   'è' "    "        "     « meta-h »    code 234 (decimal)</LI>
<LI> etc</LI>
</UL>
<P>C'est normal avec les polices iso-8859-1 !
<P>Il faut installer les « locales » ou mettre à jour sa version de
ncurses.
<P>
<H2><A NAME="ss6.28">6.28 Perl</A>
</H2>

<P>
<P>Si tout d'un coup après une mise à jour il raconte :
<P>
<BLOCKQUOTE><CODE>
<PRE>
(guylhem@victis:guylhem)$ perl
perl: warning: Setting locale failed for the categories:
        LC_CTYPE LC_COLLATE
perl: warning: Please check that your locale settings:
        LC_ALL = "fr_FR",
        LC_CTYPE = "ISO-8859-1",
        LC_COLLATE = (unset),
        LANG = "fr"
    are supported and installed on your system.
perl: warning: Falling back to the "C" locale.
(guylhem@victis:guylhem)$
</PRE>
</CODE></BLOCKQUOTE>
<P>En libc6 le format des fichiers binaires de définition des locales a
(encore) changé : il faut les régénérer à partir des sources 
<A HREF="ftp://ftp.lip6.fr:/pub/linux/GCC">sources WG15collection.tar.gz</A> par exemple et des programmes «
locale » et « localedef » qui sont fournis dans les sources de la libc.
<P>Sinon on peut également se passer des locales :
<P>
<BLOCKQUOTE><CODE>
<PRE>
     unset LANG
     unset LC_CTYPE
     unset LC_COLLATE
     export LC_ALL=fr_FR.ISO-8859-1
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss6.29">6.29 Installer les locales</A>
</H2>

<P>
<P>Les « locales » sont des fichiers qui vont modifier le comportement de
certains programmes pour qu'ils s'adaptent aux « spécificités culturelles du
pays ».
<P>Cela sert à résoudre les erreurs rapportées par perl ou une mauvaise
gestion des accents par ncurses.
<P>
<UL>
<LI> récupérer pour la libc5 la collection de
<A HREF="ftp://ftp.lip6.fr/pub/linux/GCC/WG15-collection.linux.tar.gz">locales POSIX</A></LI>
<LI> ou pour la libc6, elle est dans l'ajout
<A HREF="ftp://ftp.lip6.fr/pub/gnu/glibc-localedata-2.0.6.tar.gz">« glibc-localedata »</A></LI>
<LI> copier dans le répertoire /usr/share/locale les fichiers fr_FR et en_DK
(qui est inclus dans fr_FR)</LI>
<LI> créer le répertoire /usr/share/i18n/charmap et copier le fichier
ISO_8859-1:1987</LI>
<LI> faire man localedef et lancer la commande :

<BLOCKQUOTE><CODE>
<PRE>
          localedef -f ISO_8859-1:1987 -i fr_FR fr
</PRE>
</CODE></BLOCKQUOTE>


Ceci créera l'entrée fr dans /usr/share/locale soit :

<BLOCKQUOTE><CODE>
<PRE>
        /usr/share/locale/fr
</PRE>
</CODE></BLOCKQUOTE>


Ce répertoire devrait maintenant contenir les fichiers :

<BLOCKQUOTE><CODE>
<PRE>
         LC_COLLATE
         LC_CTYPE
         LC_MESSAGES
         LC_MONETARY
         LC_NUMERIC
         LC_TIME
</PRE>
</CODE></BLOCKQUOTE>

</LI>
<LI> lire le fichier « locale.fr » que l'on peut trouver sur le serveur
ftp.lip6.fr (chercher sous doc, linux...) et dont la traduction française a été
faite par &Eacute;ric DUMAS (hélas ce doc ne traite principalement que de
LC_MESSAGES. À quand la suite Éric ? ;-) )
</LI>
<LI> compléter éventuellement l'initialisation des variables du shell comme
décrit dans la section sur bash ou tcsh</LI>
<LI> dans un programme, utilisez la fonction  setlocale() (man setlocale.3)
pour fixer les paramètres locaux CAR le noyau linux initialise toujours cette
fonction avec l'argument une locale « C » (POSIX) donc sans accents !

<BLOCKQUOTE><CODE>
<PRE>
          setlocale(LC_CTYPE,"fr_FR");
</PRE>
</CODE></BLOCKQUOTE>

</LI>
<LI> Ça y est ! Les accents sont disponibles dans ncurses.</LI>
</UL>
<P>
<H3>Midnight Commander (mc)</H3>

<P>
<P>En changeant de police, il peut arriver que les lignes de cadre soient
remplacées par divers caractères.
<P>2 possibilitées :
<UL>
<LI> La police chargée ne dispose pas de caractères dits « semi
graphiques », qui permettent de dessiner des cadres</LI>
<LI> Il y a discordance entre la police et sa table de mappage</LI>
</UL>
<P>Pour le premier cas, la seule solution est de changer de police, mais
dans le second cas, il suffit en général de charger la table avec
loadunimap par exemple :
<P>
<BLOCKQUOTE><CODE>
<PRE>
          loadunimap lat1u.uni
          loadunimap lat5u.uni
          loadunimap lat9u.uni
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss6.30">6.30 Kernel</A>
</H2>

<P>
<P>Pour mettre un support pour le clavier français directement dans le
kernel, ce qui est pratique pour les systèmes embarqués ou ne démarrant que sur
disquettes, afin de gagner le maximum de place :
<P>
<BLOCKQUOTE><CODE>
<PRE>
/usr/bin/loadkeys loadkeys --mktable votre-table-de-clavier.map > /usr/src/linux/drivers/char/defkeymap.c
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss6.31">6.31 Lilo</A>
</H2>

<P>
<P>Depuis la version 20, on peut spécifier un clavier (français, par
exemple) au démarrage de LILO.
<P>Bien sur, cela ne fait qu'échanger quelques touches (a/q,m/:,... pour un
clavier fr) mais cela est assez utile lorsque l'on veut taper « win ».
<P>Je vous conseille toutefois de ne pas faire de label utilisant des
touches qui diffèrent entre l'AZERTY et le QWERTY, ne serait-ce que si
vous devez avoir un jour un autre utilisateur sur votre ordinateur...
<P>Il est plus simple de faire des labels courts et d'utiliser des
programmes comme GAG ou GRUB, remplaçant fort avantageusement les lignes
de lilo par un magnifique menu graphique dans le cas de GAG.
<P>
<H2><A NAME="ss6.32">6.32 Groff (man)</A>
</H2>

<P>
<P>Sur certaines distributions, le programme man n'est pas configuré pour
afficher les accents.
<P>Si vous rencontrez ce problème, éditez son fichier de configuration
(/etc/man.config sur les distributions actuelles) et localisez une ligne
ressemblant à cela :
<P>
<BLOCKQUOTE><CODE>
<PRE>
NROFF           /usr/bin/groff -Tascii -mandoc
</PRE>
</CODE></BLOCKQUOTE>
<P>Remplacez-là par :
<P>
<BLOCKQUOTE><CODE>
<PRE>
NROFF           /usr/bin/groff -Tlatin1 -mandoc
</PRE>
</CODE></BLOCKQUOTE>
<P>Les vieilles versions de man utilisent aussi col, et le point suivant
s'applique aussi.
<P>
<H2><A NAME="ss6.33">6.33 Divers</A>
</H2>

<P>
<P>Une belle discussion sur le thème de l'ISO-8859-1 et sur « comment
manipuler les caractères 8-bits » est
<A HREF="ftp://grasp.insa-lyon.fr/pub/faq/fr/accents">disponible</A><P>
<HR>
<A HREF="Francophones-HOWTO-7.html"><IMG SRC="../img/next.gif" ALT="Next"></A>
<A HREF="Francophones-HOWTO-5.html"><IMG SRC="../img/prev.gif" ALT="Previous"></A>
<A HREF="Francophones-HOWTO.html#toc6"><IMG SRC="../img/toc.gif" ALT="Contents"></A>
<SCRIPT>EndPage();</SCRIPT>  </BODY>
</HTML>
